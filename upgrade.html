<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Blacksmith - Kaden's Dungeon Game</title>
        <link rel="stylesheet" type="text/css" href="style.css">
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/5/w3.css">
        <link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-blue.css">
        <style>
            .upgrade-container {
                display: none;
                padding: 20px;
                max-width: 1600px;
                margin: 0 auto;
            }

            .upgrade-container.active {
                display: block;
            }

            .party-equipment-grid {
                display: grid;
                grid-template-columns: repeat(5, 1fr);
                gap: 20px;
                margin-bottom: 30px;
            }

            .member-column {
                background: rgba(15, 52, 96, 0.3);
                border: 2px solid #0f3460;
                border-radius: 10px;
                padding: 15px;
            }

            .member-name {
                text-align: center;
                font-size: 1.3em;
                color: #e94560;
                margin-bottom: 15px;
                font-weight: bold;
            }

            .member-level {
                text-align: center;
                font-size: 1em;
                color: #aaa;
                margin-bottom: 10px;
            }

            .equipment-slots {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .equip-slot {
                background: rgba(0, 0, 0, 0.4);
                border: 2px solid #555;
                border-radius: 8px;
                padding: 10px;
                cursor: pointer;
                transition: all 0.3s;
                min-height: 80px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }

            .equip-slot:hover {
                border-color: #e94560;
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(233, 69, 96, 0.3);
            }

            .equip-slot.empty {
                opacity: 0.5;
                cursor: default;
            }

            .equip-slot.empty:hover {
                border-color: #555;
                transform: none;
                box-shadow: none;
            }

            .slot-label {
                font-size: 0.85em;
                color: #888;
                margin-bottom: 5px;
            }

            .item-name {
                font-weight: bold;
                color: #fff;
                margin-bottom: 3px;
            }

            .item-level {
                font-size: 0.9em;
                color: #aaa;
            }

            .enchant-indicator {
                font-size: 0.85em;
                color: #ffcc00;
                margin-top: 5px;
            }

            .upgrade-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 3000;
                padding: 20px;
            }

            .upgrade-modal.active {
                display: flex;
            }

            .upgrade-modal-content {
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                border: 3px solid #e94560;
                border-radius: 15px;
                padding: 30px;
                max-width: 600px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
                position: relative;
            }

            .upgrade-close {
                position: absolute;
                top: 15px;
                right: 15px;
                background: #e94560;
                color: #fff;
                border: none;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                font-size: 1.5em;
                cursor: pointer;
                font-weight: bold;
            }

            .upgrade-close:hover {
                background: #ff6b88;
            }

            .upgrade-header {
                text-align: center;
                margin-bottom: 25px;
            }

            .upgrade-header h2 {
                font-size: 2em;
                margin-bottom: 10px;
            }

            .upgrade-image {
                text-align: center;
                margin: 20px 0;
            }

            .upgrade-image img {
                max-width: 150px;
                max-height: 150px;
                border: 3px solid;
                border-radius: 10px;
                box-shadow: 0 0 20px currentColor;
            }

            .upgrade-info {
                background: rgba(15, 52, 96, 0.3);
                border: 2px solid #0f3460;
                border-radius: 10px;
                padding: 20px;
                margin-bottom: 20px;
            }

            .info-row {
                display: flex;
                justify-content: space-between;
                padding: 10px 0;
                border-bottom: 1px solid #0f3460;
            }

            .info-row:last-child {
                border-bottom: none;
            }

            .info-label {
                font-weight: bold;
                color: #aaa;
            }

            .info-value {
                color: #fff;
            }

            .upgrade-button {
                width: 100%;
                background: linear-gradient(135deg, #e94560 0%, #ff6b88 100%);
                color: #fff;
                border: 2px solid #fff;
                border-radius: 8px;
                padding: 15px 20px;
                font-size: 1.2em;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s;
                margin-top: 15px;
            }

            .upgrade-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(233, 69, 96, 0.5);
            }

            .enchant-section {
                background: rgba(255, 204, 0, 0.1);
                border: 2px solid #ffcc00;
                border-radius: 10px;
                padding: 15px;
                margin-top: 15px;
            }

            .enchant-title {
                color: #ffcc00;
                font-weight: bold;
                font-size: 1.2em;
                margin-bottom: 10px;
            }

            .no-enchant {
                color: #888;
                font-style: italic;
            }
        </style>
    </head>
<body id="blacksmith">
    <!-- Main Selection Screen -->
    <div class="w3-container w3-auto" id="selection-screen">
          
          <div class="w3-container w3-left" style="width:50%">
            <a href="home.html"><h2 class="glow">Back</h2></a>
        </div>
        
        <div class="w3-row">
            <div class="w3-col m4">
                <h2 class="glow clickable" onclick="showCraftScreen()">Craft</h2>
                <img src="Assests/smelting.png" alt="img">
            </div>
            
            <div class="w3-col m4">
                <h2 class="glow clickable2" onclick="showUpgradeScreen()">Upgrade</h2>
                <img src="Assests/anvil.png" alt="img">
            </div>
            
            <div class="w3-col m4">
                <h2 class="glow clickable" onclick="showAttacksScreen()">Attacks</h2>
                <img src="Animations/gust/6.png" alt="img">
            </div>
        </div>
    </div>
    
    <!-- Craft Screen -->
    <div class="upgrade-container" id="craft-screen">
        <div class="w3-container w3-left" style="width:50%">
            <a href="#" onclick="hideCraftScreen(); return false;"><h2 class="glow">‚Üê Back</h2></a>
        </div>

        <h1 class="glow" style="text-align: center; margin: 20px 0;">Craft Mythical Items</h1>
        
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="display: inline-block; background: rgba(0, 200, 255, 0.2); border: 3px solid #00c8ff; border-radius: 15px; padding: 15px 30px;">
                <span style="color: #00c8ff; font-size: 1.5em; font-weight: bold;">üíé Gems: </span>
                <span id="craft-gem-count" style="color: #fff; font-size: 1.8em; font-weight: bold;">0</span>
            </div>
        </div>

        <div id="craft-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 25px; max-width: 1600px; margin: 0 auto; padding: 20px;">
            <!-- Craft recipes will be rendered here -->
        </div>
    </div>
    
    <!-- Upgrade Screen -->
    <div class="upgrade-container" id="upgrade-screen">
        <div class="w3-container w3-left" style="width:50%">
            <a href="#" onclick="hideUpgradeScreen(); return false;"><h2 class="glow">‚Üê Back</h2></a>
        </div>

        <h1 class="glow" style="text-align: center; margin: 20px 0;">Enchant Equipment</h1>

        <div class="party-equipment-grid" id="party-equipment">
            <!-- Party member equipment will be rendered here -->
        </div>
    </div>
    
    <!-- Attacks Shop Screen -->
    <div class="upgrade-container" id="attacks-screen">
        <div class="w3-container w3-left" style="width:50%">
            <a href="#" onclick="hideAttacksScreen(); return false;"><h2 class="glow">‚Üê Back</h2></a>
        </div>

        <h1 class="glow" style="text-align: center; margin: 20px 0;">Special Attacks Shop</h1>
        
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="display: inline-block; background: rgba(0, 200, 255, 0.2); border: 3px solid #00c8ff; border-radius: 15px; padding: 15px 30px;">
                <span style="color: #00c8ff; font-size: 1.5em; font-weight: bold;">üíé Gems: </span>
                <span id="gem-count" style="color: #fff; font-size: 1.8em; font-weight: bold;">0</span>
            </div>
        </div>

        <div id="attacks-shop-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 25px; max-width: 1400px; margin: 0 auto; padding: 20px;">
            <!-- Attack cards will be rendered here -->
        </div>
    </div>

    <!-- Upgrade Modal -->
    <div class="upgrade-modal" id="upgrade-modal">
        <div class="upgrade-modal-content">
            <button class="upgrade-close" onclick="closeUpgradeModal()">√ó</button>
            <div id="upgrade-modal-body"></div>
        </div>
    </div>

    <footer>
        Kaden Cruts - 2025
    </footer>

    <script src="script.js"></script>
    <script>
        // Music system for upgrade page
        let upgradeMusic = null;
        
        function playUpgradeMusic() {
            const musicEnabled = localStorage.getItem('musicEnabled') === 'true';
            if (!musicEnabled) return;
            
            if (upgradeMusic) {
                upgradeMusic.pause();
                upgradeMusic = null;
            }
            
            upgradeMusic = new Audio('audio/background/swingingLevel.wav');
            upgradeMusic.loop = true;
            upgradeMusic.volume = 0.5;
            
            // Restore playback position from localStorage
            const savedPosition = parseFloat(localStorage.getItem('swingingLevel_position')) || 0;
            upgradeMusic.currentTime = savedPosition;
            
            // Save position periodically
            upgradeMusic.addEventListener('timeupdate', () => {
                localStorage.setItem('swingingLevel_position', upgradeMusic.currentTime.toString());
            });
            
            // Try to play immediately
            const playPromise = upgradeMusic.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('Upgrade music playing');
                }).catch(err => {
                    console.log('Autoplay prevented, waiting for user interaction:', err);
                    // Wait for any user interaction to start music
                    const startMusic = () => {
                        if (upgradeMusic && localStorage.getItem('musicEnabled') === 'true') {
                            upgradeMusic.play().catch(e => console.error('Failed to play music:', e));
                            document.removeEventListener('click', startMusic);
                            document.removeEventListener('keydown', startMusic);
                        }
                    };
                    document.addEventListener('click', startMusic);
                    document.addEventListener('keydown', startMusic);
                });
            }
        }
        
        // Start music when page loads
        window.addEventListener('DOMContentLoaded', () => {
            playUpgradeMusic();
            loadAttackCosts();
        });
        
        // Load saved attack costs from localStorage
        function loadAttackCosts() {
            const savedCosts = localStorage.getItem('attackCosts');
            if (savedCosts && typeof SPECIAL_ATTACKS !== 'undefined') {
                try {
                    const costMap = JSON.parse(savedCosts);
                    Object.keys(costMap).forEach(key => {
                        if (SPECIAL_ATTACKS[key]) {
                            SPECIAL_ATTACKS[key].cost = costMap[key];
                        }
                    });
                    console.log('Loaded saved attack costs from localStorage');
                } catch (err) {
                    console.error('Failed to load attack costs:', err);
                }
            }
        }
        
        // Sound effect helper
        function playSoundEffect(soundName) {
            const musicEnabled = localStorage.getItem('musicEnabled') === 'true';
            if (!musicEnabled) return;
            
            const audio = new Audio(`audio/soundEffects/${soundName}.wav`);
            audio.volume = 0.5;
            audio.play().catch(err => console.log('Could not play sound:', err));
        }
        
        // Enchantment definitions
        const ENCHANTMENTS = {
            "Sharpness": {
                type: "attack_potency",
                description: "Increases attack damage by 15%",
                strBonus: 0.15,
                magBonus: 0.15
            },
            "Lifesteal": {
                type: "ability",
                description: "Grants Lifesteal ability - heal for 15% of damage dealt",
                abilityEffect: "leech"
            },
            "Burning": {
                type: "status_duration",
                description: "Burn status lasts 2 extra turns",
                statusType: "burn",
                durationBonus: 2
            },
            "Fortification": {
                type: "stat_boost",
                description: "+20 Defense",
                defense: 20
            },
            "Swiftness": {
                type: "stat_boost",
                description: "+15 Speed",
                speed: 15
            },
            "Vitality": {
                type: "stat_boost",
                description: "+50 Max Health",
                health: 50
            },
            "Hemorrhage": {
                type: "ability",
                description: "Grants Bleed ability - attacks apply bleed status",
                abilityEffect: "bleed"
            },
            "Precision": {
                type: "attack_potency",
                description: "Increases critical strike chance by 20%",
                critBonus: 0.20
            },
            "Arcane Power": {
                type: "stat_boost",
                description: "+25 Magic Power",
                magic: 25
            },
            "Berserker": {
                type: "stat_boost",
                description: "+25 Strength",
                strength: 25
            },
            // Basic Enchantments
            "Resilience": {
                type: "stat_boost",
                description: "+30 Max Health and +10 Defense",
                health: 30,
                defense: 10
            },
            "Haste": {
                type: "stat_boost",
                description: "+20 Speed",
                speed: 20
            },
            "Frost": {
                type: "status_effect",
                description: "Attacks apply chill status - reduces enemy speed",
                statusEffect: "chill"
            },
            "Vengeance": {
                type: "stat_boost",
                description: "+15 Strength and +15 Magic",
                strength: 15,
                magic: 15
            },
            "Warding": {
                type: "stat_boost",
                description: "+25 Defense",
                defense: 25
            },
            // Legendary Enchantments
            "Multistrike": {
                type: "ability",
                description: "üåü LEGENDARY: Grants MultiStrike ability - attack twice per turn",
                abilityEffect: "multistrike",
                legendary: true
            },
            "Soulrend": {
                type: "ability",
                description: "üåü LEGENDARY: Grants Grim ability - 50% chance to execute low HP enemies instantly",
                abilityEffect: "grim",
                legendary: true
            },
            "Phoenix Rebirth": {
                type: "ability",
                description: "üåü LEGENDARY: Once per battle, revive at 50% HP when defeated",
                abilityEffect: "phoenix",
                legendary: true
            },
            "Temporal Flux": {
                type: "ability",
                description: "üåü LEGENDARY: Grants Aftershock - immune to next attack after dealing damage (2 turn cooldown)",
                abilityEffect: "aftershock",
                legendary: true
            },
            "Chaos Storm": {
                type: "ability",
                description: "üåü LEGENDARY: Attacks apply random status effects and deal bonus chaos damage",
                abilityEffect: "chaos",
                legendary: true
            }
        };

        function showUpgradeScreen() {
            hideAllScreens();
            document.getElementById('upgrade-screen').classList.add('active');
            renderPartyEquipment();
        }

        function hideUpgradeScreen() {
            document.getElementById('upgrade-screen').classList.remove('active');
            document.getElementById('selection-screen').style.display = 'block';
        }

        function showAttacksScreen() {
            hideAllScreens();
            document.getElementById('attacks-screen').classList.add('active');
            renderAttacksShop();
        }
        
        function hideAttacksScreen() {
            document.getElementById('attacks-screen').classList.remove('active');
            document.getElementById('selection-screen').style.display = 'block';
        }
        
        function renderAttacksShop() {
            const container = document.getElementById('attacks-shop-grid');
            const gemCount = document.getElementById('gem-count');
            
            if (!container) return;
            
            // Update gem display
            const currentGems = typeof GEMS !== 'undefined' ? GEMS : 0;
            if (gemCount) gemCount.textContent = currentGems;
            
            // Get special attacks from script.js
            const attacks = typeof SPECIAL_ATTACKS !== 'undefined' ? SPECIAL_ATTACKS : {};
            
            let html = '';
            
            for (const attackKey in attacks) {
                const attack = attacks[attackKey];
                const owned = hasAttack(attack.name);
                const canAfford = currentGems >= attack.cost;
                
                const bgGradient = owned 
                    ? 'linear-gradient(135deg, rgba(46, 125, 50, 0.3) 0%, rgba(27, 94, 32, 0.3) 100%)'
                    : 'linear-gradient(135deg, rgba(15, 52, 96, 0.3) 0%, rgba(22, 33, 62, 0.3) 100%)';
                
                const borderColor = owned ? '#4caf50' : (canAfford ? '#00c8ff' : '#666');
                
                html += `
                    <div style="background: ${bgGradient}; border: 3px solid ${borderColor}; border-radius: 15px; padding: 25px; transition: all 0.3s;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h2 style="color: ${borderColor}; margin: 0; font-size: 1.5em;">${attack.icon} ${attack.name}</h2>
                            ${owned ? '<div style="background: #4caf50; color: #fff; padding: 5px 15px; border-radius: 20px; font-weight: bold;">OWNED</div>' : ''}
                        </div>
                        
                        <p style="color: #aaa; margin: 15px 0; font-size: 1.05em;">${attack.description}</p>
                        
                        <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px; margin: 15px 0;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div>
                                    <div style="color: #888; font-size: 0.9em;">Strength Multiplier</div>
                                    <div style="color: #e94560; font-weight: bold; font-size: 1.2em;">${attack.strMultiplier}x</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 0.9em;">Magic Multiplier</div>
                                    <div style="color: #5c7cfa; font-weight: bold; font-size: 1.2em;">${attack.magicMultiplier}x</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 0.9em;">Type</div>
                                    <div style="color: #ffcc00; font-weight: bold;">${attack.aoe ? 'AOE' : 'Single Target'}</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 0.9em;">Status Effect</div>
                                    <div style="color: #ff6b88; font-weight: bold;">${attack.statusEffect ? attack.statusEffect.toUpperCase() : 'None'}</div>
                                </div>
                            </div>
                        </div>
                        
                        ${owned 
                            ? '<button disabled style="width: 100%; padding: 15px; background: #666; color: #aaa; border: none; border-radius: 10px; font-size: 1.1em; font-weight: bold; cursor: not-allowed;">Already Purchased</button>'
                            : `<button onclick="purchaseAttack('${attackKey}')" 
                                style="width: 100%; padding: 15px; background: ${canAfford ? 'linear-gradient(135deg, #00c8ff 0%, #0099cc 100%)' : '#666'}; color: ${canAfford ? '#fff' : '#aaa'}; border: none; border-radius: 10px; font-size: 1.1em; font-weight: bold; cursor: ${canAfford ? 'pointer' : 'not-allowed'}; transition: all 0.3s;"
                                ${!canAfford ? 'disabled' : ''}
                                ${canAfford ? `onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0, 200, 255, 0.5)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';"` : ''}>
                                üíé Purchase for ${attack.cost} Gems
                            </button>`
                        }
                    </div>
                `;
            }
            
            if (Object.keys(attacks).length === 0) {
                html = '<div style="text-align: center; color: #888; padding: 50px;"><h2>No special attacks available yet!</h2></div>';
            }
            
            container.innerHTML = html;
        }
        
        function hasAttack(attackName) {
            // Check if any party member has this attack
            if (typeof PARTY_ATTACKS === 'undefined') return false;
            
            for (const memberKey of ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE']) {
                const memberAttacks = PARTY_ATTACKS[memberKey];
                if (memberAttacks && memberAttacks.ATTACK_INVENTORY) {
                    const found = memberAttacks.ATTACK_INVENTORY.find(a => a.name === attackName);
                    if (found) return true;
                }
            }
            return false;
        }
        
        function purchaseAttack(attackKey) {
            const attacks = typeof SPECIAL_ATTACKS !== 'undefined' ? SPECIAL_ATTACKS : {};
            const attack = attacks[attackKey];
            
            if (!attack) {
                alert('Attack not found!');
                return;
            }
            
            const currentGems = typeof GEMS !== 'undefined' ? GEMS : 0;
            
            if (currentGems < attack.cost) {
                alert(`Not enough gems! You need ${attack.cost} gems but only have ${currentGems}.`);
                return;
            }
            
            if (hasAttack(attack.name)) {
                alert('You already own this attack!');
                return;
            }
            
            // Confirm purchase
            if (!confirm(`Purchase ${attack.name} for ${attack.cost} gems?`)) {
                return;
            }
            
            // Deduct gems
            if (typeof GEMS !== 'undefined') {
                GEMS -= attack.cost;
            } else {
                window.GEMS = 0;
            }
            
            // Double the cost of all remaining attacks after purchase
            if (typeof SPECIAL_ATTACKS !== 'undefined') {
                Object.keys(SPECIAL_ATTACKS).forEach(key => {
                    if (SPECIAL_ATTACKS[key].cost) {
                        SPECIAL_ATTACKS[key].cost = Math.round(SPECIAL_ATTACKS[key].cost * 2);
                    }
                });
                
                // Save updated costs to localStorage
                const costMap = {};
                Object.keys(SPECIAL_ATTACKS).forEach(key => {
                    if (SPECIAL_ATTACKS[key].cost) {
                        costMap[key] = SPECIAL_ATTACKS[key].cost;
                    }
                });
                localStorage.setItem('attackCosts', JSON.stringify(costMap));
            }
            
            // Add attack to ALL party members
            if (typeof PARTY_ATTACKS !== 'undefined' && typeof attackCounter !== 'undefined') {
                for (const memberKey of ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE']) {
                    if (!PARTY_ATTACKS[memberKey]) {
                        PARTY_ATTACKS[memberKey] = { ATTACK_INVENTORY: [], ATTACK_EQUIPPED: new Set() };
                    }
                    
                    const newAttack = {
                        id: attackCounter++,
                        name: attack.name,
                        strMultiplier: attack.strMultiplier,
                        magicMultiplier: attack.magicMultiplier,
                        aoe: attack.aoe || false,
                        statusEffect: attack.statusEffect || null,
                        sourceUid: null,
                        itemName: null,
                        special: true  // Mark as special purchasable attack
                    };
                    
                    PARTY_ATTACKS[memberKey].ATTACK_INVENTORY.push(newAttack);
                }
            }
            
            // Save game data
            if (typeof saveGameData === 'function') {
                saveGameData();
            }
            
            // Refresh display
            renderAttacksShop();
            
            alert(`${attack.icon} ${attack.name} purchased! All party members now have access to this attack.`);
        }

        function renderPartyEquipment() {
            const container = document.getElementById('party-equipment');
            if (!container) return;

            let html = '';
            const members = ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE'];
            const slotOrder = ['HELMET', 'CHEST', 'LEGS', 'BOOTS', 'MAINHAND', 'OFFHAND'];

            members.forEach(memberKey => {
                const member = PARTY_STATS[memberKey];
                if (!member) return;

                html += `
                    <div class="member-column">
                        <div class="member-name">${member.NAME}</div>
                        <div class="member-level">Level ${member.LEVEL || 1}</div>
                        <div class="equipment-slots">
                `;

                slotOrder.forEach(slot => {
                    const itemName = member[slot];
                    
                    if (itemName && itemName !== null) {
                        const item = INVENTORY.find(i => i.name === itemName);
                        if (item) {
                            const rarity = item.rarity || 'Common';
                            const color = getRarityColor(rarity);
                            const enchant = item.enchantment || null;
                            let enchantDisplay = '';
                            if (enchant) {
                                const isLegendary = ['Multistrike', 'Soulrend', 'Phoenix Rebirth', 'Temporal Flux', 'Chaos Storm'].includes(enchant);
                                const enchantColor = isLegendary ? '#ff8000' : '#ffcc00';
                                const icon = isLegendary ? 'üåü' : '‚ú®';
                                enchantDisplay = `<div class="enchant-indicator" style="color: ${enchantColor};">${icon} ${enchant}</div>`;
                            }

                            html += `
                                <div class="equip-slot" style="border-color: ${color};" 
                                     onclick="showUpgradeModal('${memberKey}', '${slot}', '${itemName}')">
                                    <div class="slot-label">${slot}</div>
                                    <div class="item-name" style="color: ${color};">${itemName}</div>
                                    <div class="item-level">Level ${item.level || 1}</div>
                                    ${enchantDisplay}
                                </div>
                            `;
                        } else {
                            html += `
                                <div class="equip-slot empty">
                                    <div class="slot-label">${slot}</div>
                                    <div style="color: #666; text-align: center;">Empty</div>
                                </div>
                            `;
                        }
                    } else {
                        html += `
                            <div class="equip-slot empty">
                                <div class="slot-label">${slot}</div>
                                <div style="color: #666; text-align: center;">Empty</div>
                            </div>
                        `;
                    }
                });

                html += `
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function showUpgradeModal(memberKey, slot, itemName) {
            const modal = document.getElementById('upgrade-modal');
            const modalBody = document.getElementById('upgrade-modal-body');
            if (!modal || !modalBody) return;

            const item = INVENTORY.find(i => i.name === itemName);
            if (!item) return;

            const member = PARTY_STATS[memberKey];
            const rarity = item.rarity || 'Common';
            const color = getRarityColor(rarity);
            const enchant = item.enchantment || null;
            const enchantData = enchant ? ENCHANTMENTS[enchant] : null;

            let html = `
                <div class="upgrade-header">
                    <h2 style="color: ${color};">${itemName}</h2>
                    <div style="color: #aaa;">Equipped by ${member.NAME} - ${slot}</div>
                </div>

                <div class="upgrade-image">
                    <img src="${item.image || 'Assests/empty-slot.png'}" 
                         alt="${itemName}"
                         style="border-color: ${color};">
                </div>

                <div class="upgrade-info">
                    <div class="info-row">
                        <span class="info-label">Level:</span>
                        <span class="info-value">${item.level || 1}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Rarity:</span>
                        <span class="info-value" style="color: ${color};">${rarity}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Strength:</span>
                        <span class="info-value">${item.strength || 0}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Magic:</span>
                        <span class="info-value">${item.magic || 0}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Speed:</span>
                        <span class="info-value">${item.speed || 0}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Defense:</span>
                        <span class="info-value">${item.defense || 0}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Health:</span>
                        <span class="info-value">${item.health || 0}</span>
                    </div>
                </div>
            `;
            
            // Calculate and display level up cost
            const itemLevel = item.level || 1;
            const baseGemCost = getRarityGemCost(item.rarity);
            const gemCost = Math.ceil((baseGemCost * (1 + itemLevel * 0.5)) / 4);
            const currentGems = typeof GEMS !== 'undefined' ? GEMS : 0;
            const canAfford = currentGems >= gemCost;
            
            html += `
                <button class="upgrade-button" onclick="levelUpEquippedItem('${itemName}')" style="${!canAfford ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                    ‚¨ÜÔ∏è Level Up Item (${gemCost} üíé)
                </button>
            `;

            if (enchant && enchantData) {
                const isLegendary = enchantData.legendary || false;
                const enchantColor = isLegendary ? '#ff8000' : '#ffcc00';
                const borderColor = isLegendary ? '#ff8000' : '#ffcc00';
                const icon = isLegendary ? 'üåü' : '‚ú®';
                html += `
                    <div class="enchant-section" style="cursor: pointer; border-color: ${borderColor}; background: ${isLegendary ? 'rgba(255, 128, 0, 0.1)' : 'rgba(255, 204, 0, 0.1)'};" onclick="showEnchantOptions('${itemName}')">
                        <div class="enchant-title" style="color: ${enchantColor};">${icon} Enchantment: ${enchant}</div>
                        <div style="color: #fff; margin-top: 10px;">${enchantData.description}</div>
                        <div style="color: #aaa; margin-top: 10px; font-size: 0.9em;">Click to replace enchantment</div>
                    </div>
                `;
            } else {
                html += `
                    <div class="enchant-section" style="cursor: pointer;" onclick="showEnchantOptions('${itemName}')">
                        <div class="enchant-title">‚ú® Enchantment</div>
                        <div class="no-enchant">No enchantment applied</div>
                        <div style="color: #aaa; margin-top: 10px; font-size: 0.9em;">Click to apply enchantment</div>
                    </div>
                `;
            }

            modalBody.innerHTML = html;
            modal.classList.add('active');
        }

        function showEnchantOptions(itemName) {
            const item = INVENTORY.find(i => i.name === itemName);
            if (!item) return;

            // Get available enchantments
            const enchantInventory = typeof ENCHANTMENT_INVENTORY !== 'undefined' ? ENCHANTMENT_INVENTORY : {};
            const availableEnchants = Object.keys(enchantInventory).filter(e => enchantInventory[e] > 0);

            if (availableEnchants.length === 0) {
                alert("You don't have any enchantments! Obtain enchantments from battles and explore the world.");
                return;
            }

            // Build enchantment selection modal
            let html = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="color: #ffcc00;">Select Enchantment</h2>
                    <div style="color: #aaa; margin-top: 10px;">Choose an enchantment to apply to ${itemName}</div>
                </div>
                <div style="max-height: 400px; overflow-y: auto;">
            `;

            availableEnchants.forEach(enchantName => {
                const count = enchantInventory[enchantName];
                const enchantData = ENCHANTMENTS[enchantName];
                const isLegendary = enchantData.legendary || false;
                const borderColor = isLegendary ? '#ff8000' : '#ffcc00';
                const bgColor = isLegendary ? 'rgba(255, 128, 0, 0.1)' : 'rgba(255, 204, 0, 0.1)';
                const hoverBgColor = isLegendary ? 'rgba(255, 128, 0, 0.2)' : 'rgba(255, 204, 0, 0.2)';
                const icon = isLegendary ? 'üåü' : '‚ú®';
                
                html += `
                    <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s;"
                         onmouseover="this.style.background='${hoverBgColor}'; this.style.transform='translateX(5px)';"
                         onmouseout="this.style.background='${bgColor}'; this.style.transform='translateX(0)';"
                         onclick="applyEnchantment('${itemName}', '${enchantName}')">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="color: ${borderColor}; font-weight: bold; font-size: 1.1em;">${icon} ${enchantName}</div>
                                <div style="color: #fff; margin-top: 5px;">${enchantData.description}</div>
                            </div>
                            <div style="background: rgba(233, 69, 96, 0.8); color: #fff; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.2em;">
                                ${count}
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
                </div>
                <button class="upgrade-button" onclick="showUpgradeModal('${item.equipped ? getEquippedMemberKey(itemName) : 'ONE'}', '${item.slot}', '${itemName}')" style="background: linear-gradient(135deg, #666 0%, #444 100%);">
                    ‚Üê Back to Item
                </button>
            `;

            const modalBody = document.getElementById('upgrade-modal-body');
            if (modalBody) {
                modalBody.innerHTML = html;
            }
        }

        function getEquippedMemberKey(itemName) {
            for (const memberKey in PARTY_STATS) {
                const member = PARTY_STATS[memberKey];
                for (const slot of ['HELMET', 'CHEST', 'LEGS', 'BOOTS', 'MAINHAND', 'OFFHAND']) {
                    if (member[slot] === itemName) {
                        return memberKey;
                    }
                }
            }
            return 'ONE';
        }

        function applyEnchantment(itemName, enchantName) {
            const item = INVENTORY.find(i => i.name === itemName);
            if (!item) return;

            // Check if item already has an enchantment
            if (item.enchantment && item.enchantment !== enchantName) {
                if (!confirm(`This item already has ${item.enchantment} enchantment. Replace it with ${enchantName}? (Previous enchantment will be lost)`)) {
                    return;
                }
            }

            // Check if player has this enchantment
            const enchantInventory = typeof ENCHANTMENT_INVENTORY !== 'undefined' ? ENCHANTMENT_INVENTORY : {};
            const count = enchantInventory[enchantName] || 0;
            if (count <= 0) {
                alert("You don't have this enchantment!");
                return;
            }

            // Get enchantment bonuses (use the bonuses from inventory.js if available)
            const ENCHANTMENT_BONUSES = {
                "Sharpness": { strength: 5 },
                "Lifesteal": { health: 10 },
                "Burning": { magic: 5 },
                "Fortification": { defense: 5 },
                "Swiftness": { speed: 3 },
                "Vitality": { health: 15 },
                "Hemorrhage": { strength: 3, speed: 2 },
                "Precision": { speed: 5 },
                "Arcane Power": { magic: 8 },
                "Berserker": { strength: 10, defense: -3 },
                "Resilience": { defense: 8, health: 5 },
                "Haste": { speed: 6 },
                "Frost": { magic: 4, speed: 2 },
                "Vengeance": { strength: 6, health: 8 },
                "Warding": { defense: 10 },
                "Multistrike": { strength: 15, speed: 10 },
                "Soulrend": { magic: 20, health: -10 },
                "Phoenix Rebirth": { health: 25, defense: 5 },
                "Temporal Flux": { speed: 15, magic: 10 },
                "Chaos Storm": { strength: 12, magic: 12, speed: 8 }
            };

            const bonuses = ENCHANTMENT_BONUSES[enchantName] || {};

            // Remove old enchantment bonuses if exists
            if (item.enchantment && item.enchantmentBonuses) {
                for (const stat in item.enchantmentBonuses) {
                    item[stat] = (item[stat] || 0) - item.enchantmentBonuses[stat];
                }
            }

            // Apply new enchantment bonuses
            item.enchantment = enchantName;
            item.enchantmentBonuses = Object.assign({}, bonuses);
            for (const stat in bonuses) {
                item[stat] = (item[stat] || 0) + bonuses[stat];
            }

            // Remove enchantment from inventory (consume it)
            if (typeof window.removeEnchantment === 'function') {
                window.removeEnchantment(enchantName, 1);
            } else if (typeof ENCHANTMENT_INVENTORY !== 'undefined') {
                ENCHANTMENT_INVENTORY[enchantName] = Math.max(0, (ENCHANTMENT_INVENTORY[enchantName] || 0) - 1);
            }

            // Update party stats if item is equipped
            if (typeof updateStats === 'function') {
                updateStats();
            }

            // Save game data
            if (typeof saveGameData === 'function') {
                saveGameData();
            }

            // Update display
            renderPartyEquipment();
            
            // Play enchant sound
            playSoundEffect('enchant');
            
            // Show success message and return to item view
            alert(`Successfully applied ${enchantName} to ${itemName}!`);
            
            // Find which member has this item equipped
            const memberKey = getEquippedMemberKey(itemName);
            const slot = item.slot || 'MAINHAND';
            showUpgradeModal(memberKey, slot, itemName);
        }

        function closeUpgradeModal() {
            const modal = document.getElementById('upgrade-modal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function levelUpEquippedItem(itemName) {
            const item = INVENTORY.find(i => i.name === itemName);
            if (!item) {
                alert("Item not found!");
                return;
            }
            
            const itemLevel = item.level || 1;
            const baseGemCost = getRarityGemCost(item.rarity);
            const gemCost = Math.ceil((baseGemCost * (1 + itemLevel * 0.5)) / 4);
            const currentGems = typeof GEMS !== 'undefined' ? GEMS : 0;
            
            if (currentGems < gemCost) {
                alert(`Not enough gems! You need ${gemCost} gems but only have ${currentGems}.`);
                return;
            }
            
            // Get base item stats from ITEM_TABLE
            const baseItem = ITEM_TABLE[item.name];
            if (!baseItem) {
                alert("Cannot find base item data!");
                return;
            }
            
            // Calculate new level stats
            const newLevel = itemLevel + 1;
            const newScale = Math.pow(newLevel, 0.8);
            
            function scaleStat(baseValue) {
                if (!baseValue || baseValue <= 0) return baseValue || 0;
                return Math.round(baseValue * newScale);
            }
            
            const newStats = {
                strength: scaleStat(baseItem.strength),
                magic: scaleStat(baseItem.magic),
                speed: scaleStat(baseItem.speed),
                defense: scaleStat(baseItem.defense),
                health: scaleStat(baseItem.health)
            };
            
            if (!confirm(`Level up ${item.name} from level ${itemLevel} to ${newLevel}?\nCost: ${gemCost} gems\n\nNew stats:\nSTR: ${item.strength} ‚Üí ${newStats.strength}\nMAG: ${item.magic} ‚Üí ${newStats.magic}\nSPD: ${item.speed} ‚Üí ${newStats.speed}\nDEF: ${item.defense} ‚Üí ${newStats.defense}\nHP: ${item.health} ‚Üí ${newStats.health}`)) {
                return;
            }
            
            // Deduct gems
            GEMS -= gemCost;
            
            // Update item stats to match new level
            item.level = newLevel;
            item.strength = newStats.strength;
            item.magic = newStats.magic;
            item.speed = newStats.speed;
            item.defense = newStats.defense;
            item.health = newStats.health;
            
            // Update stats if equipped
            if (typeof updateStats === 'function') {
                updateStats();
            }
            
            if (typeof saveGameData === 'function') {
                saveGameData();
            }
            
            alert(`${item.name} leveled up to ${item.level}!`);
            
            // Refresh the modal to show new stats
            const memberKey = getEquippedMemberKey(itemName);
            const slot = item.slot || 'MAINHAND';
            showUpgradeModal(memberKey, slot, itemName);
        }
        
        // ==================== CRAFT SCREEN ====================
        const MYTHICAL_RECIPES = {
            "Running Spikes": {
                requiredItem: "Gem Boots",
                gems: 500,
                enchantment: "Haste",
                description: "Sprint through battles with legendary speed"
            },
            "Rulers Hand": {
                requiredItem: "Energy Saber",
                gems: 600,
                enchantment: "Phoenix Rebirth",
                description: "Command the battlefield with royal authority"
            },
            "Muramasa": {
                requiredItem: "Demon Sythe",
                gems: 750,
                enchantment: "Soulrend",
                description: "The cursed blade of perfect precision"
            },
            "Spell Blade": {
                requiredItem: "Pixel Sword",
                gems: 700,
                enchantment: "Chaos Storm",
                description: "Merge steel and magic into one"
            },
            "Enhanced Stick": {
                requiredItem: "Stick",
                requiredLevel: 100,
                gems: 650,
                enchantment: "Temporal Flux",
                description: "A simple weapon with infinite potential"
            }
        };
        
        function showCraftScreen() {
            hideAllScreens();
            document.getElementById('craft-screen').classList.add('active');
            renderCraftGrid();
        }
        
        function hideCraftScreen() {
            document.getElementById('craft-screen').classList.remove('active');
            document.getElementById('selection-screen').style.display = 'block';
        }
        
        function renderCraftGrid() {
            const grid = document.getElementById('craft-grid');
            const gemDisplay = document.getElementById('craft-gem-count');
            if (!grid) return;
            
            const currentGems = typeof GEMS !== 'undefined' ? GEMS : 0;
            gemDisplay.textContent = currentGems;
            
            grid.innerHTML = '';
            
            for (const mythicalName in MYTHICAL_RECIPES) {
                const recipe = MYTHICAL_RECIPES[mythicalName];
                const mythicalData = ITEM_TABLE[mythicalName];
                if (!mythicalData) continue;
                
                // Check if player has the required legendary item
                let hasRequiredItem = false;
                const requiredItemInstance = INVENTORY.find(item => {
                    const nameMatch = item.name === recipe.requiredItem;
                    const levelMatch = !recipe.requiredLevel || (item.level >= recipe.requiredLevel);
                    return nameMatch && levelMatch;
                });
                hasRequiredItem = !!requiredItemInstance;
                
                // Check if player has the required enchantment
                const hasEnchantment = (typeof ENCHANTMENT_INVENTORY !== 'undefined' && 
                                       ENCHANTMENT_INVENTORY[recipe.enchantment] > 0) ||
                                       (typeof getEnchantmentCount === 'function' && 
                                       getEnchantmentCount(recipe.enchantment) > 0);
                
                const hasGems = currentGems >= recipe.gems;
                const canCraft = hasRequiredItem && hasEnchantment && hasGems;
                
                const card = document.createElement('div');
                card.style.cssText = `
                    background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(75, 0, 130, 0.2));
                    border: 3px solid ${canCraft ? '#9d4edd' : '#555'};
                    border-radius: 15px;
                    padding: 25px;
                    position: relative;
                    ${canCraft ? 'cursor: pointer;' : 'opacity: 0.6;'}
                    transition: all 0.3s;
                `;
                
                if (canCraft) {
                    card.onmouseenter = () => card.style.transform = 'translateY(-5px)';
                    card.onmouseleave = () => card.style.transform = 'translateY(0)';
                    card.onclick = () => craftMythicalItem(mythicalName);
                }
                
                card.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="color: #9d4edd; margin: 0 0 10px 0;">${mythicalName}</h2>
                        <p style="color: #aaa; font-style: italic; margin: 5px 0;">${recipe.description}</p>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <h3 style="color: #fff; margin: 0 0 10px 0;">Required Materials:</h3>
                        <div style="color: ${hasRequiredItem ? '#51cf66' : '#ff6b6b'};">
                            ${hasRequiredItem ? '‚úì' : '‚úó'} ${recipe.requiredItem}${recipe.requiredLevel ? ` (Level ${recipe.requiredLevel})` : ''}
                        </div>
                        <div style="color: ${hasEnchantment ? '#51cf66' : '#ff6b6b'};">
                            ${hasEnchantment ? '‚úì' : '‚úó'} ${recipe.enchantment} Enchantment
                        </div>
                        <div style="color: ${hasGems ? '#51cf66' : '#ff6b6b'};">
                            ${hasGems ? '‚úì' : '‚úó'} ${recipe.gems} Gems
                        </div>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                        <h3 style="color: #fff; margin: 0 0 10px 0;">Stats:</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; color: #fff;">
                            <div>‚öîÔ∏è STR: ${mythicalData.strength || 0}</div>
                            <div>‚ú® MAG: ${mythicalData.magic || 0}</div>
                            <div>‚ö° SPD: ${mythicalData.speed || 0}</div>
                            <div>üõ°Ô∏è DEF: ${mythicalData.defense || 0}</div>
                            <div>‚ù§Ô∏è HP: ${mythicalData.health || 0}</div>
                            ${mythicalData.ability ? `<div>üéØ Ability: #${mythicalData.ability}</div>` : ''}
                        </div>
                    </div>
                `;
                
                grid.appendChild(card);
            }
        }
        
        function craftMythicalItem(mythicalName) {
            const recipe = MYTHICAL_RECIPES[mythicalName];
            if (!recipe) return;
            
            const levelReq = recipe.requiredLevel ? ` (Level ${recipe.requiredLevel})` : '';
            if (!confirm(`Craft ${mythicalName}? This will consume:\n- ${recipe.requiredItem}${levelReq}\n- ${recipe.enchantment} Enchantment\n- ${recipe.gems} Gems`)) {
                return;
            }
            
            // Verify materials again
            const currentGems = typeof GEMS !== 'undefined' ? GEMS : 0;
            if (currentGems < recipe.gems) {
                alert("Not enough gems!");
                return;
            }
            
            const requiredItemIndex = INVENTORY.findIndex(item => {
                const nameMatch = item.name === recipe.requiredItem;
                const levelMatch = !recipe.requiredLevel || (item.level >= recipe.requiredLevel);
                return nameMatch && levelMatch;
            });
            
            if (requiredItemIndex === -1) {
                alert(`You don't have ${recipe.requiredItem}${levelReq}!`);
                return;
            }
            
            // Check enchantment
            let hasEnchantment = false;
            if (typeof ENCHANTMENT_INVENTORY !== 'undefined' && ENCHANTMENT_INVENTORY[recipe.enchantment] > 0) {
                hasEnchantment = true;
            } else if (typeof getEnchantmentCount === 'function' && getEnchantmentCount(recipe.enchantment) > 0) {
                hasEnchantment = true;
            }
            
            if (!hasEnchantment) {
                alert(`You don't have ${recipe.enchantment} enchantment!`);
                return;
            }
            
            // Consume materials
            INVENTORY.splice(requiredItemIndex, 1);
            GEMS -= recipe.gems;
            
            if (typeof window.removeEnchantment === 'function') {
                window.removeEnchantment(recipe.enchantment, 1);
            } else if (typeof ENCHANTMENT_INVENTORY !== 'undefined') {
                ENCHANTMENT_INVENTORY[recipe.enchantment]--;
            }
            
            // Create mythical item
            const mythicalData = ITEM_TABLE[mythicalName];
            const newItem = {
                name: mythicalName,
                level: 1,
                slot: mythicalData.slot,
                rarity: mythicalData.rarity,
                strength: mythicalData.strength || 0,
                speed: mythicalData.speed || 0,
                magic: mythicalData.magic || 0,
                defense: mythicalData.defense || 0,
                health: mythicalData.health || 0,
                attack: mythicalData.attack,
                ability: mythicalData.ability,
                image: mythicalData.image
            };
            
            INVENTORY.push(newItem);
            
            if (typeof saveGameData === 'function') {
                saveGameData();
            }
            
            alert(`Successfully crafted ${mythicalName}!`);
            renderCraftGrid();
        }
        
        function getRarityGemCost(rarity) {
            const costs = {
                'Common': 10,
                'Uncommon': 25,
                'Rare': 50,
                'Epic': 100,
                'Legendary': 200,
                'Mythical': 500,
                'Artifact': 1000
            };
            return costs[rarity] || 50;
        }
        
        // Helper function to hide all screens
        function hideAllScreens() {
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('craft-screen').classList.remove('active');
            document.getElementById('upgrade-screen').classList.remove('active');
            document.getElementById('attacks-screen').classList.remove('active');
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('upgrade-modal');
            if (e.target === modal) {
                closeUpgradeModal();
            }
        });
        
        // Load game data on page load
        if (typeof loadGameData === 'function') {
            loadGameData();
        }
    </script>
</body>
</html>