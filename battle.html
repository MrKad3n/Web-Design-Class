<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Kaden's Dungeon Game</title>
        <link rel="stylesheet" type="text/css" href="style.css">
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/5/w3.css">
        <link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-blue.css">
        <style>
            /* Arena-focused responsive battle layout */
            body#battle {
                margin: 0;
                padding: 0;
                height: 100vh;
                display: flex;
                flex-direction: column;
                background-image: url('Backgrounds/unknown-battle.png');
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                background-attachment: fixed;
            }
            
            /* Main arena container */
            #battle-container {
                display: grid;
                grid-template-columns: 15% 1fr 15%;
                grid-template-rows: auto auto 1fr auto;
                gap: 0.5rem;
                flex: 1;
                padding: 0.5rem;
                box-sizing: border-box;
                max-height: 100vh;
                overflow: hidden;
            }
            
            /* Central arena area with dark semi-transparent overlay to highlight battle space */
            .arena {
                grid-column: 1 / -1;
                grid-row: 3;
                background: rgba(0, 0, 0, 0.3);
                border: 3px solid rgba(255, 215, 0, 0.5);
                border-radius: 10px;
                padding: 1rem;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 1rem;
                align-items: stretch;
                box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.3);
                min-height: 0;
                overflow: hidden;
            }
            
            /* Party sidebar - positioned above arena */
            #party {
                grid-column: 1;
                grid-row: 1;
                display: flex;
                flex-direction: column;
                gap: 0.3rem;
                max-height: 120px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.5);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 5px;
                padding: 0.4rem;
            }
            
            /* Player stats display */
            #player-stats-display {
                grid-column: 1 / -1;
                grid-row: 2;
                background: rgba(0, 0, 0, 0.7);
                border: 2px solid rgba(255, 215, 0, 0.6);
                border-radius: 5px;
                padding: 0.5rem 1rem;
                display: flex;
                justify-content: space-around;
                align-items: center;
                color: white;
                font-size: 0.9rem;
            }
            
            #player-stats-display .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.2rem;
            }
            
            #player-stats-display .stat-label {
                color: rgba(255, 215, 0, 0.8);
                font-size: 0.75rem;
                font-weight: bold;
            }
            
            #player-stats-display .stat-value {
                font-size: 1rem;
                font-weight: bold;
            }
            
            /* Leave Battle Button */
            #leave-battle-btn {
                grid-column: 3;
                grid-row: 1;
                align-self: start;
                padding: 0.5rem 1rem;
                background: rgba(220, 53, 69, 0.8);
                color: white;
                border: 2px solid rgba(220, 53, 69, 1);
                border-radius: 5px;
                font-size: 1rem;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                text-transform: uppercase;
                box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            }
            
            #leave-battle-btn:hover {
                background: rgba(220, 53, 69, 1);
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
            }
            
            #leave-battle-btn:active {
                transform: scale(0.98);
            }

            
            .party-slot {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 0.5rem;
                cursor: pointer;
                transition: all 0.2s;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 3px;
                border: 1px solid transparent;
            }
            
            .party-slot:hover {
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.5);
            }
            
            .party-slot img {
                width: 35px;
                height: 35px;
                flex-shrink: 0;
            }
            
            .party-slot span {
                font-size: 0.9rem;
                color: white;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            /* Enemy area - right side of arena */
            #enemy-area {
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                position: relative;
                width: 100%;
                height: 100%;
                overflow-y: auto;
                padding: 0.5rem;
                box-sizing: border-box;
            }
            
            #enemy-area h2 {
                margin: 0 0 0.5rem 0;
                text-align: center;
            }
            
            .enemy-health-bar {
                width: 100%;
                height: 1.5rem;
                margin-bottom: 1rem;
            }
            
            #enemies {
                position: relative;
                width: 100%;
                min-height: 150px;
                max-height: 200px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                flex-shrink: 0;
                overflow-y: auto;
                gap: 8px;
                padding: 8px 0;
            }
            
            #enemies img {
                position: absolute;
                max-width: 28%;
                max-height: 100%;
                object-fit: contain;
                transition: transform 0.3s ease, filter 0.3s ease;
                filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5));
            }
            
            #enemies img:nth-child(1) {
                left: 5%;
            }
            
            #enemies img:nth-child(2) {
                left: 36%;
                z-index: 10;
            }
            
            #enemies img:nth-child(3) {
                right: 5%;
            }
            
            #enemies img.hoverable:hover {
                transform: scale(1.15);
                filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
            }
            
            /* Status effect display */
            .status-effects-display {
                position: absolute;
                bottom: -25px;
                left: 50%;
                transform: translateX(-50%);
                display: none;
                font-size: 18px;
                background: rgba(0, 0, 0, 0.8);
                padding: 2px 8px;
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.5);
                white-space: nowrap;
                z-index: 100;
            }
            
            .status-effects-display span {
                margin: 0 2px;
            }
            
            #player-status-effects {
                text-align: center;
                color: #ffaa00;
                font-weight: bold;
            }
            
            /* Turn order display */
            .turn-box {
                width: 50px;
                height: 50px;
                border-radius: 8px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                position: relative;
                transition: all 0.3s ease;
                border: 2px solid transparent;
            }
            
            .turn-box img {
                width: 35px;
                height: 35px;
                object-fit: contain;
            }
            
            .turn-box.player-turn {
                background: rgba(40, 167, 69, 0.3);
                border-color: rgba(40, 167, 69, 1);
                box-shadow: 0 0 15px rgba(40, 167, 69, 0.6);
            }
            
            .turn-box.enemy-turn {
                background: rgba(220, 53, 69, 0.3);
                border-color: rgba(220, 53, 69, 1);
                box-shadow: 0 0 15px rgba(220, 53, 69, 0.6);
            }
            
            .turn-box.active {
                transform: scale(1.15);
                border-width: 3px;
            }
            
            .turn-box.player-turn.active {
                box-shadow: 0 0 25px rgba(40, 167, 69, 1);
            }
            
            .turn-box.enemy-turn.active {
                box-shadow: 0 0 25px rgba(220, 53, 69, 1);
            }
            
            .turn-box .enemy-number {
                position: absolute;
                bottom: -2px;
                right: -2px;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                font-size: 10px;
                font-weight: bold;
                padding: 2px 4px;
                border-radius: 3px;
                min-width: 14px;
                text-align: center;
            }
            
            /* Enemy tooltip */
            .enemy-tooltip {
                position: fixed;
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid rgba(255, 215, 0, 0.8);
                border-radius: 8px;
                padding: 12px 16px;
                color: white;
                font-size: 14px;
                z-index: 10000;
                pointer-events: none;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
                max-width: 300px;
                display: none;
            }
            
            .enemy-tooltip.active {
                display: block;
            }
            
            .enemy-tooltip h4 {
                margin: 0 0 8px 0;
                color: #ffd700;
                font-size: 16px;
                border-bottom: 1px solid rgba(255, 215, 0, 0.5);
                padding-bottom: 4px;
            }
            
            .enemy-tooltip .stat-row {
                margin: 4px 0;
                display: flex;
                justify-content: space-between;
            }
            
            .enemy-tooltip .special-effect {
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid rgba(255, 215, 0, 0.3);
                color: #ffaa00;
                font-style: italic;
            }
            
            @media (max-width: 768px) {
                .enemy-tooltip {
                    max-width: 250px;
                    font-size: 12px;
                }
            }
            
            /* Player area - left side of arena */
            #player-area {
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
                padding: 0.5rem;
                box-sizing: border-box;
            }
            
            .player-bars {
                width: 100%;
                margin-bottom: 0.5rem;
                flex-shrink: 0;
            }
            
            .health-bar, .mana-bar {
                width: 100%;
                height: 1.5rem;
                margin-bottom: 0.5rem;
                border-radius: 3px;
                overflow: hidden;
            }
            
            .health-bar div, .mana-bar div {
                height: 100%;
                transition: width 0.3s ease;
            }
            
            #player {
                max-width: 100%;
                max-height: 150px;
                width: auto;
                height: auto;
                object-fit: contain;
                filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5));
                transition: transform 0.3s ease;
                flex-shrink: 1;
            }
            
            #player:hover {
                transform: scale(1.05);
            }
            
            /* Attacks area - bottom center */
            #Attacks {
                grid-column: 1 / -1;
                grid-row: 4;
                display: flex;
                flex-direction: row;
                gap: 0.4rem;
                min-height: 80px;
                max-height: 100px;
                overflow-x: auto;
                overflow-y: hidden;
                background: rgba(0, 0, 0, 0.5);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 5px;
                padding: 0.4rem;
                justify-content: flex-end;
            }
            
            .attack-slot {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.2rem;
                padding: 0.3rem;
                cursor: pointer;
                transition: all 0.2s;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 3px;
                border: 1px solid transparent;
                flex-shrink: 0;
                min-width: 70px;
            }
            
            .attack-slot:hover {
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.5);
                transform: scale(1.05);
            }
            
            .attack-slot img {
                width: 35px;
                height: 35px;
            }
            
            .attack-slot span {
                font-size: 0.8rem;
                color: white;
                text-align: center;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 70px;
            }
            
            /* Responsive adjustments */
            @media (max-width: 1200px) {
                #battle-container {
                    grid-template-columns: 1fr;
                    grid-template-rows: auto auto auto 1fr auto;
                    gap: 0.5rem;
                    padding: 0.5rem;
                }
                
                .arena {
                    grid-template-columns: 1fr;
                    grid-row: 3;
                    padding: 1rem;
                    gap: 1rem;
                }
                
                #party {
                    grid-column: 1;
                    grid-row: 1;
                    flex-direction: row;
                    max-height: auto;
                    max-width: 100%;
                }
                
                #player-stats-display {
                    grid-row: 2;
                }
                
                #Attacks {
                    grid-column: 1;
                    grid-row: 4;
                }
                
                #enemies {
                    min-height: 200px;
                    max-height: 250px;
                }
                
                #player {
                    max-height: 200px;
                }
            }
            
            @media (max-width: 768px) {
                body#battle {
                    padding: 0;
                    height: auto;
                    min-height: 100vh;
                }
                
                #battle-container {
                    gap: 0.3rem;
                    padding: 0.3rem;
                    grid-template-rows: auto auto auto 1fr auto;
                    max-height: none;
                    height: auto;
                    min-height: 100vh;
                }
                
                .arena {
                    grid-template-columns: 1fr;
                    grid-row: 3;
                    padding: 0.5rem;
                    gap: 0.5rem;
                }
                
                #party {
                    flex-direction: row;
                    gap: 0.3rem;
                    max-width: 100%;
                    grid-row: 1;
                }
                
                .party-slot span {
                    display: none;
                }
                
                #player-stats-display {
                    grid-row: 2;
                    flex-wrap: wrap;
                    padding: 0.3rem 0.5rem;
                    font-size: 0.8rem;
                }
                
                #player-stats-display .stat-item {
                    min-width: 60px;
                }
                
                #Attacks {
                    gap: 0.4rem;
                    padding: 0.5rem;
                    grid-row: 4;
                    position: relative;
                    z-index: 1;
                    min-height: 90px;
                    max-height: 120px;
                }
                
                .attack-slot {
                    min-width: 65px;
                    padding: 0.4rem;
                }
                
                .attack-slot img {
                    width: 40px;
                    height: 40px;
                }
                
                .attack-slot span {
                    display: none;
                }
                
                #enemies {
                    min-height: 150px;
                    max-height: 200px;
                }
                
                #player {
                    max-height: 120px;
                }
                
                #player-area {
                    padding: 0.3rem;
                }
            }
        </style>
    </head>
<body id="battle">
    <!--Battle arena with party sidebar, player, and enemies in a contained arena space-->
    <div id="battle-container">
        
        <!--Party sidebar - top left-->
        <div id="party" class="w3-blue-grey">
            <!--Party member 1-->
            <div id="slot-one" class="party-slot">
                <img src="Assests/player.png" alt="Player 1">
                <span>P1 lvl#</span>
            </div>
            <!--Party member 2, etc-->
            <div id="slot-two" class="party-slot">
                <img src="Assests/player.png" alt="Player 2">
                <span>P2 lvl#</span>
            </div>
            <div id="slot-three" class="party-slot">
                <img src="Assests/player.png" alt="Player 3">
                <span>P3 lvl#</span>
            </div>
            <div id="slot-four" class="party-slot">
                <img src="Assests/player.png" alt="Player 4">
                <span>P4 lvl#</span>
            </div>
            <div id="slot-five" class="party-slot">
                <img src="Assests/player.png" alt="Player 5">
                <span>P5 lvl#</span>
            </div>
        </div>
        
        <!--Leave Battle Button - top right-->
        <div style="display:flex;gap:8px;justify-content:flex-end;align-items:center;">
            <button id="leave-battle-btn" onclick="leaveBattle()">Leave Battle</button>
            <button id="start-combat-btn" onclick="startCombat()" style="background:rgba(40,167,69,0.85);color:white;border:2px solid rgba(40,167,69,1);padding:0.5rem 1rem;border-radius:5px;cursor:pointer;">Start Combat</button>
        </div>
        
        <!--Turn Order Queue Display-->
        <div id="turn-order-display" style="margin-top:1rem;padding:0.5rem;background:rgba(0,0,0,0.3);border-radius:8px;border:1px solid rgba(255,255,255,0.1);max-width:600px;">
            <h3 style="margin:0 0 0.5rem 0;font-size:14px;text-align:center;color:#ffaa00;">Turn Order</h3>
            <div id="turn-order-queue" style="display:flex;gap:8px;justify-content:flex-start;align-items:center;overflow-x:auto;padding:4px;">
                <!-- Turn order boxes will be inserted here -->
            </div>
        </div>
        
        <!--Player Stats Display-->
        <div id="player-stats-display">
            <div class="stat-item">
                <span class="stat-label">HP</span>
                <span class="stat-value" id="stat-hp">100/100</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Strength</span>
                <span class="stat-value" id="stat-strength">10</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Magic</span>
                <span class="stat-value" id="stat-magic">10</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Speed</span>
                <span class="stat-value" id="stat-speed">10</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Defense</span>
                <span class="stat-value" id="stat-defense">5</span>
            </div>
        </div>
        
        <!--Central Arena-->
        <div class="arena">
            <!--Player area - left side of arena-->
            <div id="player-area">
                <div class="player-bars">
                    <div class="health-bar w3-light-grey">
                        <div class="w3-green" style="width:50%; height:100%">HP #</div>
                    </div>
                    <div class="mana-bar w3-light-grey">
                        <div class="w3-blue" style="width:50%; height:100%">mana #</div>
                    </div>
                </div>
                <img id="player" src="Assests/player.png" alt="Player">
            </div>
            
            <!--Enemy area - right side of arena-->
            <div id="enemy-area">
                
                <div id="enemies">
                    <img class="hoverable" src="Enemies/cursedKnight.png" alt="Enemy 1">
                    <img class="hoverable" src="Enemies/cursedKnight.png" alt="Enemy 2">
                    <img class="hoverable" src="Enemies/cursedKnight.png" alt="Enemy 3">
                </div>
            </div>
        </div>
        
        <!--Attacks area - bottom-->
        <div id="Attacks" class="w3-blue-grey">
            <!--Attack 1-->
            <div id="atk-one" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 1">
                <span>Attack 1</span>
            </div>
            <!--Attack 2, etc-->
            <div id="atk-two" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 2">
                <span>Attack 2</span>
            </div>
            <div id="atk-three" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 3">
                <span>Attack 3</span>
            </div>
            <div id="atk-four" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 4">
                <span>Attack 4</span>
            </div>
            <div id="atk-five" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 5">
                <span>Attack 5</span>
            </div>
        </div>
    </div>
    
    <footer>
        Kaden Cruts - 2025
    </footer>

        <!-- Combat debug panel (visible during testing) -->
        <div id="combat-debug" style="position:fixed;left:8px;bottom:8px;max-width:320px;max-height:220px;overflow:auto;background:rgba(0,0,0,0.6);color:#fff;padding:8px;border-radius:6px;font-size:12px;z-index:9999;border:1px solid rgba(255,255,255,0.08);">
            <strong style="display:block;margin-bottom:6px">Combat Debug</strong>
        </div>
    
    <script>
        function leaveBattle() {
            // Navigate back to home page
            window.location.href = 'home.html';
        }
    </script>
        <!-- Core game script to access PARTY_STATS, INVENTORY, ENEMY_BASE_STATS, etc. -->
        <script src="script.js"></script>
        <!-- Item index tracking -->
        <script src="index.js"></script>
        <!-- Enemy index tracking -->
        <script src="enemy-index.js"></script>
        <script>
        // Debug: Check what's available from script.js
        console.log('window.clearLevelAndUnlock:', typeof window.clearLevelAndUnlock);
        console.log('window object keys sample:', Object.keys(window).filter(k => k.includes('clear') || k.includes('Level')));
        
        // Battle page initialization: read session battleData, update UI
        (function(){
            // Check for challenge mode from URL
            const urlParams = new URLSearchParams(window.location.search);
            const mode = urlParams.get('mode');
            const challengeId = urlParams.get('id');
            
            // Read battleData from sessionStorage
            let battleData = {};
            
            // If challenge mode, load challenge data and set up battle
            if (mode === 'challenge' && challengeId) {
                try {
                    const challengeDataStr = localStorage.getItem('activeChallengeData');
                    if (challengeDataStr) {
                        const challengeData = JSON.parse(challengeDataStr);
                        
                        // Calculate level based on highest party member
                        let maxPartyLevel = 1;
                        if (typeof PARTY_STATS !== 'undefined') {
                            Object.values(PARTY_STATS).forEach(member => {
                                if (member && member.LEVEL) {
                                    maxPartyLevel = Math.max(maxPartyLevel, member.LEVEL);
                                }
                            });
                        }
                        
                        // Convert enemy names to image paths
                        const enemyPaths = (challengeData.enemies || ['skull']).map(enemyName => {
                            // If already a path, use it; otherwise convert name to path
                            if (enemyName.includes('/') || enemyName.includes('.png')) {
                                return enemyName;
                            }
                            return `Enemies/${enemyName}.png`;
                        });
                        
                        // Parse modifiers from description (simplified for now - could be enhanced)
                        const modifiers = {};
                        const modText = (challengeData.modifier || '').toLowerCase();
                        if (modText.includes('2x defense')) modifiers.defenseBoost = 2;
                        if (modText.includes('1.5x speed')) modifiers.speedBoost = 1.5;
                        if (modText.includes('+50% speed')) modifiers.speedBoost = 1.5;
                        if (modText.includes('3x health')) modifiers.healthBoost = 3;
                        if (modText.includes('2x health')) modifiers.healthBoost = 2;
                        
                        // Set up battle data from challenge
                        battleData = {
                            level: maxPartyLevel,
                            enemies: enemyPaths,
                            isBossTile: false,
                            isChallenge: true,
                            challengeId: parseInt(challengeId),
                            challengeReward: challengeData.reward,
                            challengeModifiers: modifiers
                        };
                        
                        // Store in sessionStorage for consistency
                        sessionStorage.setItem('battleData', JSON.stringify(battleData));
                    }
                } catch(e) {
                    console.error('Failed to load challenge data:', e);
                }
            } else {
                // Normal/hard mode - read from sessionStorage
                try { battleData = JSON.parse(sessionStorage.getItem('battleData')||'{}'); } catch(e) { battleData = {}; }
            }
            
            const level = battleData.level || 1;
            const enemyImages = battleData.enemies && battleData.enemies.length ? battleData.enemies : ['Enemies/skull.png'];
            const isChallenge = battleData.isChallenge || false;
            const challengeModifiers = battleData.challengeModifiers || {};

            // Track active battle member and battle state
            let activeBattleMember = 'ONE';
            let battleEnemyStates = {}; // Store enemy HP across member switches
            const battleParticipants = new Set(); // Track members who participated this battle
            
            // Status effect tracking: each enemy/player has arrays of effects
            // Effect format: { type: 'burn'|'leech'|'bleed'|'grim', turnsLeft: N, stacks: N, sourceData: {} }
            let enemyStatusEffects = {}; // key = enemy index, value = array of effects
            let playerStatusEffects = {}; // key = member key, value = array of effects

            // Helper: get the current active member key
            function getActiveBattleMember() {
                return activeBattleMember;
            }

            // Helper: switch to a different party member during battle
            function switchBattleMember(memberKey, isEmergencySwitch = false) {
                if (!PARTY_STATS || !PARTY_STATS[memberKey]) return false;
                const member = PARTY_STATS[memberKey];
                
                // Only allow switching during player's turn to prevent bugs (unless it's an emergency switch due to KO)
                if (!isEmergencySwitch && (!playerCanAct || !playerWaiting)) {
                    logCombat("You can only switch party members during your turn!");
                    return false;
                }
                
                // Skip if member is dead
                if (Number(member.HEALTH) <= 0) {
                    logCombat(`${member.NAME} is still KO'd and cannot be switched to.`);
                    return false;
                }

                activeBattleMember = memberKey;
                // DO NOT mark as participant just for switching - only when dealing/taking damage
                logCombat(`Switched to ${member.NAME}!`);
                updatePlayerArea();
                renderAttacksForPlayer();
                enableAttackSelection();
                // Recalculate attack ratio based on new member's speed
                recalculateActionQueue();
                // Highlight the selected party slot
                updatePartySlotHighlight();
                return true;
            }

            // Helper: highlight the active party member slot
            function updatePartySlotHighlight() {
                const slotIds = ['one', 'two', 'three', 'four', 'five'];
                slotIds.forEach((id, idx) => {
                    const slot = document.getElementById(`slot-${id}`);
                    if (slot) {
                        const key = ['ONE','TWO','THREE','FOUR','FIVE'][idx];
                        if (key === activeBattleMember) {
                            slot.style.background = 'rgba(255, 215, 0, 0.3)';
                            slot.style.border = '2px solid rgba(255, 215, 0, 1)';
                        } else {
                            slot.style.background = 'rgba(255, 255, 255, 0.05)';
                            slot.style.border = '1px solid transparent';
                        }
                    }
                });
            }

            // Ensure game data loaded and stats are up-to-date
            if (typeof loadGameData === 'function') loadGameData();
            if (typeof updateStats === 'function') updateStats();
            // Initialize all party members for battle: ensure stats and full HP
            for (const key of ['ONE','TWO','THREE','FOUR','FIVE']) {
                const member = PARTY_STATS[key];
                if (!member) continue;
                // Ensure MAX_HEALTH is reasonable (avoid tiny base HP like 3 causing instant death)
                if (typeof member.MAX_HEALTH === 'undefined' || Number(member.MAX_HEALTH) < 20) {
                    member.MAX_HEALTH = Math.max(20, Number(member.MAX_HEALTH) || 20);
                }
                // Set full health for all party members at battle start
                member.HEALTH = Number(member.MAX_HEALTH);
            }

            // Update party sidebar and player stats
            function updatePartyDisplay(){
                for (let i=1;i<=5;i++){
                    const key = ['ONE','TWO','THREE','FOUR','FIVE'][i-1];
                    const slot = document.getElementById(`slot-${['one','two','three','four','five'][i-1]}`);
                    if (!slot) continue;
                    const member = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[key]) ? PARTY_STATS[key] : null;
                    const span = slot.querySelector('span');
                    if (member){
                        span.textContent = `${member.NAME} lv${member.LEVEL||1}`;
                    } else {
                        span.textContent = `P${i} lv#`;
                    }
                }
                updatePlayerStatsDisplay();
            }
            
            // Update player stats display at top
            function updatePlayerStatsDisplay(){
                const member = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[getActiveBattleMember()]) ? PARTY_STATS[getActiveBattleMember()] : null;
                if (!member) return;
                
                // Update stat values
                const hpEl = document.getElementById('stat-hp');
                const strEl = document.getElementById('stat-strength');
                const magEl = document.getElementById('stat-magic');
                const spdEl = document.getElementById('stat-speed');
                const defEl = document.getElementById('stat-defense');
                
                if (hpEl) {
                    const cur = Number(member.HEALTH || 0);
                    const max = Number(member.MAX_HEALTH || 1);
                    hpEl.textContent = `${cur}/${max}`;
                }
                if (strEl) strEl.textContent = Number(member.STRENGTH || 0);
                if (magEl) magEl.textContent = Number(member.MAGIC || 0);
                if (spdEl) spdEl.textContent = Number(member.SPEED || 0);
                if (defEl) defEl.textContent = Number(member.DEFENSE || 0);
            }

            // Main player area uses active battle member
            function updatePlayerArea(){
                const member = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[getActiveBattleMember()]) ? PARTY_STATS[getActiveBattleMember()] : null;
                if (!member) return;
                // Ensure mana fields
                if (typeof member.MAX_MANA === 'undefined') member.MAX_MANA = 100;
                if (typeof member.MANA === 'undefined') member.MANA = 75;

                // Don't call updateStats() during battle - it recalculates from equipment and overwrites enhanced stats
                // Ensure numeric health values exist, but don't modify them
                if (typeof member.MAX_HEALTH === 'undefined') member.MAX_HEALTH = 10;
                if (typeof member.HEALTH === 'undefined') member.HEALTH = Number(member.MAX_HEALTH);

                        const healthBar = document.querySelector('.health-bar div');
                        const manaBar = document.querySelector('.mana-bar div');
                        if (healthBar) {
                            // Ensure numeric values
                            const cur = Number(member.HEALTH || 0);
                            const max = Number(member.MAX_HEALTH || 1);
                            // If max is zero or invalid, treat as 1 to avoid division by zero
                            const safeMax = max > 0 ? max : 1;
                            // Compute percentage as ratio of current to max
                            let pct = Math.round((cur / safeMax) * 100);
                            if (pct > 100) pct = 100;
                            if (pct < 0) pct = 0;
                            healthBar.style.width = pct + '%';
                            // Show fractional HP (current/max) so small max values make sense
                            healthBar.textContent = `HP ${cur}/${safeMax}`;
                        }
                        if (manaBar) {
                            const curM = Number(member.MANA || 0);
                            const maxM = Number(member.MAX_MANA || 100);
                            const safeMaxM = maxM > 0 ? maxM : 100;
                            let mpct = Math.round((curM / safeMaxM) * 100);
                            if (mpct > 100) mpct = 100;
                            if (mpct < 0) mpct = 0;
                            manaBar.style.width = mpct + '%';
                            manaBar.textContent = `MP ${curM}/${safeMaxM}`;
                        }
                        
                        // Update stats display at top
                        updatePlayerStatsDisplay();
                        
                        // Update status effect display
                        updateStatusEffectDisplay();
            }

            // Helper to map image filename to enemy key
            function enemyKeyFromImage(path){
                if (!path) return null;
                const name = path.split('/').pop().split('.')[0];
                // Try to find matching key in ENEMY_BASE_STATS
                for (const k in ENEMY_BASE_STATS) if (k.toLowerCase() === name.toLowerCase()) return k;
                return name;
            }

            // Function to spawn a new enemy during battle
            function spawnEnemy(enemyKey, enemyLevel) {
                const enemiesDiv = document.getElementById('enemies');
                if (!enemiesDiv) return;
                
                const base = ENEMY_BASE_STATS[enemyKey] || { health:20, strength:3, magic:0, speed:2, defense:0, hBars:1 };
                const scaled = Object.assign({}, base);
                
                // Scale stats for the given level
                const scaleMultiplier = Math.pow(enemyLevel, 0.9);
                scaled.health = Math.max(1, Math.round(base.health * scaleMultiplier));
                scaled.strength = Math.round(base.strength * scaleMultiplier);
                scaled.magic = Math.round(base.magic * scaleMultiplier);
                scaled.speed = Math.round(base.speed * scaleMultiplier);
                scaled.defense = Math.round((base.defense || 0) * scaleMultiplier);
                
                // Create enemy wrapper
                const wrap = document.createElement('div');
                wrap.className = 'enemy-single';
                wrap.style.width = '100%';
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.alignItems = 'center';
                wrap.style.marginBottom = '8px';
                
                const nameH = document.createElement('h3');
                nameH.className = 'w3-text-white';
                nameH.textContent = (enemyKey || 'Enemy') + ` (Lv ${enemyLevel})`;
                
                const barWrap = document.createElement('div');
                barWrap.className = 'enemy-health-bar w3-light-grey';
                barWrap.style.width = '80%';
                barWrap.style.height = '12px';
                barWrap.style.marginBottom = '6px';
                const inner = document.createElement('div');
                inner.className = 'w3-green';
                inner.style.width = '100%';
                inner.style.height = '100%';
                inner.textContent = `HP ${scaled.health}`;
                barWrap.appendChild(inner);
                
                const img = document.createElement('img');
                img.src = base.image || `Enemies/${enemyKey}.png`;
                img.alt = enemyKey;
                img.style.maxWidth = '28%';
                img.style.objectFit = 'contain';
                img.className = 'hoverable';
                
                wrap.appendChild(nameH);
                wrap.appendChild(barWrap);
                wrap.appendChild(img);
                
                // Store stats
                wrap.dataset.hp = scaled.health;
                wrap.dataset.maxHp = scaled.health;
                wrap.dataset.str = scaled.strength;
                wrap.dataset.speed = scaled.speed;
                wrap.dataset.mag = scaled.magic;
                wrap.dataset.def = scaled.defense;
                wrap.dataset.key = enemyKey;
                wrap.dataset.transformed = 'false';
                
                // Add hover tooltip functionality
                let tooltip = document.getElementById('enemy-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'enemy-tooltip';
                    tooltip.className = 'enemy-tooltip';
                    document.body.appendChild(tooltip);
                }
                
                const showTooltip = (e) => {
                    const isMobile = window.innerWidth <= 768;
                    const rect = wrap.getBoundingClientRect();
                    
                    const currentHp = Number(wrap.dataset.hp) || 0;
                    const currentMaxHp = Number(wrap.dataset.maxHp) || 1;
                    const currentStr = Number(wrap.dataset.str) || 0;
                    const currentMag = Number(wrap.dataset.mag) || 0;
                    const currentSpeed = Number(wrap.dataset.speed) || 0;
                    const currentDef = Number(wrap.dataset.def) || 0;
                    const specialEffect = base.specialEffect || 'No special effect';
                    
                    tooltip.innerHTML = `
                        <h4>${enemyKey} (Level ${enemyLevel})</h4>
                        <div class="stat-row"><span>Health:</span><span>${currentHp}/${currentMaxHp}</span></div>
                        <div class="stat-row"><span>Strength:</span><span>${currentStr}</span></div>
                        <div class="stat-row"><span>Magic:</span><span>${currentMag}</span></div>
                        <div class="stat-row"><span>Speed:</span><span>${currentSpeed}</span></div>
                        <div class="stat-row"><span>Defense:</span><span>${currentDef}</span></div>
                        ${specialEffect !== 'No special effect' ? `<div class="special-effect">${specialEffect}</div>` : ''}
                    `;
                    
                    tooltip.classList.add('active');
                    
                    if (isMobile) {
                        tooltip.style.left = Math.max(10, rect.left) + 'px';
                        tooltip.style.top = (rect.bottom + 10) + 'px';
                    } else {
                        tooltip.style.left = (rect.right + 15) + 'px';
                        tooltip.style.top = rect.top + 'px';
                    }
                };
                
                const hideTooltip = () => {
                    tooltip.classList.remove('active');
                };
                
                wrap.addEventListener('mouseenter', showTooltip);
                wrap.addEventListener('mouseleave', hideTooltip);
                wrap.addEventListener('mousemove', showTooltip);
                
                // Make clickable for targeting
                wrap.style.cursor = 'pointer';
                wrap.onclick = () => {
                    getEnemyWrappers().forEach(w=>w.style.outline='');
                    wrap.style.outline = '3px solid red';
                    selectedTarget = wrap;
                    logCombat(`Selected target: ${enemyKey}`);
                    
                    // Check if player can attack
                    const memberKey = getActiveBattleMember();
                    const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                    const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                    const finalList = (attacks.filter(a=>equipped.has(a.id)).concat(attacks.filter(a=>!equipped.has(a.id)))).slice(0,5);
                    const hasAttacks = finalList.length > 0;
                    
                    if (playerCanAct && typeof window.playerPerformAttackOn === 'function') {
                        if (!hasAttacks || (hasAttacks && selectedAttackId)) {
                            window.playerPerformAttackOn(wrap);
                        } else {
                            logCombat('Select an attack first!');
                        }
                    }
                };
                
                // Add to enemies container
                enemiesDiv.appendChild(wrap);
                
                // Register encounter
                if (typeof registerEnemyEncountered === 'function') {
                    registerEnemyEncountered(enemyKey);
                }
                
                // Recalculate action queue with new enemy
                recalculateActionQueue();
            }
            
            function renderEnemies(){
                const enemyArea = document.getElementById('enemy-area');
                const enemiesDiv = document.getElementById('enemies');
                if (!enemyArea || !enemiesDiv) return;
                // Clear existing enemy health bars (we'll create per-enemy bars above enemiesDiv)
                const existingBars = enemyArea.querySelectorAll('.enemy-single');
                existingBars.forEach(n=>n.remove());
                enemiesDiv.innerHTML = '';

                enemyImages.forEach((imgPath, idx) => {
                    const key = enemyKeyFromImage(imgPath) || imgPath;
                    
                    // Register enemy encounter for index tracking
                    if (typeof registerEnemyEncountered === 'function') {
                        registerEnemyEncountered(key);
                    }
                    
                    const base = ENEMY_BASE_STATS[key] || { health:20, strength:3, magic:0, speed:2, defense:0, hBars:1 };
                    const scaled = Object.assign({}, base);
                    
                    // Determine if this is a boss-tier enemy (tier 5 or 6)
                    const isBossEnemy = base.tier >= 5;
                    const isBossTile = battleData.isBossTile || false;
                    
                    // Use exponential scaling: level^0.9 (slightly faster than player/item scaling of level^0.8)
                    let baseScale = Math.pow(level, 0.9);
                    
                    // Apply different scaling based on boss tile vs regular tile
                    let scaleMultiplier = baseScale;
                    if (isBossEnemy) {
                        if (isBossTile) {
                            // Boss on boss tile: buffed (extra 30% stats)
                            scaleMultiplier = baseScale * 1.3;
                        } else {
                            // Boss on regular tile: weaker (70% stats)
                            scaleMultiplier = baseScale * 0.7;
                        }
                    }
                    
                    // Scale health and stats
                    scaled.health = Math.max(1, Math.round(base.health * scaleMultiplier));
                    scaled.strength = Math.round(base.strength * scaleMultiplier);
                    scaled.magic = Math.round(base.magic * scaleMultiplier);
                    scaled.speed = Math.round(base.speed * scaleMultiplier);
                    
                    // Apply challenge modifiers if in challenge mode
                    if (isChallenge && challengeModifiers) {
                        if (challengeModifiers.healthBoost) {
                            scaled.health = Math.round(scaled.health * challengeModifiers.healthBoost);
                        }
                        if (challengeModifiers.damageBoost) {
                            scaled.strength = Math.round(scaled.strength * challengeModifiers.damageBoost);
                            scaled.magic = Math.round(scaled.magic * challengeModifiers.damageBoost);
                        }
                        if (challengeModifiers.speedBoost) {
                            scaled.speed = Math.round(scaled.speed * challengeModifiers.speedBoost);
                        }
                        if (challengeModifiers.defenseBoost) {
                            scaled.defense = Math.round((scaled.defense || 0) * challengeModifiers.defenseBoost);
                        }
                    }

                    // Create enemy visual
                    const wrap = document.createElement('div');
                    wrap.className = 'enemy-single';
                    wrap.style.width = '100%';
                    wrap.style.display = 'flex';
                    wrap.style.flexDirection = 'column';
                    wrap.style.alignItems = 'center';
                    wrap.style.marginBottom = '8px';

                    const nameH = document.createElement('h3');
                    nameH.className = 'w3-text-white';
                    nameH.textContent = (key || 'Enemy') + ` (Lv ${level})`;

                    const barWrap = document.createElement('div');
                    barWrap.className = 'enemy-health-bar w3-light-grey';
                    barWrap.style.width = '80%';
                    barWrap.style.height = '12px';
                    barWrap.style.marginBottom = '6px';
                    const inner = document.createElement('div');
                    inner.className = 'w3-green';
                    inner.style.width = '100%';
                    inner.style.height = '100%';
                    inner.textContent = `HP ${scaled.health}`;
                    barWrap.appendChild(inner);

                    const img = document.createElement('img');
                    img.src = imgPath || (`Enemies/${key.toLowerCase()}.png`);
                    img.alt = key;
                    img.style.maxWidth = '28%';
                    img.style.objectFit = 'contain';
                    img.className = 'hoverable';

                    wrap.appendChild(nameH);
                    wrap.appendChild(barWrap);
                    wrap.appendChild(img);

                    // Store scaled stats on element for later (if needed)
                    wrap.dataset.hp = scaled.health;
                    wrap.dataset.maxHp = scaled.health;
                    wrap.dataset.str = scaled.strength;
                    wrap.dataset.speed = scaled.speed;
                    wrap.dataset.mag = scaled.magic;
                    wrap.dataset.def = scaled.defense || base.defense || 0;
                    wrap.dataset.key = key;
                    wrap.dataset.transformed = 'false'; // Track transformation state for Divine King

                    // Add hover tooltip functionality
                    let tooltip = document.getElementById('enemy-tooltip');
                    if (!tooltip) {
                        tooltip = document.createElement('div');
                        tooltip.id = 'enemy-tooltip';
                        tooltip.className = 'enemy-tooltip';
                        document.body.appendChild(tooltip);
                    }
                    
                    const showTooltip = (e) => {
                        const isMobile = window.innerWidth <= 768;
                        const rect = wrap.getBoundingClientRect();
                        
                        // Get current stats from dataset (handles transformations)
                        const currentKey = wrap.dataset.key || key;
                        const currentBase = ENEMY_BASE_STATS[currentKey] || base;
                        const currentHp = Number(wrap.dataset.hp) || 0;
                        const currentMaxHp = Number(wrap.dataset.maxHp) || 1;
                        const currentStr = Number(wrap.dataset.str) || 0;
                        const currentMag = Number(wrap.dataset.mag) || 0;
                        const currentSpeed = Number(wrap.dataset.speed) || 0;
                        const currentDef = Number(wrap.dataset.def) || 0;
                        const specialEffect = currentBase.specialEffect || 'No special effect';
                        
                        tooltip.innerHTML = `
                            <h4>${currentKey} (Level ${level})</h4>
                            <div class="stat-row"><span>Health:</span><span>${currentHp}/${currentMaxHp}</span></div>
                            <div class="stat-row"><span>Strength:</span><span>${currentStr}</span></div>
                            <div class="stat-row"><span>Magic:</span><span>${currentMag}</span></div>
                            <div class="stat-row"><span>Speed:</span><span>${currentSpeed}</span></div>
                            <div class="stat-row"><span>Defense:</span><span>${currentDef}</span></div>
                            ${specialEffect !== 'No special effect' ? `<div class="special-effect">${specialEffect}</div>` : ''}
                        `;
                        
                        tooltip.classList.add('active');
                        
                        // Position tooltip
                        if (isMobile) {
                            // Below enemy on mobile
                            tooltip.style.left = Math.max(10, rect.left) + 'px';
                            tooltip.style.top = (rect.bottom + 10) + 'px';
                        } else {
                            // To the right on desktop
                            tooltip.style.left = (rect.right + 15) + 'px';
                            tooltip.style.top = rect.top + 'px';
                        }
                    };
                    
                    const hideTooltip = () => {
                        tooltip.classList.remove('active');
                    };
                    
                    wrap.addEventListener('mouseenter', showTooltip);
                    wrap.addEventListener('mouseleave', hideTooltip);
                    wrap.addEventListener('mousemove', showTooltip);

                    // Make enemy clickable for target selection
                    wrap.style.cursor = 'pointer';
                    wrap.onclick = () => {
                        // clear previous highlights
                        getEnemyWrappers().forEach(w=>w.style.outline='');
                        wrap.style.outline = '3px solid red';
                        selectedTarget = wrap;
                        logCombat(`Selected target: ${wrap.querySelector('img').alt}`);
                        // Only perform attack from clicking an enemy if it's the player's turn AND an attack is selected (or no attacks exist)
                        const memberKey = getActiveBattleMember();
                        const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                        const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                        const finalList = (attacks.filter(a=>equipped.has(a.id)).concat(attacks.filter(a=>!equipped.has(a.id)))).slice(0,5);
                        const hasAttacks = finalList.length > 0;
                        if (playerCanAct && typeof window.playerPerformAttackOn === 'function') {
                            if (!hasAttacks || (hasAttacks && selectedAttackId)) {
                                window.playerPerformAttackOn(wrap);
                            } else {
                                // Prompt player to select an attack first
                                logCombat('Please select an attack before targeting an enemy.');
                            }
                        } else if (!playerCanAct) {
                            logCombat('Wait for your turn to attack!');
                        }
                    };

                    enemyArea.insertBefore(wrap, enemiesDiv);
                });
            }

            // Populate attacks area for active battle member
            function renderAttacksForPlayer(){
                const atkArea = document.getElementById('Attacks');
                if (!atkArea) return;
                atkArea.innerHTML = '';
                const memberKey = getActiveBattleMember();
                const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                // Show up to 5 attack slots, mark equipped ones first
                const equippedList = attacks.filter(a=>equipped.has(a.id));
                const invList = attacks.filter(a=>!equipped.has(a.id));
                const finalList = equippedList.concat(invList).slice(0,5);
                finalList.forEach(a=>{
                    const slot = document.createElement('div');
                    slot.className = 'attack-slot';
                    slot.innerHTML = `<img src="${(ITEM_TABLE && ITEM_TABLE[a.itemName] && ITEM_TABLE[a.itemName].image) || 'Assests/empty-slot.png'}" alt="${a.name}"><span>${a.name}</span>`;
                    atkArea.appendChild(slot);
                });
            }

            // Run updates
            updatePartyDisplay();
            updatePartySlotHighlight();
            updatePlayerArea();
            renderEnemies();
            renderAttacksForPlayer();
            // DO NOT mark initial member as participant - they must deal or take damage first

            // Make party slots clickable to switch members during battle
            function enablePartySlotSwitching(){
                const slotIds = ['one', 'two', 'three', 'four', 'five'];
                slotIds.forEach((id, idx) => {
                    const slot = document.getElementById(`slot-${id}`);
                    if (slot) {
                        slot.style.cursor = 'pointer';
                        slot.onclick = () => {
                            const key = ['ONE','TWO','THREE','FOUR','FIVE'][idx];
                            // Check if it's player's turn before allowing switch
                            if (!playerCanAct || !playerWaiting) {
                                logCombat("You can only switch party members during your turn!");
                                return;
                            }
                            switchBattleMember(key);
                        };
                    }
                });
            }
            enablePartySlotSwitching();

                            // -------------------- Combat engine --------------------
                            const DEBUG_COMBAT = true;
                            function logCombat(msg){
                                try { console.log('[combat] '+msg); } catch(e){}
                                if (!DEBUG_COMBAT) return;
                                const box = document.getElementById('combat-debug');
                                if (!box) return;
                                const line = document.createElement('div');
                                line.textContent = msg;
                                box.appendChild(line);
                                box.scrollTop = box.scrollHeight;
                            }

                            let selectedAttackId = null;
                    // Map of enemy wrappers in order
                    function getEnemyWrappers(){
                        return Array.from(document.querySelectorAll('.enemy-single'));
                    }

                    // Make attack slots clickable/selectable
                    function enableAttackSelection(){
                        const atkArea = document.getElementById('Attacks');
                        if (!atkArea) return;
                        atkArea.querySelectorAll('.attack-slot').forEach(slot=>{
                            slot.style.cursor = 'pointer';
                            slot.onclick = () => {
                                // clear previous highlights
                                atkArea.querySelectorAll('.attack-slot').forEach(s=>s.style.outline='');
                                slot.style.outline = '3px solid gold';
                                // find index of slot among children
                                const idx = Array.prototype.indexOf.call(atkArea.children, slot);
                                // selectedAttackId will map to the attack objects displayed order
                                const memberKey = getActiveBattleMember();
                                const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                                const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                                const equippedList = attacks.filter(a=>equipped.has(a.id));
                                const invList = attacks.filter(a=>!equipped.has(a.id));
                                const finalList = equippedList.concat(invList).slice(0,5);
                                const atk = finalList[idx];
                                                        selectedAttackId = atk ? atk.id : null;
                                                        // Clear any previously selected enemy  selecting attack should not auto-attack
                                                        getEnemyWrappers().forEach(w=>w.style.outline='');
                                                        selectedTarget = null;
                            };
                        });
                    }
                    enableAttackSelection();

                    // Helper to update enemy bar visuals when hp changes
                    function updateEnemyBar(wrap){
                        const bar = wrap.querySelector('.enemy-health-bar .w3-green');
                        if (!bar) return;
                        const cur = Number(wrap.dataset.hp);
                        const max = Number(wrap.dataset.maxHp) || 1;
                        const pct = Math.max(0, Math.min(100, Math.round((cur/max)*100)));
                        bar.style.width = pct + '%';
                        bar.textContent = `HP ${Math.max(0,cur)}/${max}`;
                        
                        // Update status effect display after health update
                        updateStatusEffectDisplay();
                    }
                    
                    // Display active status effects on enemies and players
                    function updateStatusEffectDisplay(){
                        // Safety check - only run if status effects are initialized
                        if (typeof enemyStatusEffects === 'undefined' || typeof playerStatusEffects === 'undefined') return;
                        
                        // Show status effects on enemies
                        const enemyWraps = getEnemyWrappers();
                        enemyWraps.forEach((wrap, idx) => {
                            const effects = enemyStatusEffects[idx];
                            // Remove any existing status display first to prevent duplicates
                            const oldDisplay = wrap.querySelector('.status-effects-display');
                            if (oldDisplay) oldDisplay.remove();
                            
                            let existing = document.createElement('div');
                            existing.className = 'status-effects-display';
                            wrap.appendChild(existing);
                            
                            if (effects && effects.length > 0) {
                                const icons = effects.map(e => {
                                    const icon = e.type === 'burn' ? '' : 
                                                 e.type === 'leech' ? '' : 
                                                 e.type === 'bleed' ? '' : 
                                                 e.type === 'grim' ? '' : 
                                                 e.type === 'chill' ? '' : '?';
                                    const stackDisplay = (e.stacks && e.stacks > 1) ? `${e.stacks}` : '';
                                    return `<span title="${e.type.toUpperCase()}${stackDisplay}">${icon}${stackDisplay}</span>`;
                                }).join(' ');
                                existing.innerHTML = icons;
                                existing.style.display = 'block';
                            } else {
                                existing.style.display = 'none';
                            }
                        });
                        
                        // Show status effects on player (in player stats display)
                        const memberKey = getActiveBattleMember();
                        const effects = playerStatusEffects[memberKey];
                        let playerEffectDisplay = document.getElementById('player-status-effects');
                        if (!playerEffectDisplay) {
                            const statsDisplay = document.getElementById('player-stats-display');
                            if (statsDisplay) {
                                playerEffectDisplay = document.createElement('div');
                                playerEffectDisplay.id = 'player-status-effects';
                                playerEffectDisplay.style.marginTop = '5px';
                                playerEffectDisplay.style.fontSize = '18px';
                                statsDisplay.appendChild(playerEffectDisplay);
                            }
                        }
                        if (playerEffectDisplay) {
                            if (effects && effects.length > 0) {
                                const icons = effects.map(e => {
                                    const icon = e.type === 'burn' ? '' : 
                                                 e.type === 'leech' ? '' : 
                                                 e.type === 'bleed' ? '' : 
                                                 e.type === 'grim' ? '' : 
                                                 e.type === 'chill' ? '' : '?';
                                    const stackDisplay = (e.stacks && e.stacks > 1) ? `${e.stacks}` : '';
                                    return `<span title="${e.type.toUpperCase()}${stackDisplay}">${icon}${stackDisplay}</span>`;
                                }).join(' ');
                                playerEffectDisplay.innerHTML = `Status: ${icons}`;
                                playerEffectDisplay.style.display = 'block';
                            } else {
                                playerEffectDisplay.style.display = 'none';
                            }
                        }
                    }

                            // Track whether player is allowed to act this turn (set by scheduler)
                            let playerCanAct = false;
                            let playerWaiting = false; // avoids re-prompting repeatedly
                            let selectedTarget = null;

                    // Combat scheduler using speed-based attack ratios (GCD method)
                    // Helper: compute GCD for ratio simplification
                    function gcd(a, b) {
                        while (b) { const t = b; b = a % b; a = t; }
                        return a;
                    }
                    
                    // Get effective speed accounting for chill
                    function getEffectiveSpeed(targetType, targetKey, baseSpeed) {
                        const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                        if (!effectsArray) return baseSpeed;
                        const chill = effectsArray.find(e => e.type === 'chill');
                        if (chill) {
                            return Math.max(1, Math.round(baseSpeed * 0.75)); // 25% speed reduction
                        }
                        return baseSpeed;
                    }

                    let combatRunning = true;
                    let actionQueue = [];
                    let queueIndex = 0;
                    let playerAttacksPerCycle = 0;
                    
                    // Update turn order display UI
                    function updateTurnOrderDisplay() {
                        const container = document.getElementById('turn-order-queue');
                        if (!container) return;
                        
                        container.innerHTML = '';
                        
                        // Show next 8 turns in the queue
                        const displayCount = Math.min(8, actionQueue.length);
                        for (let i = 0; i < displayCount; i++) {
                            const idx = (queueIndex + i) % actionQueue.length;
                            const action = actionQueue[idx];
                            
                            const box = document.createElement('div');
                            box.className = 'turn-box';
                            
                            if (action === 'p') {
                                // Player turn
                                box.classList.add('player-turn');
                                const img = document.createElement('img');
                                img.src = 'Assests/player.png';
                                img.alt = 'Player';
                                box.appendChild(img);
                            } else if (action.type === 'e') {
                                // Enemy turn
                                box.classList.add('enemy-turn');
                                const enemies = getEnemyWrappers();
                                const enemyWrap = enemies[action.index];
                                if (enemyWrap) {
                                    const enemyImg = enemyWrap.querySelector('img');
                                    const img = document.createElement('img');
                                    img.src = enemyImg ? enemyImg.src : 'Enemies/skull.png';
                                    img.alt = 'Enemy';
                                    box.appendChild(img);
                                    
                                    // Add enemy number
                                    const numLabel = document.createElement('div');
                                    numLabel.className = 'enemy-number';
                                    numLabel.textContent = `#${action.index + 1}`;
                                    box.appendChild(numLabel);
                                }
                            }
                            
                            // Highlight the current/next turn
                            if (i === 0) {
                                box.classList.add('active');
                            }
                            
                            container.appendChild(box);
                        }
                    }

                    // Recalculate action queue based on current active member speed and ALL enemy speeds
                    function recalculateActionQueue() {
                        const member = PARTY_STATS[getActiveBattleMember()];
                        if (!member) return;
                        const enemies = getEnemyWrappers();
                        if (enemies.length === 0) return;

                        // Get player speed with chill effect
                        const memberKey = getActiveBattleMember();
                        const basePlayerSpeed = Math.max(1, Number(member.SPEED) || 1);
                        const pSpeed = getEffectiveSpeed('player', memberKey, basePlayerSpeed);

                        // Collect all enemy speeds with chill effects
                        const enemySpeeds = enemies.map((wrap, idx) => {
                            const baseSpeed = Math.max(1, Number(wrap.dataset.speed) || Number(wrap.dataset.str) || 1);
                            const effectiveSpeed = getEffectiveSpeed('enemy', idx, baseSpeed);
                            return { wrap, index: idx, speed: effectiveSpeed };
                        }).filter(e => Number(e.wrap.dataset.hp) > 0); // Only alive enemies

                        if (enemySpeeds.length === 0) return;

                        // Find GCD of all speeds (player + all enemies)
                        let allSpeeds = [Math.round(pSpeed), ...enemySpeeds.map(e => Math.round(e.speed))];
                        let g = allSpeeds[0];
                        for (let i = 1; i < allSpeeds.length; i++) {
                            g = gcd(g, allSpeeds[i]);
                        }

                        // Calculate attacks per cycle for player
                        playerAttacksPerCycle = Math.round(pSpeed) / g;

                        // Create action queue: 'p' for player, {type:'e', index:N, enemyId:name} for each enemy
                        actionQueue = [];
                        const playerActions = [];
                        const enemyActionsByEnemy = {}; // Track actions per individual enemy
                        
                        for (let i = 0; i < playerAttacksPerCycle; i++) playerActions.push('p');
                        
                        // Add actions for each enemy based on their individual speed
                        let totalEnemyActions = 0;
                        enemySpeeds.forEach(enemyData => {
                            const enemyAttacks = Math.round(enemyData.speed) / g;
                            const enemyName = enemyData.wrap.querySelector('img') ? enemyData.wrap.querySelector('img').alt : `Enemy${enemyData.index}`;
                            enemyActionsByEnemy[enemyData.index] = {
                                actions: [],
                                name: enemyName,
                                count: enemyAttacks
                            };
                            for (let i = 0; i < enemyAttacks; i++) {
                                enemyActionsByEnemy[enemyData.index].actions.push({ type: 'e', index: enemyData.index, enemyId: enemyName });
                                totalEnemyActions++;
                            }
                        });
                        
                        // Interleave player and all enemy actions evenly
                        // Strategy: distribute actions proportionally across the cycle
                        const totalActions = playerActions.length + totalEnemyActions;
                        
                        // Create sorted list of all action sources with their counts
                        const actionSources = [
                            { type: 'player', actions: playerActions, remaining: playerActions.length, ratio: playerActions.length / totalActions }
                        ];
                        
                        Object.keys(enemyActionsByEnemy).forEach(enemyIdx => {
                            const enemyData = enemyActionsByEnemy[enemyIdx];
                            actionSources.push({
                                type: 'enemy',
                                enemyIndex: parseInt(enemyIdx),
                                actions: enemyData.actions,
                                remaining: enemyData.count,
                                ratio: enemyData.count / totalActions,
                                name: enemyData.name
                            });
                        });
                        
                        // Always start with player
                        if (actionSources[0].remaining > 0) {
                            actionQueue.push(actionSources[0].actions.shift());
                            actionSources[0].remaining--;
                        }
                        
                        // Distribute remaining actions evenly
                        while (actionQueue.length < totalActions) {
                            // Calculate how much each source has contributed relative to their target
                            actionSources.forEach(source => {
                                const currentCount = actionQueue.filter(a => {
                                    if (source.type === 'player') return a === 'p';
                                    return a.type === 'e' && a.index === source.enemyIndex;
                                }).length;
                                source.deficit = (source.ratio * actionQueue.length) - currentCount;
                            });
                            
                            // Sort by deficit (highest first) - but filter out sources with no remaining actions
                            const availableSources = actionSources.filter(s => s.remaining > 0);
                            if (availableSources.length === 0) break;
                            
                            availableSources.sort((a, b) => b.deficit - a.deficit);
                            
                            // Add action from the source with highest deficit
                            const nextSource = availableSources[0];
                            actionQueue.push(nextSource.actions.shift());
                            nextSource.remaining--;
                        }
                        
                        queueIndex = 0;
                        
                        const totalEnemyAttacks = actionQueue.filter(a => typeof a === 'object' && a.type === 'e').length;
                        logCombat(`Action queue recalculated: Player ${playerAttacksPerCycle}/cycle, Total Enemy attacks ${totalEnemyAttacks}/cycle (${enemySpeeds.length} enemies)`);
                        
                        // Update turn order display
                        updateTurnOrderDisplay();
                    }

                    function startCombatLoop(){
                        const member = PARTY_STATS[getActiveBattleMember()];
                        if (!member) return;
                        // Gather active enemy wrappers and their stats
                        const enemies = getEnemyWrappers().map(w=>({wrap:w, hp: Number(w.dataset.hp), maxHp: Number(w.dataset.maxHp), str: Number(w.dataset.str)||0}));

                        // If no enemies, nothing to do
                        if (enemies.length === 0) return;

                        // Initialize action queue
                        recalculateActionQueue();

                        function pickNextActor(){
                            // Pick from queue; when depleted, regenerate
                            if (queueIndex >= actionQueue.length) {
                                queueIndex = 0;
                                // Recalculate queue in case enemies died or speeds changed
                                recalculateActionQueue();
                            }
                            const action = actionQueue[queueIndex++];
                            
                            // Update turn order display to show new queue position
                            updateTurnOrderDisplay();
                            
                            // action is either 'p' or {type:'e', index:N}
                            if (action === 'p') return { type: 'player' };
                            if (action.type === 'e') return { type: 'enemy', enemyIndex: action.index };
                            return { type: 'enemy', enemyIndex: 0 }; // fallback
                        }

                                function getFirstAliveEnemy(){
                                    const arr = getEnemyWrappers();
                                    for (const w of arr){
                                        if (Number(w.dataset.hp) > 0) return w;
                                    }
                                    return null;
                                }

                                // Coral ability tracking - consecutive attacks for bonus damage (max 80%)
                                let consecutiveAttacks = 0;
                                
                                // Overuse ability tracking (ability 7) - consecutive attacks for 200% bonus
                                let overuseConsecutive = 0;
                                
                                // After Shock ability tracking (ability 12) - opponent's next attack ignored
                                let afterShockActive = false;
                                let afterShockCooldown = 0;
                                
                                // Pixel Combo ability tracking (ability 13)
                                let pixelComboCount = 0;
                                let pixelComboActive = false;
                                
                                // Burn ground effect tracking (ability 8) - enemies in burn zone
                                const burnGroundEffects = {}; // {enemyIndex: {duration, damage}}
                                
                                // Enhance ability tracking (ability 19) - permanent stat boosts for the battle
                                const enhancedStats = {}; // {memberKey: {strength, magic, speed, defense, health}}

                                // Helper function to get all equipped item abilities for a party member
                                function getEquippedAbilities(memberKey) {
                                    const member = PARTY_STATS[memberKey];
                                    if (!member) return [];
                                    
                                    const abilities = [];
                                    const slots = ['HELMET', 'CHEST', 'LEGS', 'BOOTS', 'MAINHAND', 'OFFHAND'];
                                    
                                    for (const slot of slots) {
                                        const itemName = member[slot];
                                        if (!itemName) continue;
                                        
                                        // Look up the item from INVENTORY (equipped items) or ITEM_TABLE
                                        let itemData = null;
                                        if (typeof INVENTORY !== 'undefined') {
                                            itemData = INVENTORY.find(i => i.name === itemName && i.equipped);
                                        }
                                        if (!itemData && typeof ITEM_TABLE !== 'undefined') {
                                            itemData = ITEM_TABLE[itemName];
                                        }
                                        
                                        if (itemData && itemData.ability && itemData.ability > 0) {
                                            abilities.push(itemData.ability);
                                        }
                                    }
                                    
                                    return abilities;
                                }
                                
                                // Helper function to get item data from attack object
                                function getItemFromAttack(attackObj) {
                                    if (!attackObj || !attackObj.itemName) return null;
                                    
                                    // Look up the item from INVENTORY or ITEM_TABLE
                                    let itemData = null;
                                    if (typeof INVENTORY !== 'undefined') {
                                        itemData = INVENTORY.find(i => i.name === attackObj.itemName);
                                    }
                                    if (!itemData && typeof ITEM_TABLE !== 'undefined') {
                                        itemData = ITEM_TABLE[attackObj.itemName];
                                    }
                                    
                                    return itemData;
                                }
                                
                                // Helper function to count alive party members for Carried ability
                                function countAlivePartyMembers() {
                                    let count = 0;
                                    ['ONE','TWO','THREE','FOUR','FIVE'].forEach(key => {
                                        const m = PARTY_STATS[key];
                                        if (m && Number(m.HEALTH) > 0) count++;
                                    });
                                    return count;
                                }
                                
                                // Helper function to get Carried stat multiplier (ability 6)
                                function getCarriedMultiplier(memberKey) {
                                    const equippedAbilities = getEquippedAbilities(memberKey);
                                    if (!equippedAbilities.includes(6)) return 1.0;
                                    
                                    const aliveCount = countAlivePartyMembers();
                                    if (aliveCount > 3) {
                                        // +20% per ally over 3
                                        return 1.0 + ((aliveCount - 3) * 0.2);
                                    } else if (aliveCount < 3) {
                                        // -40% per ally under 3
                                        return Math.max(0.1, 1.0 - ((3 - aliveCount) * 0.4));
                                    }
                                    return 1.0;
                                }

                                // Perform a player attack on a specific enemy wrapper (called when player clicks an enemy)
                                function playerPerformAttackOn(enemyWrap){
                                    if (!enemyWrap) return false;
                                                                            // Ensure current member is counted as participant
                                                                            try { battleParticipants.add(getActiveBattleMember()); } catch(e) {}
                                      const atkArea = document.getElementById('Attacks');
                                      const memberKey = getActiveBattleMember();
                                      const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                                      const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                                    const equippedList = attacks.filter(a=>equipped.has(a.id));
                                    const invList = attacks.filter(a=>!equipped.has(a.id));
                                    const finalList = equippedList.concat(invList).slice(0,5);

                                    let attackObj = null;
                                    if (selectedAttackId) attackObj = attacks.find(a=>a.id === selectedAttackId) || finalList[0] || null;
                                    else attackObj = finalList[0] || attacks[0] || null;
                                    if (!attackObj) attackObj = { name: 'slap', strMultiplier: 1, magicMultiplier: 0, itemName: null };

                                    const enemyDefense = Number( (ENEMY_BASE_STATS[enemyWrap.querySelector('img').alt] && ENEMY_BASE_STATS[enemyWrap.querySelector('img').alt].defense) || 0 );
                                    const attacker = PARTY_STATS[getActiveBattleMember()];
                                    
                                    // Check for attack-specific abilities (10: MultiStrike, 19: Enhance)
                                    const attackSourceItem = getItemFromAttack(attackObj);
                                    const attackAbility = attackSourceItem ? attackSourceItem.ability : 0;
                                    console.log(`[Attack Ability] Attack: ${attackObj.name}, ItemName: ${attackObj.itemName}, SourceItem:`, attackSourceItem, `Ability: ${attackAbility}`);
                                    
                                    // Ability 19: Enhance - Each attack enhances stats with decaying multiplier (100%, 90%, 81%, etc.)
                                    if (attackAbility === 19 && attackSourceItem) {
                                        console.log(`[Enhance] Triggered! Count before: ${enhancedStats[memberKey] ? enhancedStats[memberKey].count : 0}`);
                                        
                                        if (!enhancedStats[memberKey]) {
                                            enhancedStats[memberKey] = { count: 0 };
                                        }
                                        
                                        // Calculate decaying multiplier: 100%, 90%, 81%, 72.9%, etc. (0.9^n)
                                        const decayMultiplier = Math.pow(0.9, enhancedStats[memberKey].count);
                                        
                                        // Get stats from the actual attack source item (equipped) - use floats for precision
                                        const strBoost = Number(attackSourceItem.strength || 0) * decayMultiplier;
                                        const magBoost = Number(attackSourceItem.magic || 0) * decayMultiplier;
                                        const spdBoost = Number(attackSourceItem.speed || 0) * decayMultiplier;
                                        const defBoost = Number(attackSourceItem.defense || 0) * decayMultiplier;
                                        const hpBoost = Number(attackSourceItem.health || 0) * decayMultiplier;
                                        
                                        console.log(`[Enhance] Item stats:`, attackSourceItem, `Multiplier: ${decayMultiplier}, Boosts:`, {strBoost, magBoost, spdBoost, defBoost, hpBoost});
                                        console.log(`[Enhance] Stats BEFORE:`, {STR: attacker.STRENGTH, MAG: attacker.MAGIC, SPD: attacker.SPEED, DEF: attacker.DEFENSE, HP: attacker.HEALTH, MAX_HP: attacker.MAX_HEALTH});
                                        
                                        // Always apply enhancement, even if individual stats round to 0
                                        if (strBoost >= 0.01 || magBoost >= 0.01 || spdBoost >= 0.01 || defBoost >= 0.01 || hpBoost >= 0.01) {
                                            // Apply enhancements with floating point precision
                                            attacker.STRENGTH = Number(attacker.STRENGTH || 0) + strBoost;
                                            attacker.MAGIC = Number(attacker.MAGIC || 0) + magBoost;
                                            attacker.SPEED = Number(attacker.SPEED || 0) + spdBoost;
                                            attacker.DEFENSE = Number(attacker.DEFENSE || 0) + defBoost;
                                            attacker.MAX_HEALTH = Number(attacker.MAX_HEALTH || 0) + hpBoost;
                                            attacker.HEALTH = Number(attacker.HEALTH || 0) + hpBoost;
                                            
                                            console.log(`[Enhance] Stats AFTER:`, {STR: attacker.STRENGTH, MAG: attacker.MAGIC, SPD: attacker.SPEED, DEF: attacker.DEFENSE, HP: attacker.HEALTH, MAX_HP: attacker.MAX_HEALTH});
                                            
                                            enhancedStats[memberKey].count++;
                                            
                                            // Update stats display in battle UI
                                            updatePlayerStatsDisplay();
                                            updatePlayerArea();
                                            
                                            const percentBoost = Math.round(decayMultiplier * 100);
                                            const displayStr = strBoost >= 0.5 ? Math.round(strBoost) : strBoost.toFixed(1);
                                            const displayMag = magBoost >= 0.5 ? Math.round(magBoost) : magBoost.toFixed(1);
                                            const displaySpd = spdBoost >= 0.5 ? Math.round(spdBoost) : spdBoost.toFixed(1);
                                            const displayDef = defBoost >= 0.5 ? Math.round(defBoost) : defBoost.toFixed(1);
                                            const displayHp = hpBoost >= 0.5 ? Math.round(hpBoost) : hpBoost.toFixed(1);
                                            logCombat(` Enhance (${percentBoost}%): +${displayStr} STR, +${displayMag} MAG, +${displaySpd} SPD, +${displayDef} DEF, +${displayHp} HP`);
                                        } else {
                                            console.log(`[Enhance] Skipped - all boosts below 0.01`);
                                        }
                                    }
                                    
                                    // Apply Carried multiplier (ability 6) to stats
                                    const carriedMult = getCarriedMultiplier(memberKey);
                                    const str = Number(attacker.STRENGTH||0) * carriedMult;
                                    const mag = Number(attacker.MAGIC||0) * carriedMult;
                                    const strMult = Number(attackObj.strMultiplier||0);
                                    const magMult = Number(attackObj.magicMultiplier||0);
                                    
                                    // Get enemy index for status tracking
                                    const enemyIndex = Array.from(getEnemyWrappers()).indexOf(enemyWrap);
                                    
                    // Apply bleed multiplier if present
                    const bleedMult = getBleedMultiplier('enemy', enemyIndex);
                    
                    // Calculate base damage before defense
                    const baseDmg = (mag * magMult + str * strMult) * bleedMult;
                    
                    // Apply defense with diminishing returns: damage reduction = def / (def + 100)
                    // This ensures attacks always deal at least some damage (max 95% reduction)
                    // and defense has better scaling without hard cutoffs
                    const defenseReduction = enemyDefense / (enemyDefense + 100);
                    const damageAfterDefense = baseDmg * (1 - defenseReduction * 0.95); // Max 95% reduction
                    
                    let dmg = Math.max(1, Math.round(Math.max(damageAfterDefense, baseDmg * 0.05)));
                    if (isNaN(dmg)) dmg = 1;                                    // ===== ITEM ABILITIES =====
                                    // Get all equipped abilities for the active member
                                    const equippedAbilities = getEquippedAbilities(memberKey);
                                    console.log(`[Abilities] Member ${memberKey} equipped abilities:`, equippedAbilities);
                                    
                                    // Ability 13: Pixel Combo - Reduce damage to 50%, with mini-game for extra attacks
                                    let pixelComboMultiplier = 1.0;
                                    if (equippedAbilities.includes(13)) {
                                        pixelComboMultiplier = pixelComboCount >= 8 ? 1.0 : 0.5;
                                    }
                                    dmg = Math.round(dmg * pixelComboMultiplier);
                                    
                                    // Ability 7: Overuse - Consecutive attacks deal 200% bonus but 20% recoil
                                    let overuseSelfDamage = 0;
                                    if (equippedAbilities.includes(7)) {
                                        const overuseBonus = Math.round(dmg * 2.0); // 200% bonus
                                        dmg += overuseBonus;
                                        overuseSelfDamage = Math.round(dmg * 0.2); // 20% recoil
                                        overuseConsecutive++;
                                        logCombat(` Overuse: +${overuseBonus} damage (200% bonus)`);
                                    } else {
                                        overuseConsecutive = 0;
                                    }
                                    
                                    // Ability 2: Coral - Consecutive attacks deal bonus damage (20% per turn, max 80%)
                                    if (equippedAbilities.includes(2)) {
                                        const coralBonus = Math.min(consecutiveAttacks * 0.2, 0.8); // Max 80%
                                        if (coralBonus > 0) {
                                            const bonusDmg = Math.round(dmg * coralBonus);
                                            dmg += bonusDmg;
                                            logCombat(` Coral Bonus: +${bonusDmg} damage (${Math.round(coralBonus * 100)}%)`);
                                        }
                                        consecutiveAttacks++;
                                    } else {
                                        consecutiveAttacks = 0; // Reset if coral not equipped
                                    }
                                    
                                    // Ability 6: Carried - Log if multiplier is active
                                    if (equippedAbilities.includes(6) && carriedMult !== 1.0) {
                                        const aliveCount = countAlivePartyMembers();
                                        logCombat(` Carried: ${aliveCount} allies (${Math.round((carriedMult - 1) * 100)}% stat bonus)`);
                                    }
                                    
                                    // Ability 17: Perfectly Timed - 50% chance to critically strike for 150% damage
                                    if (equippedAbilities.includes(17)) {
                                        const critRoll = Math.random();
                                        if (critRoll < 0.5) {
                                            const critBonus = Math.round(dmg * 0.5);
                                            dmg += critBonus;
                                            logCombat(` CRITICAL STRIKE! +${critBonus} damage (150% total)`);
                                            console.log(`[Perfectly Timed] Critical strike! Roll: ${critRoll.toFixed(3)} < 0.5 | Bonus: ${critBonus} | Total damage: ${dmg}`);
                                        } else {
                                            console.log(`[Perfectly Timed] No crit. Roll: ${critRoll.toFixed(3)} >= 0.5`);
                                        }
                                    }

                                    logCombat(`Player uses ${attackObj.name} on ${enemyWrap.querySelector('img').alt} and deals ${dmg} damage${bleedMult > 1 ? ' (BLEED +' + Math.round((bleedMult - 1) * 100) + '%)' : ''}`);
                                    
                                    // Apply status effect from attack
                                    if (attackObj.status && attackObj.status !== 'none') {
                                        applyStatusEffect(enemyWrap, 'enemy', enemyIndex, attackObj.status, dmg);
                                    }
                                    
                                    // Ability 1: Bleed - Each attack gives bleed status (can stack with attack's bleed)
                                    if (equippedAbilities.includes(1)) {
                                        applyStatusEffect(enemyWrap, 'enemy', enemyIndex, 'bleed', dmg);
                                        logCombat(' Bleed ability activated!');
                                    }
                                    
                                    // Ability 5: Plasma - Every attack grants random status effect
                                    if (equippedAbilities.includes(5)) {
                                        const plasmaStatuses = ['burn', 'leech', 'bleed', 'grim', 'chill'];
                                        const randomStatus = plasmaStatuses[Math.floor(Math.random() * plasmaStatuses.length)];
                                        applyStatusEffect(enemyWrap, 'enemy', enemyIndex, randomStatus, dmg);
                                        logCombat(` Plasma: Applied ${randomStatus}!`);
                                    }
                                    
                                    // Ability 8: Burn - Set ground aflame (35% magic damage per turn)
                                    if (equippedAbilities.includes(8)) {
                                        const burnDmg = Math.round(Number(attacker.MAGIC||0) * 0.35);
                                        burnGroundEffects[enemyIndex] = { duration: 3, damage: burnDmg };
                                        logCombat(` Burn: Ground aflame! ${burnDmg} damage/turn for 3 turns`);
                                    }
                                    
                                    // Ability 12: After Shock - Next enemy attack ignored (2 turn cooldown)
                                    if (equippedAbilities.includes(12) && afterShockCooldown === 0) {
                                        afterShockActive = true;
                                        afterShockCooldown = 2;
                                        logCombat(` After Shock: Next enemy attack will be ignored!`);
                                    }
                                    
                                    // Apply Overuse self-damage
                                    if (overuseSelfDamage > 0) {
                                        attacker.HEALTH = Math.max(1, Number(attacker.HEALTH) - overuseSelfDamage);
                                        updatePlayerArea();
                                        logCombat(` Overuse recoil: ${overuseSelfDamage} self-damage`);
                                    }
                                    
                                    // Decrement bleed duration
                                    decrementBleed('enemy', enemyIndex);
                                    
                                    const curHp = Number(enemyWrap.dataset.hp) - dmg;
                                    enemyWrap.dataset.hp = Math.max(0, curHp);
                                    updateEnemyBar(enemyWrap);
                                    
                                    // Ability 10: MultiStrike - Attack twice with this attack
                                    if (attackAbility === 10 && Number(enemyWrap.dataset.hp) > 0) {
                                        // Recalculate damage for second strike (same formula)
                                        const str2 = Number(attacker.STRENGTH||0) * carriedMult;
                                        const mag2 = Number(attacker.MAGIC||0) * carriedMult;
                                        const bleedMult2 = getBleedMultiplier('enemy', enemyIndex);
                                        let dmg2 = Math.round((mag2 * magMult + str2 * strMult - enemyDefense) * bleedMult2);
                                        if (isNaN(dmg2) || dmg2 < 1) dmg2 = 1;
                                        
                                        const curHp2 = Number(enemyWrap.dataset.hp) - dmg2;
                                        enemyWrap.dataset.hp = Math.max(0, curHp2);
                                        updateEnemyBar(enemyWrap);
                                        logCombat(` MultiStrike: Second hit deals ${dmg2} damage!`);
                                        
                                        // Apply attack status on second hit too
                                        if (attackObj.status && attackObj.status !== 'none') {
                                            applyStatusEffect(enemyWrap, 'enemy', enemyIndex, attackObj.status, dmg2);
                                        }
                                    }

                                                // Play hit animation on the enemy image
                                                try {
                                                    const img = enemyWrap.querySelector('img');
                                                    if (img) {
                                                        img.classList.remove('hit-animation');
                                                        // Force reflow to restart animation
                                                        void img.offsetWidth;
                                                        img.classList.add('hit-animation');
                                                        setTimeout(()=> img.classList.remove('hit-animation'), 700);
                                                    }
                                                } catch(e){}

                                                  // Ability 13: Pixel Combo mini-game
                                                  if (equippedAbilities.includes(13)) {
                                                      showPixelComboMiniGame(enemyWrap);
                                                      return; // Wait for mini-game to complete
                                                  }

                                                  // After attacking, clear selectedAttackId so player must re-select an attack next time
                                                  selectedAttackId = null;
                                                  // After attacking, consume selection and reset waiting flag to resume queue
                                                  playerCanAct = false;
                                                  playerWaiting = false;
                                                  waitingForPlayerAction = false;

                                    // Check if this enemy dies
                                    if (Number(enemyWrap.dataset.hp) <= 0) {
                                        const enemyName = enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : '';
                                        const enemyKey = enemyWrap.dataset.key || enemyName;
                                        
                                        // Check if this is Divine King (phase 1) - transform to phase 2
                                        const isDivineKing = enemyName.toLowerCase().includes('divineking') || 
                                                           (enemyWrap.dataset.key && enemyWrap.dataset.key.toLowerCase() === 'divineking');
                                        
                                        // Check if this is a crawler with two lives
                                        const isCrawler = enemyKey.toLowerCase().includes('crawler');
                                        const crawlerFirstLife = !enemyWrap.dataset.crawlerSecondForm;
                                        
                                        // Crawler mechanic: Transform to second form on first death
                                        if (isCrawler && crawlerFirstLife) {
                                            logCombat(' Crawler survives! Transforming to frenzied form!');
                                            
                                            const crawlerStats = ENEMY_BASE_STATS['crawler'];
                                            if (crawlerStats && crawlerStats.secondForm) {
                                                const level = battleData.level || 1;
                                                const baseScale = Math.pow(level, 0.9);
                                                const scaleMultiplier = baseScale;
                                                
                                                const secondForm = crawlerStats.secondForm;
                                                enemyWrap.dataset.hp = Math.max(1, Math.round(secondForm.health * scaleMultiplier));
                                                enemyWrap.dataset.maxHp = enemyWrap.dataset.hp;
                                                enemyWrap.dataset.str = Math.round(secondForm.strength * scaleMultiplier);
                                                enemyWrap.dataset.mag = Math.round(secondForm.magic * scaleMultiplier);
                                                enemyWrap.dataset.speed = Math.round(secondForm.speed * scaleMultiplier);
                                                enemyWrap.dataset.def = 0; // No defense in second form
                                                enemyWrap.dataset.crawlerSecondForm = 'true';
                                                
                                                updateEnemyBar(enemyWrap);
                                                recalculateActionQueue();
                                                
                                                logCombat('Crawler is now fragile but extremely fast!');
                                                return true;
                                            }
                                        }
                                        
                                        // Only transform if not already transformed (check for phase flag)
                                        const alreadyTransformed = enemyWrap.dataset.transformed === 'true';
                                        
                                        if (isDivineKing && !alreadyTransformed) {
                                            logCombat(' Divine King transforms into Demon King! ');
                                            
                                            // Transform to Demon King (phase 2)
                                            const demonKingStats = ENEMY_BASE_STATS['demonKing'] || { health:600, strength:25, magic:25, speed:5, defense:30 };
                                            const level = battleData.level || 100;
                                            const baseScale = Math.pow(level, 0.9); // Use exponential scaling
                                            const scaleMultiplier = baseScale * 1.3; // Boss on boss tile
                                            
                                            // Update enemy to demon king
                                            enemyWrap.dataset.hp = Math.max(1, Math.round(demonKingStats.health * scaleMultiplier));
                                            enemyWrap.dataset.maxHp = enemyWrap.dataset.hp;
                                            enemyWrap.dataset.str = Math.round(demonKingStats.strength * scaleMultiplier);
                                            enemyWrap.dataset.mag = Math.round(demonKingStats.magic * scaleMultiplier);
                                            enemyWrap.dataset.speed = Math.round(demonKingStats.speed * scaleMultiplier);
                                            enemyWrap.dataset.def = Math.round((demonKingStats.defense || 0) * scaleMultiplier);
                                            enemyWrap.dataset.key = 'demonKing';
                                            enemyWrap.dataset.transformed = 'true'; // Mark as transformed to prevent re-triggering
                                            
                                            // Update image
                                            const img = enemyWrap.querySelector('img');
                                            if (img) {
                                                img.src = 'Enemies/demonKing.png';
                                                img.alt = 'demonKing';
                                            }
                                            
                                            // Update name display
                                            const nameH = enemyWrap.querySelector('h3');
                                            if (nameH) {
                                                nameH.textContent = `Demon King (Lv ${level})`;
                                            }
                                            
                                            // Update health bar
                                            updateEnemyBar(enemyWrap);
                                            
                                            // Clear status effects for transformation
                                            delete enemyStatusEffects[enemyIndex];
                                            
                                            // Recalculate action queue with new speed
                                            recalculateActionQueue();
                                            
                                            logCombat('Phase 2 begins! The Demon King rises!');
                                            return true;
                                        }
                                        
                                        logCombat('Enemy defeated!');
                                        
                                        // Register enemy defeat for index tracking
                                        const defeatedKey = enemyWrap.dataset.key || (enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : '');
                                        if (typeof registerEnemyDefeated === 'function' && defeatedKey) {
                                            registerEnemyDefeated(defeatedKey);
                                        }
                                        
                                        // Necromancer resurrection mechanic
                                        const allEnemies = getEnemyWrappers();
                                        const hasNecromancer = allEnemies.some(w => {
                                            const key = w.dataset.key || (w.querySelector('img') ? w.querySelector('img').alt : '');
                                            return key.toLowerCase().includes('necromancer') && Number(w.dataset.hp) > 0;
                                        });
                                        
                                        if (hasNecromancer && !enemyWrap.dataset.zombie) {
                                            // Resurrect as zombie with 50% hp and marked as zombie
                                            const maxHp = Number(enemyWrap.dataset.maxHp);
                                            enemyWrap.dataset.hp = Math.max(1, Math.round(maxHp * 0.5));
                                            enemyWrap.dataset.zombie = 'true';
                                            
                                            // Add visual indicator
                                            const nameH = enemyWrap.querySelector('h3');
                                            if (nameH && !nameH.textContent.includes('Zombie')) {
                                                nameH.textContent = 'Zombie ' + nameH.textContent;
                                            }
                                            
                                            updateEnemyBar(enemyWrap);
                                            logCombat(' Necromancer resurrects fallen ally as a zombie!');
                                            return true;
                                        }
                                        
                                        // Hide the defeated enemy completely (remove from DOM)
                                        enemyWrap.remove();
                                        
                                        // Clear status effects for defeated enemy
                                        delete enemyStatusEffects[enemyIndex];
                                        const anyAlive = getEnemyWrappers().some(w => Number(w.dataset.hp) > 0);
                                        if (!anyAlive) {
                                            logCombat('All enemies defeated! Redirecting to home...');
                                            combatRunning = false;
                                            // Handle victory: award EXP, generate loot, show victory modal, and then unlock/redirect
                                            try {
                                                const level = battleData.level || 1;
                                                showVictoryRewards(level);
                                            } catch (e) {
                                                console.error('Error showing victory rewards:', e);
                                                // Fallback: just unlock and go home
                                                try { if (typeof window.clearLevelAndUnlock === 'function') window.clearLevelAndUnlock(battleData.level||1); } catch(_){}
                                                setTimeout(()=> window.location.href = 'home.html', 1500);
                                            }
                                            return true;
                                        }
                                    }
                                    return true;
                                }

                                    // Expose attack performer so click handlers outside can call it when appropriate
                                    try{ window.playerPerformAttackOn = playerPerformAttackOn; } catch(e){}

                        // Apply status effect to a target (enemy or player)
                        function applyStatusEffect(target, targetType, targetKey, effectType, baseDamage) {
                            // targetType: 'enemy' or 'player'
                            // targetKey: enemy index or member key
                            // effectType: from attack.status
                            // baseDamage: the original damage dealt for calculating effect strength
                            
                            if (!effectType || effectType === 'none' || effectType === 'player buff') return;
                            
                            let effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray) {
                                effectsArray = [];
                                if (targetType === 'enemy') enemyStatusEffects[targetKey] = effectsArray;
                                else playerStatusEffects[targetKey] = effectsArray;
                            }
                            
                            // Handle different effect types
                            if (effectType === 'burn') {
                                // Burn: 20% of damage dealt, 3 turns, stacks
                                effectsArray.push({ type: 'burn', turnsLeft: 3, damagePerTurn: Math.round(baseDamage * 0.2) });
                                logCombat(`Applied BURN (${Math.round(baseDamage * 0.2)} dmg/turn for 3 turns)`);
                            } else if (effectType === 'leech') {
                                // Leech: 10% of damage dealt to enemy, heals player, 3 turns, stacks
                                effectsArray.push({ type: 'leech', turnsLeft: 3, damagePerTurn: Math.round(baseDamage * 0.1) });
                                logCombat(`Applied LEECH (${Math.round(baseDamage * 0.1)} dmg+heal/turn for 3 turns)`);
                            } else if (effectType === 'bleed') {
                                // Bleed: 5% stacking damage multiplier, 3 turns
                                // Find existing bleed on this target to stack
                                const existingBleed = effectsArray.find(e => e.type === 'bleed');
                                if (existingBleed) {
                                    existingBleed.stacks = (existingBleed.stacks || 1) + 1;
                                    existingBleed.turnsLeft = 3; // refresh duration
                                    logCombat(`BLEED stacked to ${existingBleed.stacks}x (${existingBleed.stacks * 5}% bonus damage)`);
                                } else {
                                    effectsArray.push({ type: 'bleed', turnsLeft: 3, stacks: 1 });
                                    logCombat(`Applied BLEED (5% bonus damage, stacks)`);
                                }
                            } else if (effectType === 'grim') {
                                // Grim: 2% max HP per turn, bypasses defense, lasts until death, stacks
                                const maxHp = targetType === 'enemy' ? Number(target.dataset.maxHp || 100) : Number(target.MAX_HEALTH || 100);
                                effectsArray.push({ type: 'grim', turnsLeft: 999, damagePerTurn: Math.max(1, Math.round(maxHp * 0.02)) });
                                logCombat(`Applied GRIM (${Math.round(maxHp * 0.02)} dmg/turn until death, stacks)`);
                            } else if (effectType === 'chill') {
                                // Chill: Slows enemy speed by 25% for 3 turns
                                effectsArray.push({ type: 'chill', turnsLeft: 3 });
                                logCombat(`Applied CHILL (25% speed reduction for 3 turns)`);
                                // Recalculate action queue with new speed
                                if (targetType === 'enemy') recalculateActionQueue();
                            } else if (effectType === 'random') {
                                // Random effect: pick one of burn, leech, bleed
                                const randomEffects = ['burn', 'leech', 'bleed'];
                                const chosen = randomEffects[Math.floor(Math.random() * randomEffects.length)];
                                applyStatusEffect(target, targetType, targetKey, chosen, baseDamage);
                            }
                        }
                        
                        // Process status effects for a target at start of their turn
                        function processStatusEffects(target, targetType, targetKey) {
                            const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray || effectsArray.length === 0) return;
                            
                            const toRemove = [];
                            
                            effectsArray.forEach((effect, idx) => {
                                if (effect.type === 'burn') {
                                    // Deal fire damage
                                    const dmg = effect.damagePerTurn || 0;
                                    if (targetType === 'enemy') {
                                        const curHp = Number(target.dataset.hp) - dmg;
                                        target.dataset.hp = Math.max(0, curHp);
                                        updateEnemyBar(target);
                                        logCombat(`BURN deals ${dmg} damage to enemy`);
                                    } else {
                                        target.HEALTH = Math.max(0, Number(target.HEALTH) - dmg);
                                        updatePlayerArea();
                                        logCombat(`BURN deals ${dmg} damage to ${target.NAME}`);
                                    }
                                    effect.turnsLeft--;
                                    if (effect.turnsLeft <= 0) toRemove.push(idx);
                                } else if (effect.type === 'leech') {
                                    // Deal damage to enemy and heal player
                                    const dmg = effect.damagePerTurn || 0;
                                    if (targetType === 'enemy') {
                                        const curHp = Number(target.dataset.hp) - dmg;
                                        target.dataset.hp = Math.max(0, curHp);
                                        updateEnemyBar(target);
                                        // Heal the active player member
                                        const activeMember = PARTY_STATS[getActiveBattleMember()];
                                        if (activeMember) {
                                            activeMember.HEALTH = Math.min(Number(activeMember.MAX_HEALTH), Number(activeMember.HEALTH) + dmg);
                                            updatePlayerArea();
                                        }
                                        logCombat(`LEECH deals ${dmg} damage and heals player ${dmg} HP`);
                                    }
                                    effect.turnsLeft--;
                                    if (effect.turnsLeft <= 0) toRemove.push(idx);
                                } else if (effect.type === 'grim') {
                                    // Deal max HP damage bypassing defense
                                    const dmg = effect.damagePerTurn || 0;
                                    if (targetType === 'enemy') {
                                        const curHp = Number(target.dataset.hp) - dmg;
                                        target.dataset.hp = Math.max(0, curHp);
                                        updateEnemyBar(target);
                                        logCombat(`GRIM deals ${dmg} true damage to enemy`);
                                    } else {
                                        target.HEALTH = Math.max(0, Number(target.HEALTH) - dmg);
                                        updatePlayerArea();
                                        logCombat(`GRIM deals ${dmg} true damage to ${target.NAME}`);
                                    }
                                    // Grim doesn't decrement turns (lasts until death)
                                } else if (effect.type === 'chill') {
                                    // Chill just slows speed, decrement duration
                                    effect.turnsLeft--;
                                    if (effect.turnsLeft <= 0) {
                                        toRemove.push(idx);
                                        logCombat('CHILL expired');
                                        // Recalculate speed when chill expires
                                        if (targetType === 'enemy') recalculateActionQueue();
                                    }
                                }
                                // Bleed is applied as damage multiplier during attack, not as DoT
                            });
                            
                            // Remove expired effects (in reverse to preserve indices)
                            toRemove.sort((a, b) => b - a).forEach(idx => effectsArray.splice(idx, 1));
                        }
                        
                        // Get bleed multiplier for a target
                        function getBleedMultiplier(targetType, targetKey) {
                            const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray) return 1.0;
                            const bleed = effectsArray.find(e => e.type === 'bleed');
                            if (!bleed) return 1.0;
                            // 5% per stack
                            return 1.0 + (bleed.stacks || 1) * 0.05;
                        }
                        
                        // Decrement bleed duration
                        function decrementBleed(targetType, targetKey) {
                            const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray) return;
                            const bleed = effectsArray.find(e => e.type === 'bleed');
                            if (bleed) {
                                bleed.turnsLeft--;
                                if (bleed.turnsLeft <= 0) {
                                    const idx = effectsArray.indexOf(bleed);
                                    if (idx > -1) effectsArray.splice(idx, 1);
                                    logCombat('BLEED expired');
                                }
                            }
                        }
                        
                        // Pixel Combo mini-game (ability 13)
                        function showPixelComboMiniGame(lastTargetWrap) {
                            const optionCount = pixelComboCount >= 8 ? 3 : 4;
                            const enemies = getEnemyWrappers().filter(w => Number(w.dataset.hp) > 0);
                            
                            // Create overlay
                            const overlay = document.createElement('div');
                            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
                            
                            const panel = document.createElement('div');
                            panel.style.cssText = 'background:#222;border:3px solid #00ff00;padding:20px;border-radius:10px;text-align:center;color:#fff;';
                            
                            const title = document.createElement('h2');
                            title.textContent = ' PIXEL COMBO! ';
                            title.style.color = '#00ff00';
                            panel.appendChild(title);
                            
                            const info = document.createElement('p');
                            info.textContent = `Choose the correct symbol to attack again! (${pixelComboCount} combo)`;
                            panel.appendChild(info);
                            
                            const btnContainer = document.createElement('div');
                            btnContainer.style.cssText = 'display:flex;gap:10px;margin-top:20px;';
                            
                            // Generate symbols (one correct, rest infected)
                            const correctSymbol = '';
                            const infectedSymbol = '';
                            const symbols = [];
                            symbols.push(correctSymbol);
                            for (let i = 1; i < optionCount; i++) {
                                symbols.push(infectedSymbol);
                            }
                            
                            // Shuffle
                            for (let i = symbols.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
                            }
                            
                            symbols.forEach(symbol => {
                                const btn = document.createElement('button');
                                btn.textContent = symbol;
                                btn.style.cssText = 'font-size:48px;width:80px;height:80px;cursor:pointer;background:#333;border:2px solid #666;border-radius:5px;color:#fff;';
                                btn.onmouseover = () => btn.style.background = '#444';
                                btn.onmouseout = () => btn.style.background = '#333';
                                
                                btn.onclick = () => {
                                    document.body.removeChild(overlay);
                                    
                                    if (symbol === correctSymbol) {
                                        // Success! Increment combo and attack again
                                        pixelComboCount++;
                                        logCombat(` Pixel Combo Success! (${pixelComboCount} streak)`);
                                        
                                        // Attack again on the same target if alive, otherwise first alive enemy
                                        const target = Number(lastTargetWrap.dataset.hp) > 0 ? lastTargetWrap : enemies[0];
                                        if (target) {
                                            setTimeout(() => playerPerformAttackOn(target), 100);
                                        } else {
                                            // End turn if no targets
                                            selectedAttackId = null;
                                            playerCanAct = false;
                                            playerWaiting = false;
                                            waitingForPlayerAction = false;
                                        }
                                    } else {
                                        // Failed! Reset combo
                                        logCombat(` Pixel Combo Failed! Combo reset.`);
                                        pixelComboCount = 0;
                                        
                                        // End turn
                                        selectedAttackId = null;
                                        playerCanAct = false;
                                        playerWaiting = false;
                                        waitingForPlayerAction = false;
                                    }
                                };
                                
                                btnContainer.appendChild(btn);
                            });
                            
                            panel.appendChild(btnContainer);
                            overlay.appendChild(panel);
                            document.body.appendChild(overlay);
                        }

                        function performPlayerAction(){
                            // Called by the scheduler when it's the player's turn. We set flags so the UI can accept a target click.
                            if (playerWaiting) return; // already waiting for the player's click
                            
                            // Process status effects on player at start of their turn
                            const memberKey = getActiveBattleMember();
                            const target = PARTY_STATS[memberKey];
                            processStatusEffects(target, 'player', memberKey);
                            
                            // Check if player died from status effects
                            if (Number(target.HEALTH) <= 0) {
                                logCombat(`${target.NAME} was defeated by status effects!`);
                                handlePlayerDefeat();
                                return;
                            }
                            
                            playerCanAct = true;
                            playerWaiting = true;
                            logCombat('Player turn: select an attack then click an enemy to perform the action.');
                        }

                        function performEnemyAction(enemyIndex){
                            const allEnemies = getEnemyWrappers();
                            const enemyWrap = allEnemies[enemyIndex];
                            
                            // Skip if this enemy is dead
                            if (!enemyWrap || Number(enemyWrap.dataset.hp) <= 0) return;
                            
                            // Process status effects on this enemy at start of its turn
                            processStatusEffects(enemyWrap, 'enemy', enemyIndex);
                            
                            // Check if enemy died from status effects
                            if (Number(enemyWrap.dataset.hp) <= 0) {
                                logCombat('Enemy defeated by status effects!');
                                const allEnemies = getEnemyWrappers();
                                const anyAlive = allEnemies.some(w => Number(w.dataset.hp) > 0);
                                if (!anyAlive) {
                                    logCombat('All enemies defeated! Redirecting to home...');
                                    combatRunning = false;
                                    try {
                                        const level = battleData.level || 1;
                                        showVictoryRewards(level);
                                    } catch (e) {
                                        console.error('Error showing victory rewards:', e);
                                        try { if (typeof window.clearLevelAndUnlock === 'function') window.clearLevelAndUnlock(battleData.level||1); } catch(_){}
                                        setTimeout(()=> window.location.href = 'home.html', 1500);
                                    }
                                }
                                return;
                            }
                            
                            // Enemy attack: use whichever stat is higher (strength or magic)
                            const enemyStr = Number(enemyWrap.dataset.str) || 1;
                            const enemyMag = Number(enemyWrap.dataset.mag) || 0;
                            
                            // Determine which stat is stronger and build attack accordingly
                            const atk = enemyStr >= enemyMag 
                                ? { strMultiplier: 1, magicMultiplier: 0 } 
                                : { strMultiplier: 0, magicMultiplier: 1 };
                            
                            const target = PARTY_STATS[getActiveBattleMember()];
                            // Count the current active member as participant when they get attacked
                            try { battleParticipants.add(getActiveBattleMember()); } catch(e) {}
                            // Debug: log queue position, speed info, and enemy name before enemy attacks
                            try {
                                const enemyName = enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : 'Unknown Enemy';
                                const enemySpeed = getEffectiveSpeed('enemy', enemyIndex, Number(enemyWrap.dataset.speed) || 1);
                                const attackType = enemyStr >= enemyMag ? 'STR' : 'MAG';
                                const attackStat = enemyStr >= enemyMag ? enemyStr : enemyMag;
                                logCombat(`${enemyName} #${enemyIndex + 1} (${attackType}:${attackStat}, SPD:${enemySpeed}) attacking  queue pos: ${queueIndex}/${actionQueue.length}`);
                            } catch(e){}
                            const defense = Number(target.DEFENSE || 0);
                            
                            // Calculate base damage before defense
                            const baseDmg = enemyMag * atk.magicMultiplier + enemyStr * atk.strMultiplier;
                            
                            // Apply defense with diminishing returns: damage reduction = def / (def + 100)
                            // This ensures attacks always deal at least 5% damage (max 95% reduction)
                            const defenseReduction = defense / (defense + 100);
                            const damageAfterDefense = baseDmg * (1 - defenseReduction * 0.95); // Max 95% reduction
                            
                            let dmg = Math.max(1, Math.round(Math.max(damageAfterDefense, baseDmg * 0.05)));
                            if (isNaN(dmg)) dmg = 1;
                            
                            // Store original damage and check if this was a magic attack
                            const originalDmg = dmg;
                            const isMagicAttack = atk.magicMultiplier > 0;
                            
            // Ability 12: After Shock - Ignore enemy attack if active
            if (afterShockActive) {
                afterShockActive = false;
                logCombat(` After Shock: Enemy attack ignored!`);
                dmg = 0;
            }
            
            // Decrement After Shock cooldown
            if (afterShockCooldown > 0) {
                afterShockCooldown--;
            }
            
            // Player Lightning Status - Ignore enemy attack if active (from Lightning Shark)
            if (typeof playerLightningActive !== 'undefined' && playerLightningActive) {
                playerLightningActive = false;
                logCombat(` Lightning Shield: Enemy attack ignored!`);
                dmg = 0;
            }
            
            // Decrement player lightning cooldown
            if (typeof playerLightningCooldown !== 'undefined' && playerLightningCooldown > 0) {
                playerLightningCooldown--;
            }                            // Apply burn ground damage to this enemy
                            if (burnGroundEffects[enemyIndex]) {
                                const burn = burnGroundEffects[enemyIndex];
                                const burnDmg = burn.damage;
                                const curEnemyHp = Number(enemyWrap.dataset.hp);
                                enemyWrap.dataset.hp = Math.max(0, curEnemyHp - burnDmg);
                                updateEnemyBar(enemyWrap);
                                logCombat(` Burn ground: ${burnDmg} damage to enemy #${enemyIndex + 1}`);
                                
                                burn.duration--;
                                if (burn.duration <= 0) {
                                    delete burnGroundEffects[enemyIndex];
                                    logCombat(` Burn ground expired on enemy #${enemyIndex + 1}`);
                                }
                            }
                            
                            target.HEALTH = (Number(target.HEALTH) || Number(target.MAX_HEALTH) || 0) - dmg;
                            
            // Get the active member key for status effects
            const memberKey = getActiveBattleMember();
            
            // Apply special enemy status effects
            const enemyKey = enemyWrap.dataset.key || (enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : '');
            const enemyBaseStats = ENEMY_BASE_STATS[enemyKey];
            if (enemyBaseStats && enemyBaseStats.attackStatus) {
                // Frozen corpse applies chill on attack
                if (enemyBaseStats.attackStatus === 'chill') {
                    if (!playerStatusEffects[memberKey]) playerStatusEffects[memberKey] = {};
                    playerStatusEffects[memberKey].chill = { duration: 3 };
                    logCombat(` Frozen Touch: ${target.NAME} has been chilled! (-25% speed for 3 turns)`);
                }
            }
            
            // Mage: Apply random status effect
            if (enemyKey === 'Mage') {
                const randomStatuses = ['burn', 'bleed', 'chill'];
                const chosenStatus = randomStatuses[Math.floor(Math.random() * randomStatuses.length)];
                applyStatusEffect(target, 'player', memberKey, chosenStatus, dmg);
                logCombat(` Arcane Curse: Mage applied ${chosenStatus.toUpperCase()}!`);
            }
            
            // Alien: Apply burn status effect
            if (enemyKey === 'alien') {
                applyStatusEffect(target, 'player', memberKey, 'burn', dmg);
                logCombat(` Alien Fire: Applied BURN!`);
            }
            
            // Crawler: Apply bleed status effect
            if (enemyKey === 'crawler') {
                applyStatusEffect(target, 'player', memberKey, 'bleed', dmg);
                logCombat(` Venomous Bite: Applied BLEED!`);
            }
            
            // Vine Lasher: Apply leech status effect
            if (enemyKey === 'vineLasher') {
                applyStatusEffect(target, 'player', memberKey, 'leech', dmg);
                logCombat(` Draining Vines: Applied LEECH!`);
            }
            
            // Cursed Knight: Apply grim status effect
            if (enemyKey === 'cursedKnight') {
                applyStatusEffect(target, 'player', memberKey, 'grim', dmg);
                logCombat(` Cursed Blade: Applied GRIM!`);
            }
            
            // Lightning Shark: Apply lightning status (ignore next attack with 2 turn cooldown)
            if (enemyKey === 'lightning_shark') {
                // Initialize lightning cooldown if not exists
                if (typeof playerLightningCooldown === 'undefined') window.playerLightningCooldown = 0;
                if (playerLightningCooldown <= 0) {
                    window.playerLightningActive = true;
                    window.playerLightningCooldown = 2;
                    logCombat(` Lightning Shock: Player's next enemy attack will be ignored!`);
                }
            }
            
            // Elder Ent: Gain 10% bonus magic stats each turn (compounds)
            if (enemyKey === 'elderEnt') {
                const currentMag = Number(enemyWrap.dataset.mag) || 0;
                const magBoost = Math.max(1, Math.round(currentMag * 0.1));
                enemyWrap.dataset.mag = currentMag + magBoost;
                logCombat(` Ancient Growth: Elder Ent gained ${magBoost} magic (now ${Number(enemyWrap.dataset.mag)})!`);
            }
            
            // Worldroot: Spawn a Vine Lasher (15 levels lower, min level 1)
            if (enemyKey === 'Worldroot') {
                const spawnLevel = Math.max(1, level - 15);
                spawnEnemy('vineLasher', spawnLevel);
                logCombat(` Nature's Call: Worldroot summoned a Vine Lasher (Lv ${spawnLevel})!`);
            }
            
            // King: Spawn King's Guard (15 levels lower, min level 1) and gain 10% bonus stats per King's Guard alive
            if (enemyKey === 'King') {
                const spawnLevel = Math.max(1, level - 15);
                spawnEnemy('kingsGuard', spawnLevel);
                
                // Count alive King's Guards
                const allEnemies = getEnemyWrappers();
                const kingsGuardCount = allEnemies.filter(w => 
                    (w.dataset.key === 'kingsGuard' || (w.querySelector('img') && w.querySelector('img').alt === 'kingsGuard')) 
                    && Number(w.dataset.hp) > 0
                ).length;
                
                if (kingsGuardCount > 0) {
                    const statBoost = 0.1 * kingsGuardCount;
                    const currentStr = Number(enemyWrap.dataset.str) || 0;
                    const currentMag = Number(enemyWrap.dataset.mag) || 0;
                    const currentSpeed = Number(enemyWrap.dataset.speed) || 0;
                    const currentDef = Number(enemyWrap.dataset.def) || 0;
                    
                    enemyWrap.dataset.str = Math.round(currentStr * (1 + statBoost));
                    enemyWrap.dataset.mag = Math.round(currentMag * (1 + statBoost));
                    enemyWrap.dataset.speed = Math.round(currentSpeed * (1 + statBoost));
                    enemyWrap.dataset.def = Math.round(currentDef * (1 + statBoost));
                    
                    logCombat(` Royal Command: King summoned King's Guard and gained ${(statBoost * 100).toFixed(0)}% stats (${kingsGuardCount} guards alive)!`);
                } else {
                    logCombat(` Royal Command: King summoned a King's Guard (Lv ${spawnLevel})!`);
                }
            }                            // Update player health UI
                            updatePlayerArea();
                                        // Play hit animation on player image
                                        try {
                                            const pimg = document.getElementById('player');
                                            if (pimg) {
                                                pimg.classList.remove('hit-animation');
                                                void pimg.offsetWidth;
                                                pimg.classList.add('hit-animation');
                                                setTimeout(()=> pimg.classList.remove('hit-animation'), 700);
                                            }
                                        } catch(e){}
                                        
                                        // ===== DEFENSIVE ITEM ABILITIES =====
                                        // Check if player survived to trigger defensive abilities
                                        const playerSurvived = Number(target.HEALTH) > 0;
                                        const equippedAbilities = getEquippedAbilities(memberKey);
                                        
                                        // Ability 3: Magi Reflect - Reflect 10% of holder's magic damage if survived magic attack
                                        if (playerSurvived && isMagicAttack && equippedAbilities.includes(3)) {
                                            const playerMagic = Number(target.MAGIC || 0);
                                            const reflectDmg = Math.max(1, Math.round(playerMagic * 0.1));
                                            const curEnemyHp = Number(enemyWrap.dataset.hp);
                                            enemyWrap.dataset.hp = Math.max(0, curEnemyHp - reflectDmg);
                                            updateEnemyBar(enemyWrap);
                                            logCombat(` Magi Reflect: ${reflectDmg} magic damage reflected!`);
                                        }
                                        
                                        // Ability 4: Spikes - Counter with 20% STR damage + apply bleed
                                        if (equippedAbilities.includes(4)) {
                                            const playerStr = Number(target.STRENGTH || 0);
                                            const spikeDmg = Math.max(1, Math.round(playerStr * 0.2));
                                            const curEnemyHp = Number(enemyWrap.dataset.hp);
                                            enemyWrap.dataset.hp = Math.max(0, curEnemyHp - spikeDmg);
                                            updateEnemyBar(enemyWrap);
                                            
                                            // Apply bleed to the enemy
                                            applyStatusEffect(enemyWrap, 'enemy', enemyIndex, 'bleed', spikeDmg);
                                            logCombat(` Spikes: ${spikeDmg} counter damage + bleed!`);
                                        }
                                        
                                        if (Number(target.HEALTH) <= 0) {
                                                const activeMember = PARTY_STATS[getActiveBattleMember()];
                                                logCombat(`${activeMember.NAME} has been defeated! Choose another member...`);
                                                handleMemberDeath();
                                                return;
                                        }
                        }

                        // Handle when active member dies - prompt for member switch
                        function handleMemberDeath(){
                            combatRunning = false;
                            const aliveMembers = ['ONE','TWO','THREE','FOUR','FIVE'].filter(key => {
                                const m = PARTY_STATS[key];
                                return m && Number(m.HEALTH) > 0;
                            });

                            if (aliveMembers.length === 0) {
                                logCombat('All party members defeated! Battle lost...');
                                combatRunning = false;
                                
                                // Count defeated enemies
                                const allEnemies = getEnemyWrappers();
                                const totalEnemies = allEnemies.length;
                                const defeatedEnemies = allEnemies.filter(w => Number(w.dataset.hp) <= 0).length;
                                
                                // Calculate partial rewards: 10% base + 30% per enemy defeated
                                const level = battleData.level || 1;
                                const baseExp = Math.max(10, Math.round(100 * level));
                                const defeatExpPercent = 0.10 + (0.30 * (defeatedEnemies / totalEnemies));
                                const partialExp = Math.round(baseExp * defeatExpPercent);
                                
                                // Award partial exp to participants
                                const expInfo = awardExpToParticipants(level, partialExp);
                                
                                // Show defeat modal
                                showDefeatModal(defeatedEnemies, totalEnemies, expInfo, level);
                                return;
                            }

                            // Create overlay to force member selection
                            const overlay = document.createElement('div');
                            overlay.style.position = 'fixed';
                            overlay.style.top = '0';
                            overlay.style.left = '0';
                            overlay.style.width = '100%';
                            overlay.style.height = '100%';
                            overlay.style.background = 'rgba(0,0,0,0.8)';
                            overlay.style.display = 'flex';
                            overlay.style.flexDirection = 'column';
                            overlay.style.justifyContent = 'center';
                            overlay.style.alignItems = 'center';
                            overlay.style.zIndex = '99999';

                            const dialog = document.createElement('div');
                            dialog.style.background = 'rgba(50,50,50,0.95)';
                            dialog.style.border = '3px solid rgb(255,215,0)';
                            dialog.style.borderRadius = '10px';
                            dialog.style.padding = '30px';
                            dialog.style.textAlign = 'center';
                            dialog.style.color = 'white';

                            const title = document.createElement('h2');
                            title.textContent = 'Choose a Party Member to Continue';
                            title.style.marginBottom = '20px';
                            title.style.color = 'rgb(255,215,0)';
                            dialog.appendChild(title);

                            const buttonContainer = document.createElement('div');
                            buttonContainer.style.display = 'flex';
                            buttonContainer.style.gap = '10px';
                            buttonContainer.style.flexWrap = 'wrap';
                            buttonContainer.style.justifyContent = 'center';

                            aliveMembers.forEach((key, idx) => {
                                const member = PARTY_STATS[key];
                                const btn = document.createElement('button');
                                btn.textContent = `${member.NAME} (Lv${member.LEVEL})`;
                                btn.style.padding = '12px 20px';
                                btn.style.fontSize = '16px';
                                btn.style.background = 'rgba(100,200,100,0.8)';
                                btn.style.color = 'white';
                                btn.style.border = '2px solid rgba(100,200,100,1)';
                                btn.style.borderRadius = '5px';
                                btn.style.cursor = 'pointer';
                                btn.style.transition = 'all 0.3s';
                                btn.onmouseover = () => {
                                    btn.style.background = 'rgba(100,200,100,1)';
                                    btn.style.transform = 'scale(1.05)';
                                };
                                btn.onmouseout = () => {
                                    btn.style.background = 'rgba(100,200,100,0.8)';
                                    btn.style.transform = 'scale(1)';
                                };
                                btn.onclick = () => {
                                    switchBattleMember(key, true); // true = emergency switch, bypass turn check
                                    overlay.remove();
                                    combatRunning = true;
                                    // Resume combat after short delay
                                    setTimeout(combatTick, COMBAT_TICK_MS);
                                };
                                buttonContainer.appendChild(btn);
                            });

                            dialog.appendChild(buttonContainer);
                            overlay.appendChild(dialog);
                            document.body.appendChild(overlay);
                        }

                        const COMBAT_TICK_MS = 900; // slower tick so actions are visible
                        let waitingForPlayerAction = false; // Flag to pause queue until player acts

                        // Loop tick
                        function combatTick(){
                            if (!combatRunning) return;
                            // if no alive enemies or active player dead -> end
                            const aliveEnemy = getFirstAliveEnemy();
                            if (!aliveEnemy) { combatRunning = false; return; }
                            const activeMember = PARTY_STATS[getActiveBattleMember()];
                            const playerAlive = activeMember && Number(activeMember.HEALTH) > 0;
                            if (!playerAlive) { logCombat('Current member is KO\'d!'); handleMemberDeath(); return; }

                            // If waiting for player to complete their action, skip this tick
                            if (waitingForPlayerAction) {
                                setTimeout(combatTick, COMBAT_TICK_MS);
                                return;
                            }

                            const actor = pickNextActor();
                            if (actor.type === 'player'){
                                // Prompt player to act and set flag to pause queue
                                waitingForPlayerAction = true;
                                performPlayerAction();
                            } else {
                                // Reset consecutive attack counters when enemy interrupts player's turn
                                consecutiveAttacks = 0;
                                overuseConsecutive = 0;
                                pixelComboCount = 0;
                                performEnemyAction(actor.enemyIndex);
                            }

                            // schedule next tick only if not waiting for player
                            if (!waitingForPlayerAction) {
                                setTimeout(combatTick, COMBAT_TICK_MS);
                            } else {
                                // If waiting for player, still schedule a tick but it will return early
                                setTimeout(combatTick, COMBAT_TICK_MS);
                            }
                        }

                        // Start the ticking loop
                        setTimeout(combatTick, 500);
                    }

                    // Function to start combat (called by button or auto-start)
                    function startCombat() {
                        try {
                            logCombat('Combat started');
                            // Log initial stats
                            const member = PARTY_STATS && PARTY_STATS['ONE'];
                            if (member) {
                                logCombat(`Player HP: ${member.HEALTH}/${member.MAX_HEALTH} STR:${member.STRENGTH} MAG:${member.MAGIC} SPD:${member.SPEED}`);
                            }
                            const first = getEnemyWrappers()[0];
                            if (first) {
                                logCombat(`Enemy HP: ${first.dataset.hp}/${first.dataset.maxHp} STR:${first.dataset.str} SPD:${first.dataset.speed||first.dataset.str}`);
                            }
                            startCombatLoop();
                            // Hide start button after combat starts
                            const startBtn = document.getElementById('start-combat-btn');
                            if (startBtn) {
                                startBtn.style.display = 'none';
                            }
                        } catch(e) {
                            console.error('Error starting combat:', e);
                            logCombat('Error starting combat. Please refresh the page.');
                        }
                    }
                    
                    // Make startCombat globally accessible for button onclick
                    window.startCombat = startCombat;
                    
                    // Auto-start combat on battle entry
                    try {
                        startCombat();
                    } catch(e) {
                        console.error('Auto-start failed:', e);
                        // If auto-start fails, keep button visible for manual start
                    }
                    // -------------------- End combat engine --------------------

        // -------------------- Victory Rewards (loot + EXP) --------------------
        function xpToNext(level){
            // Per spec: level * 100 * sqrt(level) to reach next level
            const lvl = Math.max(1, Number(level)||1);
            return Math.max(1, Math.round(lvl * 100 * Math.sqrt(lvl)));
        }

        function showDefeatModal(defeatedEnemies, totalEnemies, expInfo, level) {
            // Build modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.85)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '100000';

            const panel = document.createElement('div');
            panel.style.background = 'rgba(40,20,20,0.95)';
            panel.style.border = '3px solid #cc0000';
            panel.style.borderRadius = '10px';
            panel.style.padding = '20px 24px';
            panel.style.color = 'white';
            panel.style.minWidth = '320px';
            panel.style.maxWidth = '520px';

            const title = document.createElement('h2');
            title.textContent = 'Defeat';
            title.style.marginTop = '0';
            title.style.color = '#cc0000';
            panel.appendChild(title);

            const message = document.createElement('p');
            message.textContent = 'Your party has been defeated...';
            message.style.marginBottom = '16px';
            panel.appendChild(message);

            // Enemies defeated section
            const enemyDiv = document.createElement('div');
            enemyDiv.style.margin = '10px 0 6px';
            const defeatPercent = Math.round((defeatedEnemies / totalEnemies) * 100);
            enemyDiv.innerHTML = `<strong>Enemies Defeated:</strong> ${defeatedEnemies} / ${totalEnemies} (${defeatPercent}%)`;
            panel.appendChild(enemyDiv);

            // EXP section
            const expDiv = document.createElement('div');
            expDiv.style.margin = '6px 0 10px';
            const fullReward = Math.max(10, Math.round(100 * level));
            const totalPercent = Math.round((expInfo.totalExp / fullReward) * 100);
            expDiv.innerHTML = `<strong>Partial EXP:</strong> ${expInfo.totalExp} (${totalPercent}% of full reward)`;
            const list = document.createElement('ul');
            list.style.margin = '8px 0 0';
            list.style.paddingLeft = '18px';
            expInfo.participants.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name}: +${p.gained} EXP  Lv ${p.level}` + (p.levelsGained>0?` ( +${p.levelsGained})`:'' );
                list.appendChild(li);
            });
            panel.appendChild(expDiv);
            panel.appendChild(list);

            const btnRow = document.createElement('div');
            btnRow.style.display = 'flex';
            btnRow.style.gap = '10px';
            btnRow.style.marginTop = '16px';
            btnRow.style.justifyContent = 'flex-end';

            const ok = document.createElement('button');
            ok.textContent = 'Return to Map';
            ok.style.padding = '10px 14px';
            ok.style.background = 'rgba(200,50,50,0.9)';
            ok.style.border = '2px solid rgba(200,50,50,1)';
            ok.style.borderRadius = '6px';
            ok.style.color = 'white';
            ok.style.cursor = 'pointer';
            ok.onclick = ()=>{ 
                overlay.remove(); 
                // Save game data before leaving
                if (typeof saveGameData === 'function') saveGameData();
                window.location.href = 'map.html'; 
            };

            btnRow.appendChild(ok);
            panel.appendChild(btnRow);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
        }

        function awardExpToParticipants(level, customTotalExp = null){
            // Base total EXP proportional to level
            const totalExp = customTotalExp !== null ? customTotalExp : Math.max(10, Math.round(100 * (Number(level)||1)));
            const participants = Array.from(battleParticipants);
            const count = participants.length || 1;
            const per = Math.floor(totalExp / count);
            const breakdown = [];

            participants.forEach(key => {
                const m = PARTY_STATS[key];
                if (!m) return;
                if (typeof m.XP !== 'number') m.XP = 0;
                if (typeof m.LEVEL !== 'number' || m.LEVEL < 1) m.LEVEL = 1;
                let gain = per;
                let leveled = 0;
                m.XP += gain;
                let need = xpToNext(m.LEVEL);
                while (m.XP >= need) {
                    m.XP -= need;
                    m.LEVEL += 1;
                    leveled += 1;
                    need = xpToNext(m.LEVEL);
                }
                breakdown.push({ key, name: m.NAME||key, gained: gain, newXP: m.XP, level: m.LEVEL, levelsGained: leveled, nextReq: need });
            });

            // Recalculate stats after possible level ups
            try { if (typeof updateStats === 'function') updateStats(); } catch(e){}
            try { if (typeof saveGameData === 'function') saveGameData(); } catch(e){}

            return { totalExp, perExp: per, participants: breakdown };
        }

        function generateVictoryLoot(level){
            try {
                if (typeof window.generateRandomItem === 'function') {
                    // Check if this is the first time clearing this level
                    const progression = typeof window.loadDungeonProgression === 'function' ? window.loadDungeonProgression() : { clearedLevels: [] };
                    const isFirstClear = !progression.clearedLevels.includes(level);
                    const numItems = isFirstClear ? 3 : 1;
                    
                    // Check if this is a boss tile - if so, guarantee mythic rarity
                    const isBossTile = battleData.isBossTile || false;
                    const items = [];
                    
                    for (let i = 0; i < numItems; i++) {
                        let item;
                        if (isBossTile) {
                            // Boss tile: force mythic rarity
                            item = window.generateRandomItem(level, 'mythic');
                            if (i === 0) logCombat(' BOSS REWARD: Mythic item guaranteed!');
                        } else {
                            // Regular tile: random item
                            item = window.generateRandomItem(level);
                        }
                        if (item) items.push(item);
                    }
                    
                    if (isFirstClear && items.length > 1) {
                        logCombat(` FIRST CLEAR BONUS: ${items.length}x loot drops!`);
                    }
                    
                    try { if (typeof saveGameData === 'function') saveGameData(); } catch(e){}
                    return items;
                }
            } catch(e) { console.error('generateRandomItem failed', e); }
            return [];
        }

        function showDefeatModal(defeatedEnemies, totalEnemies, expInfo) {
            // Build modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.85)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '100000';

            const panel = document.createElement('div');
            panel.style.background = 'rgba(40,20,20,0.95)';
            panel.style.border = '3px solid #cc0000';
            panel.style.borderRadius = '10px';
            panel.style.padding = '20px 24px';
            panel.style.color = 'white';
            panel.style.minWidth = '320px';
            panel.style.maxWidth = '520px';

            const title = document.createElement('h2');
            title.textContent = 'Defeat';
            title.style.marginTop = '0';
            title.style.color = '#cc0000';
            panel.appendChild(title);

            const message = document.createElement('p');
            message.textContent = 'Your party has been defeated...';
            message.style.marginBottom = '16px';
            panel.appendChild(message);

            // Enemies defeated section
            const enemyDiv = document.createElement('div');
            enemyDiv.style.margin = '10px 0 6px';
            const defeatPercent = Math.round((defeatedEnemies / totalEnemies) * 100);
            enemyDiv.innerHTML = `<strong>Enemies Defeated:</strong> ${defeatedEnemies} / ${totalEnemies} (${defeatPercent}%)`;
            panel.appendChild(enemyDiv);

            // EXP section
            const expDiv = document.createElement('div');
            expDiv.style.margin = '6px 0 10px';
            const totalPercent = Math.round((expInfo.totalExp / (Math.round((battleData.level||1) * 100 * Math.sqrt(battleData.level||1)))) * 100);
            expDiv.innerHTML = `<strong>Partial EXP:</strong> ${expInfo.totalExp} (${totalPercent}% of full reward)`;
            const list = document.createElement('ul');
            list.style.margin = '8px 0 0';
            list.style.paddingLeft = '18px';
            expInfo.participants.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name}: +${p.gained} EXP  Lv ${p.level}` + (p.levelsGained>0?` ( +${p.levelsGained})`:'' );
                list.appendChild(li);
            });
            panel.appendChild(expDiv);
            panel.appendChild(list);

            const btnRow = document.createElement('div');
            btnRow.style.display = 'flex';
            btnRow.style.gap = '10px';
            btnRow.style.marginTop = '16px';
            btnRow.style.justifyContent = 'flex-end';

            const ok = document.createElement('button');
            ok.textContent = 'Return to Map';
            ok.style.padding = '10px 14px';
            ok.style.background = 'rgba(200,50,50,0.9)';
            ok.style.border = '2px solid rgba(200,50,50,1)';
            ok.style.borderRadius = '6px';
            ok.style.color = 'white';
            ok.style.cursor = 'pointer';
            ok.onclick = ()=>{ 
                overlay.remove(); 
                // Save game data before leaving
                if (typeof saveGameData === 'function') saveGameData();
                window.location.href = 'map.html'; 
            };

            btnRow.appendChild(ok);
            panel.appendChild(btnRow);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
        }

        function showVictoryRewards(level){
            // Compute rewards
            const expInfo = awardExpToParticipants(level);
            const lootArray = generateVictoryLoot(level);

            // Check if this is a challenge mode victory
            const isChallengeVictory = battleData.isChallenge || false;
            const challengeReward = battleData.challengeReward || null;
            const challengeId = battleData.challengeId || null;
            
            // Handle challenge completion
            if (isChallengeVictory && challengeId && challengeReward) {
                // Mark challenge as completed
                try {
                    const completed = JSON.parse(localStorage.getItem('completedChallenges') || '[]');
                    if (!completed.includes(challengeId)) {
                        completed.push(challengeId);
                        localStorage.setItem('completedChallenges', JSON.stringify(completed));
                    }
                } catch(e) {
                    console.error('Failed to mark challenge as completed:', e);
                }
                
                // Award enchantment
                if (typeof window.addEnchantment === 'function') {
                    window.addEnchantment(challengeReward);
                    logCombat(` Challenge Reward: ${challengeReward} enchantment unlocked!`);
                }
            } else {
                // Normal/Hard mode - unlock progression
                try { if (typeof window.clearLevelAndUnlock === 'function') window.clearLevelAndUnlock(level); } catch(e) { console.error('clearLevelAndUnlock failed', e); }
            }

            // Build modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.8)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '100000';

            const panel = document.createElement('div');
            panel.style.background = 'rgba(30,30,30,0.95)';
            panel.style.border = isChallengeVictory ? '3px solid #a335ee' : '3px solid gold';
            panel.style.borderRadius = '10px';
            panel.style.padding = '20px 24px';
            panel.style.color = 'white';
            panel.style.minWidth = '320px';
            panel.style.maxWidth = '600px';

            const title = document.createElement('h2');
            title.textContent = isChallengeVictory ? 'Challenge Complete!' : 'Victory!';
            title.style.marginTop = '0';
            title.style.color = isChallengeVictory ? '#a335ee' : 'gold';
            panel.appendChild(title);
            
            // Show enchantment reward for challenges
            if (isChallengeVictory && challengeReward) {
                const rewardDiv = document.createElement('div');
                rewardDiv.style.margin = '10px 0';
                rewardDiv.style.padding = '15px';
                rewardDiv.style.background = 'rgba(163, 53, 238, 0.2)';
                rewardDiv.style.border = '2px solid #a335ee';
                rewardDiv.style.borderRadius = '8px';
                rewardDiv.innerHTML = `<strong style="color: #a335ee;"> Enchantment Unlocked:</strong> <span style="color: #ff8000; font-weight: bold;">${challengeReward}</span>`;
                panel.appendChild(rewardDiv);
            }

            // Loot section - display multiple items
            const lootDiv = document.createElement('div');
            lootDiv.style.margin = '10px 0 6px';
            const lootHeader = document.createElement('strong');
            lootHeader.textContent = `Loot (${lootArray.length}):`;
            lootDiv.appendChild(lootHeader);
            
            // Track which items are marked for deletion (declare outside to be accessible in button handler)
            const markedForDeletion = new Set();
            
            if (lootArray.length > 0) {
                const itemGrid = document.createElement('div');
                itemGrid.style.display = 'grid';
                itemGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(100px, 1fr))';
                itemGrid.style.gap = '10px';
                itemGrid.style.marginTop = '10px';
                
                lootArray.forEach((loot, index) => {
                    if (!loot) return;
                    const itemCard = document.createElement('div');
                    itemCard.style.textAlign = 'center';
                    itemCard.style.padding = '8px';
                    itemCard.style.background = 'rgba(0,0,0,0.3)';
                    itemCard.style.borderRadius = '6px';
                    itemCard.style.cursor = 'pointer';
                    itemCard.style.transition = 'all 0.2s';
                    itemCard.style.position = 'relative';
                    
                    const rarityColor = (loot.rarity && typeof window.getRarityColor === 'function') ? window.getRarityColor(loot.rarity) : 'gold';
                    
                    // Click handler to toggle deletion mark
                    itemCard.onclick = () => {
                        if (markedForDeletion.has(index)) {
                            // Unmark for deletion
                            markedForDeletion.delete(index);
                            itemCard.style.opacity = '1';
                            itemCard.style.background = 'rgba(0,0,0,0.3)';
                            itemCard.style.border = 'none';
                            deleteLabel.style.display = 'none';
                        } else {
                            // Mark for deletion
                            markedForDeletion.add(index);
                            itemCard.style.opacity = '0.5';
                            itemCard.style.background = 'rgba(100,0,0,0.4)';
                            itemCard.style.border = '2px solid #ff0000';
                            deleteLabel.style.display = 'block';
                        }
                    };
                    
                    if (loot.image) {
                        const img = document.createElement('img');
                        img.src = loot.image;
                        img.alt = loot.name;
                        img.style.width = '64px';
                        img.style.height = '64px';
                        img.style.objectFit = 'contain';
                        img.style.border = `3px solid ${rarityColor}`;
                        img.style.boxShadow = `0 0 10px ${rarityColor}`;
                        img.style.borderRadius = '4px';
                        itemCard.appendChild(img);
                    }
                    
                    const itemName = document.createElement('div');
                    itemName.style.color = rarityColor;
                    itemName.style.fontSize = '0.9em';
                    itemName.style.marginTop = '4px';
                    itemName.textContent = `${loot.name}`;
                    itemCard.appendChild(itemName);
                    
                    const itemLevel = document.createElement('div');
                    itemLevel.style.color = '#aaa';
                    itemLevel.style.fontSize = '0.8em';
                    itemLevel.textContent = `Lv ${loot.level || level}`;
                    itemCard.appendChild(itemLevel);
                    
                    // Delete label (hidden by default)
                    const deleteLabel = document.createElement('div');
                    deleteLabel.textContent = ' DELETE';
                    deleteLabel.style.position = 'absolute';
                    deleteLabel.style.top = '2px';
                    deleteLabel.style.right = '2px';
                    deleteLabel.style.background = 'rgba(255,0,0,0.9)';
                    deleteLabel.style.color = 'white';
                    deleteLabel.style.fontSize = '0.7em';
                    deleteLabel.style.padding = '2px 4px';
                    deleteLabel.style.borderRadius = '3px';
                    deleteLabel.style.fontWeight = 'bold';
                    deleteLabel.style.display = 'none';
                    itemCard.appendChild(deleteLabel);
                    
                    itemGrid.appendChild(itemCard);
                });
                
                lootDiv.appendChild(itemGrid);
                
                // Add deletion info text
                const deletionInfo = document.createElement('div');
                deletionInfo.style.fontSize = '0.85em';
                deletionInfo.style.color = '#aaa';
                deletionInfo.style.marginTop = '8px';
                deletionInfo.style.fontStyle = 'italic';
                deletionInfo.textContent = 'Click items to mark for deletion';
                lootDiv.appendChild(deletionInfo);
            } else {
                const noLoot = document.createElement('div');
                noLoot.textContent = '';
                noLoot.style.marginTop = '6px';
                lootDiv.appendChild(noLoot);
            }
            panel.appendChild(lootDiv);

            // EXP section
            const expDiv = document.createElement('div');
            expDiv.style.margin = '6px 0 10px';
            expDiv.innerHTML = `<strong>EXP:</strong> ${expInfo.totalExp} total  ${expInfo.perExp} each (${expInfo.participants.length} participant${expInfo.participants.length!==1?'s':''})`;
            const list = document.createElement('ul');
            list.style.margin = '8px 0 0';
            list.style.paddingLeft = '18px';
            expInfo.participants.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name}: +${p.gained} EXP  Lv ${p.level}` + (p.levelsGained>0?` ( +${p.levelsGained})`:'' ) + `  Next: ${p.nextReq}`;
                list.appendChild(li);
            });
            panel.appendChild(expDiv);
            panel.appendChild(list);

            const btnRow = document.createElement('div');
            btnRow.style.display = 'flex';
            btnRow.style.gap = '10px';
            btnRow.style.marginTop = '16px';
            btnRow.style.justifyContent = 'flex-end';

            const ok = document.createElement('button');
            ok.textContent = 'Continue';
            ok.style.padding = '10px 14px';
            ok.style.background = 'rgba(100,200,100,0.9)';
            ok.style.border = '2px solid rgba(100,200,100,1)';
            ok.style.borderRadius = '6px';
            ok.style.color = 'white';
            ok.style.cursor = 'pointer';
            ok.onclick = ()=>{ 
                // Remove marked items from INVENTORY before continuing
                if (markedForDeletion.size > 0 && typeof INVENTORY !== 'undefined') {
                    const itemsToDelete = [];
                    lootArray.forEach((loot, index) => {
                        if (markedForDeletion.has(index)) {
                            itemsToDelete.push(loot);
                        }
                    });
                    
                    itemsToDelete.forEach(item => {
                        const idx = INVENTORY.findIndex(i => i === item || (i._uid && item._uid && i._uid === item._uid));
                        if (idx !== -1) {
                            INVENTORY.splice(idx, 1);
                        }
                    });
                    
                    try { if (typeof saveGameData === 'function') saveGameData(); } catch(e){}
                }
                
                overlay.remove();
                
                // Redirect based on mode
                if (isChallengeVictory) {
                    window.location.href = 'challenge.html';
                } else {
                    window.location.href = 'map.html';
                }
            };

            btnRow.appendChild(ok);
            panel.appendChild(btnRow);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
        }

        })();
        </script>
</body>
</html>