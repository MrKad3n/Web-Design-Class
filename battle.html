<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Kaden's Dungeon Game</title>
        <link rel="stylesheet" type="text/css" href="style.css">
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/5/w3.css">
        <link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-blue.css">
        <style>
            /* Arena-focused responsive battle layout */
            body#battle {
                margin: 0;
                padding: 0;
                height: 100vh;
                display: flex;
                flex-direction: column;
                background-image: url('Backgrounds/unknown-battle.png');
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                background-attachment: fixed;
            }
            
            /* Main arena container */
            #battle-container {
                display: grid;
                grid-template-columns: 15% 1fr 20%;
                grid-template-rows: auto auto 1fr auto;
                gap: 0.5rem;
                flex: 1;
                padding: 0.5rem;
                box-sizing: border-box;
                max-height: 100vh;
                overflow: hidden;
            }
            
            /* Central arena area with dark semi-transparent overlay to highlight battle space */
            .arena {
                grid-column: 1 / 3;
                grid-row: 3;
                background: rgba(0, 0, 0, 0.3);
                border: 3px solid rgba(255, 215, 0, 0.5);
                border-radius: 10px;
                padding: 0.5rem;
                display: grid;
                grid-template-columns: 0.8fr 1.4fr 0.8fr;
                gap: 0.4rem;
                align-items: stretch;
                box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.3);
                min-height: 0;
                overflow: hidden;
            }
            
            /* Party sidebar - positioned above arena */
            #party {
                grid-column: 1;
                grid-row: 1;
                display: flex;
                flex-direction: column;
                gap: 0.3rem;
                max-height: 120px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.5);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 5px;
                padding: 0.4rem;
            }
            
            /* Player stats display */
            #player-stats-display {
                grid-column: 1 / 3;
                grid-row: 2;
                background: rgba(0, 0, 0, 0.7);
                border: 2px solid rgba(255, 215, 0, 0.6);
                border-radius: 5px;
                padding: 0.5rem 1rem;
                display: flex;
                justify-content: space-around;
                align-items: center;
                color: white;
                font-size: 0.9rem;
            }
            
            #player-stats-display .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.2rem;
            }
            
            #player-stats-display .stat-label {
                color: rgba(255, 215, 0, 0.8);
                font-size: 0.75rem;
                font-weight: bold;
            }
            
            #player-stats-display .stat-value {
                font-size: 1rem;
                font-weight: bold;
            }
            
            /* Right sidebar for turn order and actions */
            #right-sidebar {
                grid-column: 3;
                grid-row: 1 / 4;
                display: flex;
                flex-direction: column;
                gap: 1rem;
                background: rgba(0, 0, 0, 0.5);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 8px;
                padding: 1rem;
                overflow-y: auto;
            }
            
            /* Leave Battle Button */
            #leave-battle-btn {
                padding: 0.5rem 1rem;
                background: rgba(220, 53, 69, 0.8);
                color: white;
                border: 2px solid rgba(220, 53, 69, 1);
                border-radius: 5px;
                font-size: 1rem;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                text-transform: uppercase;
                box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            }
            
            #leave-battle-btn:hover {
                background: rgba(220, 53, 69, 1);
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
            }
            
            #leave-battle-btn:active {
                transform: scale(0.98);
            }
            
            /* Auto Battle Button */
            #auto-battle-btn {
                padding: 0.5rem 1rem;
                background: rgba(40, 167, 69, 0.8);
                color: white;
                border: 2px solid rgba(40, 167, 69, 1);
                border-radius: 5px;
                font-size: 1rem;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                text-transform: uppercase;
                box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            }
            
            #auto-battle-btn:hover {
                background: rgba(40, 167, 69, 1);
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(40, 167, 69, 0.6);
            }
            
            #auto-battle-btn:active {
                transform: scale(0.98);
            }
            
            #auto-battle-btn.active {
                background: rgba(255, 193, 7, 0.9);
                border-color: rgba(255, 193, 7, 1);
                box-shadow: 0 4px 15px rgba(255, 193, 7, 0.5);
            }

            
            .party-slot {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 0.5rem;
                cursor: pointer;
                transition: all 0.2s;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 3px;
                border: 1px solid transparent;
            }
            
            .party-slot:hover {
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.5);
            }
            
            .party-slot img {
                width: 35px;
                height: 35px;
                flex-shrink: 0;
            }
            
            .party-slot span {
                font-size: 0.9rem;
                color: white;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            /* Enemy area - right side of arena */
            #enemy-area {
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                position: relative;
                width: 100%;
                height: 100%;
                overflow-y: auto;
                padding: 0.5rem;
                box-sizing: border-box;
            }
            
            #enemy-area h2 {
                margin: 0 0 0.5rem 0;
                text-align: center;
            }
            
            .enemy-health-bar {
                width: 100%;
                height: 1.5rem;
                margin-bottom: 1rem;
            }
            
            #enemies {
                position: relative;
                width: 100%;
                min-height: 150px;
                max-height: 200px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                flex-shrink: 0;
                overflow-y: auto;
                gap: 8px;
                padding: 8px 0;
            }
            
            #enemies img {
                position: absolute;
                max-width: 28%;
                max-height: 100%;
                object-fit: contain;
                transition: transform 0.3s ease, filter 0.3s ease;
                filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5));
            }
            
            #enemies img:nth-child(1) {
                left: 5%;
            }
            
            #enemies img:nth-child(2) {
                left: 36%;
                z-index: 10;
            }
            
            #enemies img:nth-child(3) {
                right: 5%;
            }
            
            #enemies img.hoverable:hover {
                transform: scale(1.15);
                filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
            }
            
            /* Player status effects display above head */
            #player-status-effects {
                text-align: center;
                color: #ffaa00;
                font-weight: bold;
            }
            
            #player-status-effects span {
                margin: 0 3px;
            }
            
            /* Turn order display */
            .turn-box {
                width: 50px;
                height: 50px;
                border-radius: 8px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                position: relative;
                transition: all 0.3s ease;
                border: 2px solid transparent;
            }
            
            .turn-box img {
                width: 35px;
                height: 35px;
                object-fit: contain;
            }
            
            .turn-box.player-turn {
                background: rgba(40, 167, 69, 0.3);
                border-color: rgba(40, 167, 69, 1);
                box-shadow: 0 0 15px rgba(40, 167, 69, 0.6);
            }
            
            .turn-box.enemy-turn {
                background: rgba(220, 53, 69, 0.3);
                border-color: rgba(220, 53, 69, 1);
                box-shadow: 0 0 15px rgba(220, 53, 69, 0.6);
            }
            
            .turn-box.active {
                transform: scale(1.15);
                border-width: 3px;
            }
            
            .turn-box.player-turn.active {
                box-shadow: 0 0 25px rgba(40, 167, 69, 1);
            }
            
            .turn-box.enemy-turn.active {
                box-shadow: 0 0 25px rgba(220, 53, 69, 1);
            }
            
            .turn-box .enemy-number {
                position: absolute;
                bottom: -2px;
                right: -2px;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                font-size: 10px;
                font-weight: bold;
                padding: 2px 4px;
                border-radius: 3px;
                min-width: 14px;
                text-align: center;
            }
            
            .turn-box .player-number {
                position: absolute;
                bottom: -2px;
                right: -2px;
                background: rgba(0, 120, 255, 0.9);
                color: white;
                font-size: 12px;
                font-weight: bold;
                padding: 2px 5px;
                border-radius: 3px;
                min-width: 16px;
                text-align: center;
            }
            
            /* Enemy tooltip */
            .enemy-tooltip {
                position: fixed;
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid rgba(255, 215, 0, 0.8);
                border-radius: 8px;
                padding: 12px 16px;
                color: white;
                font-size: 14px;
                z-index: 10000;
                pointer-events: none;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
                max-width: 300px;
                display: none;
            }
            
            .enemy-tooltip.active {
                display: block;
            }
            
            .enemy-tooltip h4 {
                margin: 0 0 8px 0;
                color: #ffd700;
                font-size: 16px;
                border-bottom: 1px solid rgba(255, 215, 0, 0.5);
                padding-bottom: 4px;
            }
            
            .enemy-tooltip .stat-row {
                margin: 4px 0;
                display: flex;
                justify-content: space-between;
            }
            
            .enemy-tooltip .special-effect {
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid rgba(255, 215, 0, 0.3);
                color: #ffaa00;
                font-style: italic;
            }
            
            @media (max-width: 768px) {
                .enemy-tooltip {
                    max-width: 250px;
                    font-size: 12px;
                }
            }
            
            /* Player area - left side of arena */
            #player-area {
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
                padding: 0.5rem;
                box-sizing: border-box;
            }
            
            .player-bars {
                width: 100%;
                margin-bottom: 0.5rem;
                flex-shrink: 0;
            }
            
            .health-bar, .mana-bar {
                width: 100%;
                height: 1.5rem;
                margin-bottom: 0.5rem;
                border-radius: 3px;
                overflow: hidden;
            }
            
            .health-bar div, .mana-bar div {
                height: 100%;
                transition: width 0.3s ease;
                color: black;
                font-weight: bold;
                text-shadow: 0 0 2px white;
            }
            
            #player {
                max-width: 100%;
                max-height: 150px;
                width: auto;
                height: auto;
                object-fit: contain;
                filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5));
                transition: transform 0.3s ease, filter 0.3s ease;
                flex-shrink: 1;
            }
            
            #player:hover {
                transform: scale(1.05);
            }
            
            /* Chill effect - blue overlay on chilled enemies and players */
            .chilled {
                filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5)) drop-shadow(0 0 15px rgba(100, 200, 255, 0.8)) brightness(0.9) sepia(0.3) hue-rotate(180deg) saturate(2) !important;
            }
            
            .chilled:hover {
                filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6)) drop-shadow(0 0 15px rgba(100, 200, 255, 0.8)) brightness(0.9) sepia(0.3) hue-rotate(180deg) saturate(2) !important;
            }
            
            /* Enemy spawn animation */
            @keyframes enemy-spawn {
                0% {
                    opacity: 0;
                    transform: scale(0.5) rotate(-10deg);
                }
                60% {
                    transform: scale(1.1) rotate(5deg);
                }
                100% {
                    opacity: 1;
                    transform: scale(1) rotate(0deg);
                }
            }
            
            .enemy-spawning {
                animation: enemy-spawn 0.6s ease-out;
            }
            
            /* Enemy death animation */
            @keyframes enemy-death {
                0% {
                    transform: scale(1) translateY(0) rotate(0deg);
                    opacity: 1;
                }
                20% {
                    transform: scale(1.05) translateY(-5px) rotate(-5deg);
                    filter: brightness(2) drop-shadow(0 0 20px red);
                }
                40% {
                    transform: scale(1.05) translateY(-5px) rotate(5deg);
                }
                100% {
                    transform: scale(0.3) translateY(30px) rotate(90deg);
                    opacity: 0;
                    filter: brightness(0.3);
                }
            }
            
            .enemy-dying {
                animation: enemy-death 0.8s ease-in forwards;
            }
            
            /* Healing effect overlay */
            @keyframes heal-flash {
                0%, 100% {
                    filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5));
                }
                50% {
                    filter: drop-shadow(0 0 20px rgba(0, 255, 100, 0.9)) brightness(1.3) saturate(1.5);
                }
            }
            
            .healing {
                animation: heal-flash 0.5s ease-in-out;
            }
            
            /* Turn indicator glow */
            @keyframes turn-glow {
                0%, 100% {
                    box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
                }
                50% {
                    box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4);
                }
            }
            
            .active-turn {
                border: 3px solid rgba(255, 215, 0, 0.9) !important;
                animation: turn-glow 2s ease-in-out infinite;
            }
            
            /* Status effect pop-in animation */
            @keyframes status-pop {
                0% {
                    transform: scale(0);
                    opacity: 0;
                }
                60% {
                    transform: scale(1.2);
                }
                100% {
                    transform: scale(1);
                    opacity: 1;
                }
            }
            
            .status-icon {
                display: inline-block;
                animation: status-pop 0.3s ease-out;
                margin: 0 2px;
            }
            
            /* Status effect expiring shake */
            @keyframes status-expire {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-3px); }
                75% { transform: translateX(3px); }
            }
            
            .status-expiring {
                animation: status-expire 0.3s ease-in-out;
            }
            
            /* Attacks area - bottom center */
            #Attacks {
                grid-column: 1 / -1;
                grid-row: 4;
                display: flex;
                flex-direction: row;
                gap: 0.4rem;
                min-height: 80px;
                max-height: 100px;
                overflow-x: auto;
                overflow-y: hidden;
                background: rgba(0, 0, 0, 0.5);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 5px;
                padding: 0.4rem;
                justify-content: flex-end;
            }
            
            .attack-slot {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.2rem;
                padding: 0.3rem;
                cursor: pointer;
                transition: all 0.2s;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 3px;
                border: 1px solid transparent;
                flex-shrink: 0;
                min-width: 70px;
                position: relative;
            }
            
            .attack-slot:hover {
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.5);
                transform: scale(1.05);
            }
            
            .attack-slot.on-cooldown {
                opacity: 0.4;
                filter: grayscale(100%);
                cursor: not-allowed;
                border-color: rgba(255, 0, 0, 0.3);
            }
            
            .attack-slot.on-cooldown:hover {
                transform: none;
                border-color: rgba(255, 0, 0, 0.3);
            }
            
            .attack-slot.no-ammo {
                opacity: 0.5;
                filter: grayscale(80%);
                cursor: not-allowed;
                border-color: rgba(102, 51, 0, 0.5);
            }
            
            .attack-slot.no-ammo:hover {
                transform: none;
                border-color: rgba(102, 51, 0, 0.5);
            }
            
            .attack-slot.no-mana {
                opacity: 0.5;
                filter: grayscale(70%);
                cursor: not-allowed;
                border-color: rgba(0, 51, 102, 0.5);
            }
            
            .attack-slot.no-mana:hover {
                transform: none;
                border-color: rgba(0, 51, 102, 0.5);
            }
            
            .attack-slot .cooldown-overlay {
                position: absolute;
                top: 2px;
                right: 2px;
                background: rgba(255, 0, 0, 0.9);
                color: white;
                padding: 2px 6px;
                border-radius: 8px;
                font-size: 0.7em;
                font-weight: bold;
                min-width: 18px;
                text-align: center;
            }
            
            .attack-slot img {
                width: 35px;
                height: 35px;
            }
            
            .attack-slot span {
                font-size: 0.8rem;
                color: white;
                text-align: center;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 70px;
            }
            
            /* Attack tooltip */
            .attack-tooltip {
                position: fixed;
                background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(40, 40, 60, 0.98));
                border: 2px solid rgba(255, 215, 0, 0.6);
                border-radius: 8px;
                padding: 12px;
                color: white;
                font-size: 0.9rem;
                pointer-events: none;
                z-index: 10000;
                max-width: 280px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(5px);
                display: none;
            }
            
            .attack-tooltip.visible {
                display: block;
            }
            
            .attack-tooltip .tooltip-header {
                font-weight: bold;
                font-size: 1.1rem;
                color: #FFD700;
                margin-bottom: 8px;
                border-bottom: 1px solid rgba(255, 215, 0, 0.3);
                padding-bottom: 4px;
            }
            
            .attack-tooltip .tooltip-damage {
                color: #FF6B6B;
                margin: 4px 0;
            }
            
            .attack-tooltip .tooltip-status {
                color: #51CF66;
                margin: 4px 0;
            }
            
            .attack-tooltip .tooltip-special {
                color: #74C0FC;
                margin: 4px 0;
                font-style: italic;
            }
            
            .attack-tooltip .tooltip-ability {
                color: #FFA94D;
                margin: 4px 0;
                font-size: 0.85rem;
            }
            
            /* Responsive adjustments */
            @media (max-width: 1200px) {
                #battle-container {
                    grid-template-columns: 1fr;
                    grid-template-rows: auto auto auto 1fr auto;
                    gap: 0.5rem;
                    padding: 0.5rem;
                }
                
                .arena {
                    grid-template-columns: 1fr;
                    grid-row: 3;
                    padding: 1rem;
                    gap: 1rem;
                }
                
                #party {
                    grid-column: 1;
                    grid-row: 1;
                    flex-direction: row;
                    max-height: auto;
                    max-width: 100%;
                }
                
                #player-stats-display {
                    grid-row: 2;
                }
                
                #Attacks {
                    grid-column: 1;
                    grid-row: 4;
                }
                
                #enemies {
                    min-height: 200px;
                    max-height: 250px;
                }
                
                #player {
                    max-height: 200px;
                }
            }
            
            @media (max-width: 768px) {
                body#battle {
                    padding: 0;
                    height: auto;
                    min-height: 100vh;
                }
                
                #battle-container {
                    gap: 0.3rem;
                    padding: 0.3rem;
                    grid-template-rows: auto auto auto 1fr auto;
                    max-height: none;
                    height: auto;
                    min-height: 100vh;
                }
                
                .arena {
                    grid-template-columns: 1fr;
                    grid-row: 3;
                    padding: 0.5rem;
                    gap: 0.5rem;
                }
                
                #party {
                    flex-direction: row;
                    gap: 0.3rem;
                    max-width: 100%;
                    grid-row: 1;
                }
                
                .party-slot span {
                    display: none;
                }
                
                #player-stats-display {
                    grid-row: 2;
                    flex-wrap: wrap;
                    padding: 0.3rem 0.5rem;
                    font-size: 0.8rem;
                }
                
                #player-stats-display .stat-item {
                    min-width: 60px;
                }
                
                #Attacks {
                    gap: 0.4rem;
                    padding: 0.5rem;
                    grid-row: 4;
                    position: relative;
                    z-index: 1;
                    min-height: 90px;
                    max-height: 120px;
                }
                
                .attack-slot {
                    min-width: 65px;
                    padding: 0.4rem;
                }
                
                .attack-slot img {
                    width: 40px;
                    height: 40px;
                }
                
                .attack-slot span {
                    display: none;
                }
                
                #enemies {
                    min-height: 150px;
                    max-height: 200px;
                }
                
                #player {
                    max-height: 120px;
                }
                
                #player-area {
                    padding: 0.3rem;
                }
            }
            
            /* Damage popup animations */
            .damage-popup {
                position: absolute;
                font-size: 32px;
                font-weight: bold;
                color: #ff4444;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -1px -1px 2px rgba(255,255,255,0.3);
                pointer-events: none;
                z-index: 10000;
                animation: damage-float 1.8s ease-out forwards;
            }
            
            .damage-popup.heal {
                color: #44ff44;
            }
            
            .damage-popup.critical {
                color: #ffaa00;
                font-size: 42px;
            }
            
            .damage-popup.burn {
                color: #ff8800;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(255,136,0,0.6);
            }
            
            .damage-popup.grim {
                color: #222222;
                text-shadow: 2px 2px 4px rgba(255,255,255,0.5), 0 0 8px rgba(128,0,128,0.6);
            }
            
            .damage-popup.leech {
                color: #2d6b2d;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 8px rgba(0,255,0,0.4);
            }
            
            .damage-popup.bleed {
                color: #cc0000;
            }
            
            .damage-popup.chill {
                color: #88ccff;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(136,204,255,0.6);
            }
            
            @keyframes damage-float {
                0% {
                    opacity: 1;
                    transform: translateY(0) scale(0.8);
                }
                15% {
                    transform: translateY(-10px) scale(1.2);
                }
                30% {
                    transform: translateY(-25px) scale(1);
                }
                100% {
                    opacity: 0;
                    transform: translateY(-80px) scale(0.9);
                }
            }
        </style>
        <script>
            // Damage popup animation function
            function showDamagePopup(element, damage, type = 'damage') {
                const rect = element.getBoundingClientRect();
                const popup = document.createElement('div');
                popup.className = 'damage-popup';
                
                // Add type-specific class for coloring
                if (type === 'heal') {
                    popup.classList.add('heal');
                    popup.textContent = '+' + damage;
                } else if (type === 'critical') {
                    popup.classList.add('critical');
                    popup.textContent = damage + '!';
                } else if (type === 'burn' || type === 'grim' || type === 'leech' || type === 'bleed' || type === 'chill') {
                    popup.classList.add(type);
                    popup.textContent = damage;
                } else {
                    popup.textContent = damage;
                }
                
                // Position with larger random spread around the element
                const randomX = (Math.random() - 0.5) * 120; // Random offset -60 to +60px
                const randomY = (Math.random() - 0.5) * 80; // Random offset -40 to +40px
                popup.style.left = (rect.left + rect.width / 2 + randomX) + 'px';
                popup.style.top = (rect.top + rect.height / 2 + randomY) + 'px';
                
                document.body.appendChild(popup);
                
                // Remove after animation completes (increased to 1.8s)
                setTimeout(() => {
                    popup.remove();
                }, 1800);
            }
        </script>
    </head>
<body id="battle">
    <!--Battle arena with party sidebar, player, and enemies in a contained arena space-->
    <div id="battle-container">
        
        <!--Party sidebar - top left-->
        <div id="party" class="w3-blue-grey">
            <!--Party member 1-->
            <div id="slot-one" class="party-slot">
                <img src="Assests/player.png" alt="Player 1">
                <span>P1 lvl#</span>
            </div>
            <!--Party member 2, etc-->
            <div id="slot-two" class="party-slot">
                <img src="Assests/player.png" alt="Player 2">
                <span>P2 lvl#</span>
            </div>
            <div id="slot-three" class="party-slot">
                <img src="Assests/player.png" alt="Player 3">
                <span>P3 lvl#</span>
            </div>
            <div id="slot-four" class="party-slot">
                <img src="Assests/player.png" alt="Player 4">
                <span>P4 lvl#</span>
            </div>
            <div id="slot-five" class="party-slot">
                <img src="Assests/player.png" alt="Player 5">
                <span>P5 lvl#</span>
            </div>
        </div>
        
        <!--Leave Battle Button - top right-->
        <div style="grid-column:2;grid-row:1;display:flex;gap:8px;justify-content:flex-end;align-items:center;">
            <button id="leave-battle-btn" onclick="leaveBattle()">Leave Battle</button>
            <button id="start-combat-btn" onclick="startCombat()" style="background:rgba(40,167,69,0.85);color:white;border:2px solid rgba(40,167,69,1);padding:0.5rem 1rem;border-radius:5px;cursor:pointer;">Start Combat</button>
        </div>
        
        <!--Right Sidebar - Turn Order and Actions-->
        <div id="right-sidebar">
            <!--Turn Order Queue Display-->
            <div id="turn-order-display" style="padding:0.5rem;background:rgba(0,0,0,0.3);border-radius:8px;border:1px solid rgba(255,255,255,0.1);">
                <h3 style="margin:0 0 0.5rem 0;font-size:14px;text-align:center;color:#ffaa00;">Turn Order</h3>
                <div id="turn-order-queue" style="display:flex;gap:8px;justify-content:flex-start;align-items:center;overflow-x:auto;padding:4px;flex-wrap:wrap;">
                    <!-- Turn order boxes will be inserted here -->
                </div>
            </div>
            
            <!--Rest Button-->
            <div style="text-align:center;">
                <button id="rest-button" style="width:100%;padding:0.75rem 1rem;font-size:1em;font-weight:bold;background:linear-gradient(135deg,#4a90e2,#357abd);color:white;border:2px solid #2c5f8d;border-radius:8px;cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,0.3);transition:all 0.2s;" onmouseover="this.style.background='linear-gradient(135deg,#5aa0f2,#4080bd)';this.style.boxShadow='0 6px 12px rgba(0,0,0,0.4)';" onmouseout="this.style.background='linear-gradient(135deg,#4a90e2,#357abd)';this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';">
                    ðŸ’¤ Rest<br><span style="font-size:0.8em;">(Restore 60% Mana)</span>
                </button>
            </div>
            
            <!--Auto Battle Button-->
            <div style="text-align:center;margin-top:0.5rem;">
                <button id="auto-battle-btn" onclick="toggleAutoBattle()" style="width:100%;">Auto Battle: OFF</button>
            </div>
        </div>
        
        <!--Player Stats Display - Now shows both players-->
        <div id="player-stats-display">
            <div style="flex: 1; padding: 0.5rem; border-right: 2px solid rgba(255, 215, 0, 0.3);">
                <div style="text-align: center; color: #ffaa00; font-weight: bold; margin-bottom: 0.3rem;">Player 1</div>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <div class="stat-item">
                        <span class="stat-label">HP</span>
                        <span class="stat-value" id="stat-hp-p1">100/100</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">STR</span>
                        <span class="stat-value" id="stat-strength-p1">10</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">MAG</span>
                        <span class="stat-value" id="stat-magic-p1">10</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">SKL</span>
                        <span class="stat-value" id="stat-skill-p1">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ðŸŽ¯</span>
                        <span class="stat-value" id="stat-ammo-p1">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">SPD</span>
                        <span class="stat-value" id="stat-speed-p1">10</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">DEF</span>
                        <span class="stat-value" id="stat-defense-p1">5</span>
                    </div>
                </div>
            </div>
            <div style="flex: 1; padding: 0.5rem;">
                <div style="text-align: center; color: #ffaa00; font-weight: bold; margin-bottom: 0.3rem;">Player 2</div>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <div class="stat-item">
                        <span class="stat-label">HP</span>
                        <span class="stat-value" id="stat-hp-p2">100/100</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">STR</span>
                        <span class="stat-value" id="stat-strength-p2">10</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">MAG</span>
                        <span class="stat-value" id="stat-magic-p2">10</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">SKL</span>
                        <span class="stat-value" id="stat-skill-p2">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ðŸŽ¯</span>
                        <span class="stat-value" id="stat-ammo-p2">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">SPD</span>
                        <span class="stat-value" id="stat-speed-p2">10</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">DEF</span>
                        <span class="stat-value" id="stat-defense-p2">5</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!--Central Arena-->
        <div class="arena">
            <!--Player area - left side of arena - now shows 2 players-->
            <div id="player-area" style="display: flex; flex-direction: row; gap: 1rem; align-items: center; justify-content: space-around; width: 100%; height: 100%;">
                <!-- Player 1 -->
                <div id="player-1-wrapper" style="display: flex; flex-direction: column; align-items: center; flex: 1; position: relative; padding: 10px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 10px; background: rgba(0, 0, 0, 0.3); transition: all 0.3s ease;">
                    <!-- Status effects for Player 1 -->
                    <div id="player-1-status" style="position: absolute; top: -15px; left: 50%; transform: translateX(-50%); font-size: 20px; background: rgba(0, 0, 0, 0.9); padding: 3px 10px; border-radius: 8px; border: 2px solid rgba(255, 170, 0, 0.7); white-space: nowrap; z-index: 10;"></div>
                    
                    <div class="player-bars" style="width: 100%;">
                        <div class="health-bar w3-light-grey">
                            <div class="w3-green" id="p1-health-bar" style="width:50%; height:100%">HP #</div>
                        </div>
                        <div class="mana-bar w3-light-grey">
                            <div class="w3-blue" id="p1-mana-bar" style="width:50%; height:100%">mana #</div>
                        </div>
                    </div>
                    <img id="player-1" src="Assests/player.png" alt="Player 1" style="max-width: 80px;">
                    <div style="color: #ffaa00; font-weight: bold; font-size: 0.9em;">Player 1</div>
                </div>
                
                <!-- Player 2 -->
                <div id="player-2-wrapper" style="display: flex; flex-direction: column; align-items: center; flex: 1; position: relative; padding: 10px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 10px; background: rgba(0, 0, 0, 0.3); transition: all 0.3s ease;">
                    <!-- Status effects for Player 2 -->
                    <div id="player-2-status" style="position: absolute; top: -15px; left: 50%; transform: translateX(-50%); font-size: 20px; background: rgba(0, 0, 0, 0.9); padding: 3px 10px; border-radius: 8px; border: 2px solid rgba(255, 170, 0, 0.7); white-space: nowrap; z-index: 10;"></div>
                    
                    <div class="player-bars" style="width: 100%;">
                        <div class="health-bar w3-light-grey">
                            <div class="w3-green" id="p2-health-bar" style="width:50%; height:100%">HP #</div>
                        </div>
                        <div class="mana-bar w3-light-grey">
                            <div class="w3-blue" id="p2-mana-bar" style="width:50%; height:100%">mana #</div>
                        </div>
                    </div>
                    <img id="player-2" src="Assests/player.png" alt="Player 2" style="max-width: 80px;">
                    <div style="color: #ffaa00; font-weight: bold; font-size: 0.9em;">Player 2</div>
                </div>
            </div>
            
            <!--Enemy area - right side of arena-->
            <div id="enemy-area">
                
                <div id="enemies">
                    <img class="hoverable" src="Enemies/cursedKnight.png" alt="Enemy 1">
                    <img class="hoverable" src="Enemies/cursedKnight.png" alt="Enemy 2">
                    <img class="hoverable" src="Enemies/cursedKnight.png" alt="Enemy 3">
                </div>
            </div>
        </div>
        
        <!--Attacks area - bottom-->
        <div id="Attacks" class="w3-blue-grey">
            <!--Attack 1-->
            <div id="atk-one" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 1">
                <span>Attack 1</span>
            </div>
            <!--Attack 2, etc-->
            <div id="atk-two" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 2">
                <span>Attack 2</span>
            </div>
            <div id="atk-three" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 3">
                <span>Attack 3</span>
            </div>
            <div id="atk-four" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 4">
                <span>Attack 4</span>
            </div>
            <div id="atk-five" class="attack-slot">
                <img src="Items/demonSythe.png" alt="Attack 5">
                <span>Attack 5</span>
            </div>
        </div>
    </div>
    
    <!-- Attack tooltip for showing attack details on hover -->
    <div id="attack-tooltip" class="attack-tooltip"></div>
    
    <footer>
        Kaden Cruts - 2025
    </footer>

        <!-- Combat debug panel (visible during testing) -->
        <div id="combat-debug" style="position:fixed;left:8px;bottom:8px;max-width:320px;max-height:220px;overflow:auto;background:rgba(0,0,0,0.6);color:#fff;padding:8px;border-radius:6px;font-size:12px;z-index:9999;border:1px solid rgba(255,255,255,0.08);">
            <strong style="display:block;margin-bottom:6px">Combat Debug</strong>
        </div>
    
    <script>
        function leaveBattle() {
            // Navigate back to home page
            window.location.href = 'home.html';
        }
    </script>
        <!-- Core game script to access PARTY_STATS, INVENTORY, ENEMY_BASE_STATS, etc. -->
        <script src="script.js"></script>
        <!-- Item index tracking -->
        <script src="index.js"></script>
        <!-- Enemy index tracking -->
        <script src="enemy-index.js"></script>
        <!-- Enchantment inventory management -->
        <script src="inventory.js"></script>
        <script>
        // Attack cooldown tracking - {attackName_memberKey: turnsRemaining}
        let attackCooldowns = {};
        
        // Ammo generation tracking - {memberKey: attacksSinceAmmo}
        let ammoGenerationCounter = {};
        
        // Debug: Check what's available from script.js
        console.log('window.clearLevelAndUnlock:', typeof window.clearLevelAndUnlock);
        console.log('window object keys sample:', Object.keys(window).filter(k => k.includes('clear') || k.includes('Level')));
        
        // Battle page initialization: read session battleData, update UI
        (function(){
            // Check for challenge mode from URL
            const urlParams = new URLSearchParams(window.location.search);
            const mode = urlParams.get('mode');
            const challengeId = urlParams.get('id');
            
            // Read battleData from sessionStorage
            let battleData = {};
            
            // If challenge mode, load challenge data and set up battle
            if (mode === 'challenge' && challengeId) {
                try {
                    const challengeDataStr = localStorage.getItem('activeChallengeData');
                    if (challengeDataStr) {
                        const challengeData = JSON.parse(challengeDataStr);
                        
                        // Use the calculated level from challenge data (based on highest cleared dungeon level + 5)
                        const challengeLevel = challengeData.calculatedLevel || 6; // Default to 6 if not set
                        
                        // Convert enemy names to image paths
                        const enemyPaths = (challengeData.enemies || ['skull']).map(enemyName => {
                            // If already a path, use it; otherwise convert name to path
                            if (enemyName.includes('/') || enemyName.includes('.png')) {
                                return enemyName;
                            }
                            return `Enemies/${enemyName}.png`;
                        });
                        
                        // Parse modifiers from challenge description
                        const modifiers = {};
                        const modText = (challengeData.modifier || '').toLowerCase();
                        
                        // Defense modifiers
                        if (modText.includes('4x defense')) modifiers.defenseBoost = 4;
                        else if (modText.includes('3x defense')) modifiers.defenseBoost = 3;
                        else if (modText.includes('2x defense')) modifiers.defenseBoost = 2;
                        else if (modText.includes('+80% defense')) modifiers.defenseBoost = 1.8;
                        
                        // Speed modifiers
                        if (modText.includes('2.5x speed')) modifiers.speedBoost = 2.5;
                        else if (modText.includes('2x speed')) modifiers.speedBoost = 2;
                        else if (modText.includes('1.5x speed')) modifiers.speedBoost = 1.5;
                        else if (modText.includes('+100% speed')) modifiers.speedBoost = 2;
                        else if (modText.includes('+60% speed')) modifiers.speedBoost = 1.6;
                        else if (modText.includes('+50% speed')) modifiers.speedBoost = 1.5;
                        else if (modText.includes('+40% speed')) modifiers.speedBoost = 1.4;
                        else if (modText.includes('+30% speed')) modifiers.speedBoost = 1.3;
                        
                        // Health modifiers
                        if (modText.includes('4x health')) modifiers.healthBoost = 4;
                        else if (modText.includes('3x health')) modifiers.healthBoost = 3;
                        else if (modText.includes('2x health')) modifiers.healthBoost = 2;
                        else if (modText.includes('+80% health')) modifiers.healthBoost = 1.8;
                        else if (modText.includes('+50% health')) modifiers.healthBoost = 1.5;
                        
                        // Strength modifiers
                        if (modText.includes('2x strength')) modifiers.strengthBoost = 2;
                        else if (modText.includes('+50% strength')) modifiers.strengthBoost = 1.5;
                        
                        // Magic modifiers
                        if (modText.includes('2x magic')) modifiers.magicBoost = 2;
                        else if (modText.includes('+75% magic')) modifiers.magicBoost = 1.75;
                        
                        // Overall stat boosts
                        if (modText.includes('+100% stats')) modifiers.allStatsBoost = 2;
                        else if (modText.includes('+75% to all stats')) modifiers.allStatsBoost = 1.75;
                        else if (modText.includes('+60% stats')) modifiers.allStatsBoost = 1.6;
                        else if (modText.includes('+50% to all stats')) modifiers.allStatsBoost = 1.5;
                        else if (modText.includes('+40% to all stats')) modifiers.allStatsBoost = 1.4;
                        else if (modText.includes('+30% to all stats')) modifiers.allStatsBoost = 1.3;
                        
                        // Special modifiers
                        if (modText.includes('necromancer has 5x health') || modText.includes('necromancer has 6x')) modifiers.necromancerBoost = modText.includes('6x') ? 6 : 5;
                        if (modText.includes('lifesteal')) modifiers.lifesteal = 0.5;
                        if (modText.includes('burn damage increased by 100%')) modifiers.burnBoost = 2;
                        else if (modText.includes('burn damage increased by 50%')) modifiers.burnBoost = 1.5;
                        if (modText.includes('bleed damage increased by 75%')) modifiers.bleedBoost = 1.75;
                        if (modText.includes('30% crit chance')) modifiers.critChance = 0.3;
                        if (modText.includes('40% dodge')) modifiers.dodgeChance = 0.4;
                        else if (modText.includes('30% dodge')) modifiers.dodgeChance = 0.3;
                        if (modText.includes('attack twice per turn')) modifiers.doubleAttack = true;
                        if (modText.includes('regenerate 5%')) modifiers.regen = 0.05;
                        
                        // Set up battle data from challenge
                        battleData = {
                            level: challengeLevel,
                            enemies: enemyPaths,
                            isBossTile: false,
                            isChallenge: true,
                            challengeId: parseInt(challengeId),
                            challengeReward: challengeData.reward,
                            challengeModifiers: modifiers
                        };
                        
                        // Store in sessionStorage for consistency
                        sessionStorage.setItem('battleData', JSON.stringify(battleData));
                    }
                } catch(e) {
                    console.error('Failed to load challenge data:', e);
                }
            } else {
                // Normal/hard mode - read from sessionStorage
                try { battleData = JSON.parse(sessionStorage.getItem('battleData')||'{}'); } catch(e) { battleData = {}; }
            }
            
            const level = battleData.level || 1;
            const enemyImages = battleData.enemies && battleData.enemies.length ? battleData.enemies : ['Enemies/skull.png'];
            const isChallenge = battleData.isChallenge || false;
            const challengeModifiers = battleData.challengeModifiers || {};

            // Track active battle members (now supporting 2 players) and battle state
            let activeBattleMember = 'ONE'; // Player 1
            let activeBattleMember2 = 'TWO'; // Player 2
            let currentPlayerTurn = 1; // Tracks which player's turn it is (1 or 2)
            let battleEnemyStates = {}; // Store enemy HP across member switches
            const battleParticipants = new Set(); // Track members who participated this battle
            
            // Status effect tracking: each enemy/player has arrays of effects
            // Effect format: { type: 'burn'|'leech'|'bleed'|'grim', turnsLeft: N, stacks: N, sourceData: {} }
            let enemyStatusEffects = {}; // key = enemy index, value = array of effects
            let playerStatusEffects = {}; // key = member key, value = array of effects

            // Helper: get the current active member key
            function getActiveBattleMember() {
                return activeBattleMember;
            }

            // Helper: switch to a different party member during battle
            function switchBattleMember(memberKey, isEmergencySwitch = false) {
                if (!PARTY_STATS || !PARTY_STATS[memberKey]) return false;
                const member = PARTY_STATS[memberKey];
                
                // Only allow switching during player's turn to prevent bugs (unless it's an emergency switch due to KO)
                if (!isEmergencySwitch && (!playerCanAct || !playerWaiting)) {
                    logCombat("You can only switch party members during your turn!");
                    return false;
                }
                
                // Skip if member is dead
                if (Number(member.HEALTH) <= 0) {
                    logCombat(`${member.NAME} is still KO'd and cannot be switched to.`);
                    return false;
                }
                
                // For emergency switches, determine which player died and replace them
                if (isEmergencySwitch) {
                    const member1 = PARTY_STATS[activeBattleMember];
                    const member2 = PARTY_STATS[activeBattleMember2];
                    
                    if (member1 && Number(member1.HEALTH) <= 0) {
                        // Player 1 died, replace them
                        if (memberKey === activeBattleMember2) {
                            logCombat("Cannot switch to Player 2's active member!");
                            return false;
                        }
                        activeBattleMember = memberKey;
                        logCombat(`Player 1 switched to ${member.NAME} (emergency)!`);
                    } else if (member2 && Number(member2.HEALTH) <= 0) {
                        // Player 2 died, replace them
                        if (memberKey === activeBattleMember) {
                            logCombat("Cannot switch to Player 1's active member!");
                            return false;
                        }
                        activeBattleMember2 = memberKey;
                        logCombat(`Player 2 switched to ${member.NAME} (emergency)!`);
                    } else {
                        logCombat("Emergency switch failed: no dead player found");
                        return false;
                    }
                } else {
                    // Normal switching during turn
                    if (currentPlayerTurn === 1) {
                        if (memberKey === activeBattleMember2) {
                            logCombat("Cannot switch to Player 2's active member!");
                            return false;
                        }
                        activeBattleMember = memberKey;
                        logCombat(`Player 1 switched to ${member.NAME}!`);
                    } else if (currentPlayerTurn === 2) {
                        if (memberKey === activeBattleMember) {
                            logCombat("Cannot switch to Player 1's active member!");
                            return false;
                        }
                        activeBattleMember2 = memberKey;
                        logCombat(`Player 2 switched to ${member.NAME}!`);
                    }
                }
                
                updatePlayerArea();
                renderAttacksForPlayer();
                enableAttackSelection();
                // Update queue to reflect new member's speed WITHOUT resetting queueIndex
                updateActionQueueForSwitch();
                // Highlight the selected party slot
                updatePartySlotHighlight();
                return true;
            }

            // Helper: highlight the active party member slot
            function updatePartySlotHighlight() {
                const slotIds = ['one', 'two', 'three', 'four', 'five'];
                slotIds.forEach((id, idx) => {
                    const slot = document.getElementById(`slot-${id}`);
                    if (slot) {
                        const key = ['ONE','TWO','THREE','FOUR','FIVE'][idx];
                        // Highlight both active players with different colors
                        if (key === activeBattleMember) {
                            slot.style.background = 'rgba(255, 215, 0, 0.3)';
                            slot.style.border = '2px solid rgba(255, 215, 0, 1)';
                        } else if (key === activeBattleMember2) {
                            slot.style.background = 'rgba(0, 191, 255, 0.3)';
                            slot.style.border = '2px solid rgba(0, 191, 255, 1)';
                        } else {
                            slot.style.background = 'rgba(255, 255, 255, 0.05)';
                            slot.style.border = '1px solid transparent';
                        }
                    }
                });
            }

            // Ensure game data loaded and stats are up-to-date
            if (typeof loadGameData === 'function') loadGameData();
            if (typeof updateStats === 'function') updateStats();
            // Initialize all party members for battle: ensure stats and full HP
            for (const key of ['ONE','TWO','THREE','FOUR','FIVE']) {
                const member = PARTY_STATS[key];
                if (!member) continue;
                // Ensure MAX_HEALTH is reasonable (avoid tiny base HP like 3 causing instant death)
                if (typeof member.MAX_HEALTH === 'undefined' || Number(member.MAX_HEALTH) < 20) {
                    member.MAX_HEALTH = Math.max(20, Number(member.MAX_HEALTH) || 20);
                }
                // Set full health for all party members at battle start
                member.HEALTH = Number(member.MAX_HEALTH);
                // Reset mana to full at battle start
                if (typeof member.MAX_MANA === 'undefined') member.MAX_MANA = 100;
                member.MANA = Number(member.MAX_MANA);
            }

            // Update party sidebar and player stats
            function updatePartyDisplay(){
                for (let i=1;i<=5;i++){
                    const key = ['ONE','TWO','THREE','FOUR','FIVE'][i-1];
                    const slot = document.getElementById(`slot-${['one','two','three','four','five'][i-1]}`);
                    if (!slot) continue;
                    const member = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[key]) ? PARTY_STATS[key] : null;
                    const span = slot.querySelector('span');
                    if (member){
                        span.textContent = `${member.NAME} lv${member.LEVEL||1}`;
                        // Add click handler for switching
                        slot.onclick = () => switchBattleMember(key);
                        slot.style.cursor = 'pointer';
                    } else {
                        span.textContent = `P${i} lv#`;
                        slot.onclick = null;
                        slot.style.cursor = 'default';
                    }
                }
                updatePlayerStatsDisplay();
                updatePartySlotHighlight(); // Highlight both active players
            }
            
            // Update player stats display at top - now shows both players
            function updatePlayerStatsDisplay(){
                // Player 1
                const member1 = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[activeBattleMember]) ? PARTY_STATS[activeBattleMember] : null;
                if (member1) {
                    const hpEl = document.getElementById('stat-hp-p1');
                    const strEl = document.getElementById('stat-strength-p1');
                    const magEl = document.getElementById('stat-magic-p1');
                    const sklEl = document.getElementById('stat-skill-p1');
                    const ammoEl = document.getElementById('stat-ammo-p1');
                    const spdEl = document.getElementById('stat-speed-p1');
                    const defEl = document.getElementById('stat-defense-p1');
                    
                    if (hpEl) {
                        const cur = Number(member1.HEALTH || 0);
                        const max = Number(member1.MAX_HEALTH || 1);
                        hpEl.textContent = `${cur}/${max}`;
                    }
                    if (strEl) strEl.textContent = Number(member1.STRENGTH || 0);
                    if (magEl) magEl.textContent = Number(member1.MAGIC || 0);
                    if (sklEl) sklEl.textContent = Number(member1.SKILL || 0);
                    if (ammoEl) ammoEl.textContent = Number(member1.AMMO || 0);
                    if (spdEl) spdEl.textContent = Number(member1.SPEED || 0);
                    if (defEl) defEl.textContent = Number(member1.DEFENSE || 0);
                }
                
                // Player 2
                const member2 = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[activeBattleMember2]) ? PARTY_STATS[activeBattleMember2] : null;
                if (member2) {
                    const hpEl = document.getElementById('stat-hp-p2');
                    const strEl = document.getElementById('stat-strength-p2');
                    const magEl = document.getElementById('stat-magic-p2');
                    const sklEl = document.getElementById('stat-skill-p2');
                    const ammoEl = document.getElementById('stat-ammo-p2');
                    const spdEl = document.getElementById('stat-speed-p2');
                    const defEl = document.getElementById('stat-defense-p2');
                    
                    if (hpEl) {
                        const cur = Number(member2.HEALTH || 0);
                        const max = Number(member2.MAX_HEALTH || 1);
                        hpEl.textContent = `${cur}/${max}`;
                    }
                    if (strEl) strEl.textContent = Number(member2.STRENGTH || 0);
                    if (magEl) magEl.textContent = Number(member2.MAGIC || 0);
                    if (sklEl) sklEl.textContent = Number(member2.SKILL || 0);
                    if (ammoEl) ammoEl.textContent = Number(member2.AMMO || 0);
                    if (spdEl) spdEl.textContent = Number(member2.SPEED || 0);
                    if (defEl) defEl.textContent = Number(member2.DEFENSE || 0);
                }
            }

            // Main player area uses active battle member
            function updatePlayerArea(){
                // Update both players
                const member1 = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[activeBattleMember]) ? PARTY_STATS[activeBattleMember] : null;
                const member2 = (typeof PARTY_STATS !== 'undefined' && PARTY_STATS[activeBattleMember2]) ? PARTY_STATS[activeBattleMember2] : null;
                
                // Player 1
                if (member1) {
                    if (typeof member1.MAX_MANA === 'undefined') member1.MAX_MANA = 100;
                    if (typeof member1.MANA === 'undefined') member1.MANA = member1.MAX_MANA;
                    if (typeof member1.MAX_HEALTH === 'undefined') member1.MAX_HEALTH = 10;
                    if (typeof member1.HEALTH === 'undefined') member1.HEALTH = Number(member1.MAX_HEALTH);

                    const healthBar1 = document.getElementById('p1-health-bar');
                    const manaBar1 = document.getElementById('p1-mana-bar');
                    if (healthBar1) {
                        const cur = Number(member1.HEALTH || 0);
                        const max = Number(member1.MAX_HEALTH || 1);
                        const safeMax = max > 0 ? max : 1;
                        let pct = Math.round((cur / safeMax) * 100);
                        if (pct > 100) pct = 100;
                        if (pct < 0) pct = 0;
                        healthBar1.style.width = pct + '%';
                        healthBar1.textContent = `HP ${cur}/${safeMax}`;
                    }
                    if (manaBar1) {
                        const curM = Number(member1.MANA || 0);
                        const maxM = Number(member1.MAX_MANA || 100);
                        const safeMaxM = maxM > 0 ? maxM : 100;
                        let mpct = Math.round((curM / safeMaxM) * 100);
                        if (mpct > 100) mpct = 100;
                        if (mpct < 0) mpct = 0;
                        manaBar1.style.width = mpct + '%';
                        manaBar1.textContent = `MP ${curM}/${safeMaxM}`;
                    }
                }
                
                // Player 2
                if (member2) {
                    if (typeof member2.MAX_MANA === 'undefined') member2.MAX_MANA = 100;
                    if (typeof member2.MANA === 'undefined') member2.MANA = member2.MAX_MANA;
                    if (typeof member2.MAX_HEALTH === 'undefined') member2.MAX_HEALTH = 10;
                    if (typeof member2.HEALTH === 'undefined') member2.HEALTH = Number(member2.MAX_HEALTH);

                    const healthBar2 = document.getElementById('p2-health-bar');
                    const manaBar2 = document.getElementById('p2-mana-bar');
                    if (healthBar2) {
                        const cur = Number(member2.HEALTH || 0);
                        const max = Number(member2.MAX_HEALTH || 1);
                        const safeMax = max > 0 ? max : 1;
                        let pct = Math.round((cur / safeMax) * 100);
                        if (pct > 100) pct = 100;
                        if (pct < 0) pct = 0;
                        healthBar2.style.width = pct + '%';
                        healthBar2.textContent = `HP ${cur}/${safeMax}`;
                    }
                    if (manaBar2) {
                        const curM = Number(member2.MANA || 0);
                        const maxM = Number(member2.MAX_MANA || 100);
                        const safeMaxM = maxM > 0 ? maxM : 100;
                        let mpct = Math.round((curM / safeMaxM) * 100);
                        if (mpct > 100) mpct = 100;
                        if (mpct < 0) mpct = 0;
                        manaBar2.style.width = mpct + '%';
                        manaBar2.textContent = `MP ${curM}/${safeMaxM}`;
                    }
                }
                        
                // Update stats display at top
                updatePlayerStatsDisplay();
                        
                // Update status effect display
                updateStatusEffectDisplay();
            }

            // Helper to map image filename to enemy key
            function enemyKeyFromImage(path){
                if (!path) return null;
                const name = path.split('/').pop().split('.')[0];
                // Try to find matching key in ENEMY_BASE_STATS
                for (const k in ENEMY_BASE_STATS) if (k.toLowerCase() === name.toLowerCase()) return k;
                return name;
            }
            
            // Helper function to get all equipped item abilities for a party member
            function getEquippedAbilities(memberKey) {
                const member = PARTY_STATS[memberKey];
                if (!member) return [];
                
                const abilities = [];
                const slots = ['HELMET', 'CHEST', 'LEGS', 'BOOTS', 'MAINHAND', 'OFFHAND'];
                
                for (const slot of slots) {
                    const itemName = member[slot];
                    if (!itemName) continue;
                    
                    // Look up the item from INVENTORY (equipped items) or ITEM_TABLE
                    let itemData = null;
                    if (typeof INVENTORY !== 'undefined') {
                        itemData = INVENTORY.find(i => i.name === itemName && i.equipped);
                    }
                    if (!itemData && typeof ITEM_TABLE !== 'undefined') {
                        itemData = ITEM_TABLE[itemName];
                    }
                    
                    if (itemData && itemData.ability && itemData.ability > 0) {
                        abilities.push(itemData.ability);
                    }
                }
                
                return abilities;
            }

            // Function to spawn a new enemy during battle
            function spawnEnemy(enemyKey, enemyLevel) {
                const enemiesDiv = document.getElementById('enemies');
                if (!enemiesDiv) return;
                
                const base = ENEMY_BASE_STATS[enemyKey] || { health:20, strength:3, magic:0, speed:2, defense:0, hBars:1 };
                const scaled = Object.assign({}, base);
                
                // Scale stats for the given level
                const scaleMultiplier = Math.pow(enemyLevel, 0.9);
                scaled.health = Math.max(1, Math.round(base.health * scaleMultiplier));
                scaled.strength = Math.round(base.strength * scaleMultiplier);
                scaled.magic = Math.round(base.magic * scaleMultiplier);
                scaled.speed = Math.round(base.speed * scaleMultiplier);
                scaled.defense = Math.round((base.defense || 0) * scaleMultiplier);
                
                // Create enemy wrapper
                const wrap = document.createElement('div');
                wrap.className = 'enemy-single';
                wrap.style.width = '100%';
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.alignItems = 'center';
                wrap.style.marginBottom = '8px';
                
                const nameH = document.createElement('h3');
                nameH.className = 'w3-text-white';
                nameH.textContent = (enemyKey || 'Enemy') + ` (Lv ${enemyLevel})`;
                
                const barWrap = document.createElement('div');
                barWrap.className = 'enemy-health-bar w3-light-grey';
                barWrap.style.width = '80%';
                barWrap.style.height = '12px';
                barWrap.style.marginBottom = '4px';
                const inner = document.createElement('div');
                inner.className = 'w3-green';
                inner.style.width = '100%';
                inner.style.height = '100%';
                inner.textContent = `HP ${scaled.health}`;
                barWrap.appendChild(inner);
                
                // Add mana bar for enemy
                const manaBarWrap = document.createElement('div');
                manaBarWrap.className = 'enemy-mana-bar w3-light-grey';
                manaBarWrap.style.width = '80%';
                manaBarWrap.style.height = '10px';
                manaBarWrap.style.marginBottom = '6px';
                const manaInner = document.createElement('div');
                manaInner.className = 'w3-blue';
                manaInner.style.width = '100%';
                manaInner.style.height = '100%';
                manaInner.style.fontSize = '0.7em';
                const enemyManaDisplay = 50 + (scaled.magic * 10);
                manaInner.textContent = `MP ${enemyManaDisplay}`;
                manaBarWrap.appendChild(manaInner);
                
                const img = document.createElement('img');
                img.src = base.image || `Enemies/${enemyKey}.png`;
                img.alt = enemyKey;
                img.style.maxWidth = '28%';
                img.style.objectFit = 'contain';
                img.className = 'hoverable';
                
                wrap.appendChild(nameH);
                wrap.appendChild(barWrap);
                wrap.appendChild(manaBarWrap);
                wrap.appendChild(img);
                
                // Calculate enemy mana - base 50, +10 per magic stat
                const enemyMana = 50 + (scaled.magic * 10);
                // All enemy attacks cost 10 mana
                const enemyManaCost = 10;
                
                // Ability 28: Gravity Well - Reduce all enemy speed by 30% at battle start
                const player1Abilities = getEquippedAbilities(activeBattleMember);
                const player2Abilities = getEquippedAbilities(activeBattleMember2);
                const hasGravityWell = player1Abilities.includes(28) || player2Abilities.includes(28);
                if (hasGravityWell) {
                    scaled.speed = Math.round(scaled.speed * 0.7); // 30% reduction
                    wrap.dataset.speed = scaled.speed;
                    if (idx === 0) { // Log only once
                        logCombat(`ðŸŒ€ Gravity Well: All enemy speed reduced by 30%!`);
                    }
                }
                
                // Store stats
                wrap.dataset.hp = scaled.health;
                wrap.dataset.maxHp = scaled.health;
                wrap.dataset.str = scaled.strength;
                wrap.dataset.speed = scaled.speed;
                wrap.dataset.mag = scaled.magic;
                wrap.dataset.def = scaled.defense;
                wrap.dataset.key = enemyKey;
                wrap.dataset.level = enemyLevel; // Store the level
                wrap.dataset.transformed = 'false';
                wrap.dataset.mana = enemyMana;
                wrap.dataset.maxMana = enemyMana;
                wrap.dataset.manaCost = enemyManaCost;
                
                // Add hover tooltip functionality
                let tooltip = document.getElementById('enemy-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'enemy-tooltip';
                    tooltip.className = 'enemy-tooltip';
                    document.body.appendChild(tooltip);
                }
                
                const showTooltip = (e) => {
                    const isMobile = window.innerWidth <= 768;
                    const rect = wrap.getBoundingClientRect();
                    
                    const currentHp = Number(wrap.dataset.hp) || 0;
                    const currentMaxHp = Number(wrap.dataset.maxHp) || 1;
                    const currentStr = Number(wrap.dataset.str) || 0;
                    const currentMag = Number(wrap.dataset.mag) || 0;
                    const currentSpeed = Number(wrap.dataset.speed) || 0;
                    const currentDef = Number(wrap.dataset.def) || 0;
                    const specialEffect = base.specialEffect || 'No special effect';
                    
                    // Calculate damage preview if an attack is selected
                    let damagePreview = '';
                    if (selectedAttackId) {
                        const memberKey = (typeof currentPlayerTurn !== 'undefined' && currentPlayerTurn === 2) ? activeBattleMember2 : activeBattleMember;
                        const attacker = PARTY_STATS[memberKey];
                        const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                        const selectedAttack = attacks.find(a => a.id === selectedAttackId);
                        
                        if (selectedAttack && attacker) {
                            const carriedMult = getCarriedMultiplier(memberKey);
                            let str = Number(attacker.STRENGTH||0) * carriedMult;
                            let mag = Number(attacker.MAGIC||0) * carriedMult;
                            const skill = Number(attacker.SKILL || 0);
                            
                            const strMult = Number(selectedAttack.strMultiplier||0);
                            const magMult = Number(selectedAttack.magicMultiplier||0);
                            const sklMult = Number(selectedAttack.sklMultiplier||0);
                            
                            // Calculate base damage
                            let baseDmg;
                            if (sklMult > 0) {
                                const flatDamage = (str * strMult + mag * magMult);
                                const skillMultiplier = (1 + skill * sklMult);
                                baseDmg = flatDamage * skillMultiplier;
                            } else {
                                baseDmg = (mag * magMult + str * strMult);
                            }
                            
                            // Apply defense reduction
                            const defenseMultiplier = Math.max(0.5, 1.0 - (Math.log10(currentDef + 1) * 0.05));
                            const damageReduction = currentDef * defenseMultiplier;
                            const damageAfterDefense = baseDmg - damageReduction;
                            const minimumDamage = Math.ceil(baseDmg * 0.1);
                            let estimatedDmg = Math.max(minimumDamage, Math.round(damageAfterDefense));
                            
                            // Account for crit chance on skill attacks
                            const isSkillAttack = sklMult > 0;
                            if (isSkillAttack) {
                                const baseCritChance = 0.05;
                                const skillCritBonus = skill * 0.003;
                                const totalCritChance = baseCritChance + skillCritBonus;
                                const critMultiplier = 1.5;
                                const avgDmg = Math.round(estimatedDmg * (1 - totalCritChance) + (estimatedDmg * critMultiplier * totalCritChance));
                                damagePreview = `<div class="stat-row" style="color: #ffaa00; font-weight: bold;"><span>ðŸ’¥ Estimated Damage:</span><span>${estimatedDmg} (${Math.round(totalCritChance * 100)}% crit â†’ avg ${avgDmg})</span></div>`;
                            } else {
                                damagePreview = `<div class="stat-row" style="color: #ffaa00; font-weight: bold;"><span>ðŸ’¥ Estimated Damage:</span><span>${estimatedDmg}</span></div>`;
                            }
                        }
                    }
                    
                    tooltip.innerHTML = `
                        <h4>${enemyKey} (Level ${enemyLevel})</h4>
                        <div class="stat-row"><span>Health:</span><span>${currentHp}/${currentMaxHp}</span></div>
                        <div class="stat-row"><span>Strength:</span><span>${currentStr}</span></div>
                        <div class="stat-row"><span>Magic:</span><span>${currentMag}</span></div>
                        <div class="stat-row"><span>Speed:</span><span>${currentSpeed}</span></div>
                        <div class="stat-row"><span>Defense:</span><span>${currentDef}</span></div>
                        ${damagePreview}
                        ${specialEffect !== 'No special effect' ? `<div class="special-effect">${specialEffect}</div>` : ''}
                    `;
                    
                    tooltip.classList.add('active');
                    
                    if (isMobile) {
                        tooltip.style.left = Math.max(10, rect.left) + 'px';
                        tooltip.style.top = (rect.bottom + 10) + 'px';
                    } else {
                        tooltip.style.left = (rect.right + 15) + 'px';
                        tooltip.style.top = rect.top + 'px';
                    }
                };
                
                const hideTooltip = () => {
                    tooltip.classList.remove('active');
                };
                
                wrap.addEventListener('mouseenter', showTooltip);
                wrap.addEventListener('mouseleave', hideTooltip);
                wrap.addEventListener('mousemove', showTooltip);
                
                // Make clickable for targeting
                wrap.style.cursor = 'pointer';
                wrap.onclick = () => {
                    getEnemyWrappers().forEach(w=>w.style.outline='');
                    wrap.style.outline = '3px solid red';
                    selectedTarget = wrap;
                    logCombat(`Selected target: ${enemyKey}`);
                    
                    // Check if player can attack
                    const memberKey = getActiveBattleMember();
                    const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                    const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                    const finalList = (attacks.filter(a=>equipped.has(a.id)).concat(attacks.filter(a=>!equipped.has(a.id)))).slice(0,5);
                    const hasAttacks = finalList.length > 0;
                    
                    if (playerCanAct && typeof window.playerPerformAttackOn === 'function') {
                        if (!hasAttacks || (hasAttacks && selectedAttackId)) {
                            window.playerPerformAttackOn(wrap);
                        } else {
                            logCombat('Select an attack first!');
                        }
                    }
                };
                
                // Add to enemies container
                enemiesDiv.appendChild(wrap);
                
                // Add spawn animation
                const enemyImg = wrap.querySelector('img');
                if (enemyImg) {
                    enemyImg.classList.add('enemy-spawning');
                    setTimeout(() => {
                        enemyImg.classList.remove('enemy-spawning');
                    }, 600);
                }
                
                // Register encounter
                if (typeof registerEnemyEncountered === 'function') {
                    registerEnemyEncountered(enemyKey);
                }
                
                // Insert new enemy's turns into the action queue WITHOUT recalculating (to preserve already-taken turns)
                const savedIndex = queueIndex;
                const allEnemiesAfterSpawn = getEnemyWrappers();
                const newEnemyIndex = allEnemiesAfterSpawn.length - 1; // The newly spawned enemy is at the end
                
                // Calculate how many turns this new enemy should get based on its speed
                const baseSpeed = Math.max(1, Number(wrap.dataset.speed) || 1);
                const effectiveSpeed = getEffectiveSpeed('enemy', newEnemyIndex, baseSpeed);
                
                // Find GCD of current queue to determine turn ratio
                const member1 = PARTY_STATS[activeBattleMember];
                const member2 = PARTY_STATS[activeBattleMember2];
                if (member1 && member2) {
                    const pSpeed1 = getEffectiveSpeed('player', activeBattleMember, Math.max(1, Number(member1.SPEED) || 1));
                    const pSpeed2 = getEffectiveSpeed('player', activeBattleMember2, Math.max(1, Number(member2.SPEED) || 1));
                    
                    // Calculate a rough estimate of how many actions to insert
                    const avgPlayerSpeed = (pSpeed1 + pSpeed2) / 2;
                    const turnsToAdd = Math.max(1, Math.round(effectiveSpeed / avgPlayerSpeed * 2)); // Proportional to player speeds
                    
                    // Insert new enemy actions evenly into remaining queue
                    const remainingQueueLength = actionQueue.length - savedIndex;
                    const insertInterval = Math.max(1, Math.floor(remainingQueueLength / (turnsToAdd + 1)));
                    
                    for (let i = 0; i < turnsToAdd; i++) {
                        const insertPos = Math.min(actionQueue.length, savedIndex + (i + 1) * insertInterval);
                        actionQueue.splice(insertPos, 0, { type: 'e', index: newEnemyIndex });
                    }
                    
                    logCombat(`Queue updated: Added ${turnsToAdd} turns for new enemy at index ${newEnemyIndex} (position preserved: ${savedIndex}/${actionQueue.length})`);
                }
            }
            
            function renderEnemies(){
                const enemyArea = document.getElementById('enemy-area');
                const enemiesDiv = document.getElementById('enemies');
                if (!enemyArea || !enemiesDiv) return;
                // Clear existing enemy health bars (we'll create per-enemy bars above enemiesDiv)
                const existingBars = enemyArea.querySelectorAll('.enemy-single');
                existingBars.forEach(n=>n.remove());
                enemiesDiv.innerHTML = '';

                enemyImages.forEach((imgPath, idx) => {
                    const key = enemyKeyFromImage(imgPath) || imgPath;
                    
                    // Register enemy encounter for index tracking
                    if (typeof registerEnemyEncountered === 'function') {
                        registerEnemyEncountered(key);
                    }
                    
                    const base = ENEMY_BASE_STATS[key] || { health:20, strength:3, magic:0, speed:2, defense:0, hBars:1 };
                    const scaled = Object.assign({}, base);
                    
                    // Determine if this is a boss-tier enemy (tier 5 or 6)
                    const isBossEnemy = base.tier >= 5;
                    const isBossTile = battleData.isBossTile || false;
                    
                    // Use exponential scaling: level^0.9 (slightly faster than player/item scaling of level^0.8)
                    let baseScale = Math.pow(level, 0.9);
                    
                    // Apply different scaling based on boss tile vs regular tile
                    let scaleMultiplier = baseScale;
                    if (isBossEnemy) {
                        if (isBossTile) {
                            // Boss on boss tile: buffed (extra 30% stats)
                            scaleMultiplier = baseScale * 1.3;
                        } else {
                            // Boss on regular tile: weaker (70% stats)
                            scaleMultiplier = baseScale * 0.7;
                        }
                    }
                    
                    // Scale health and stats
                    scaled.health = Math.max(1, Math.round(base.health * scaleMultiplier));
                    scaled.strength = Math.round(base.strength * scaleMultiplier);
                    scaled.magic = Math.round(base.magic * scaleMultiplier);
                    scaled.speed = Math.round(base.speed * scaleMultiplier);
                    scaled.defense = Math.round((base.defense || 0) * scaleMultiplier);
                    
                    // Apply challenge modifiers if in challenge mode
                    if (isChallenge) {
                        // Base 1.2x stat boost for all challenge enemies
                        scaled.health = Math.round(scaled.health * 1.2);
                        scaled.strength = Math.round(scaled.strength * 1.2);
                        scaled.magic = Math.round(scaled.magic * 1.2);
                        scaled.speed = Math.round(scaled.speed * 1.2);
                        scaled.defense = Math.round((scaled.defense || 0) * 1.2);
                        
                        // Additional challenge-specific modifiers
                        if (challengeModifiers) {
                            // Apply all stats boost first if present
                            if (challengeModifiers.allStatsBoost) {
                                scaled.health = Math.round(scaled.health * challengeModifiers.allStatsBoost);
                                scaled.strength = Math.round(scaled.strength * challengeModifiers.allStatsBoost);
                                scaled.magic = Math.round(scaled.magic * challengeModifiers.allStatsBoost);
                                scaled.speed = Math.round(scaled.speed * challengeModifiers.allStatsBoost);
                                scaled.defense = Math.round((scaled.defense || 0) * challengeModifiers.allStatsBoost);
                            }
                            
                            // Individual stat boosts (stack with allStatsBoost)
                            if (challengeModifiers.healthBoost) {
                                scaled.health = Math.round(scaled.health * challengeModifiers.healthBoost);
                            }
                            if (challengeModifiers.strengthBoost) {
                                scaled.strength = Math.round(scaled.strength * challengeModifiers.strengthBoost);
                            }
                            if (challengeModifiers.magicBoost) {
                                scaled.magic = Math.round(scaled.magic * challengeModifiers.magicBoost);
                            }
                            if (challengeModifiers.speedBoost) {
                                scaled.speed = Math.round(scaled.speed * challengeModifiers.speedBoost);
                            }
                            if (challengeModifiers.defenseBoost) {
                                scaled.defense = Math.round((scaled.defense || 0) * challengeModifiers.defenseBoost);
                            }
                        }
                        
                        // Vampiric Onslaught (challenge ID 2): Necromancer has massive health boost
                        if (battleData.challengeId === 2 && key.toLowerCase().includes('necromancer')) {
                            const necroBoost = challengeModifiers.necromancerBoost || 5;
                            scaled.health = Math.round(scaled.health * necroBoost);
                        }
                    }
                    
                    // Boss tile health buff: Double health for boss-tier enemies on boss stages
                    if (isBossTile && isBossEnemy) {
                        scaled.health = Math.round(scaled.health * 2);
                    }

                    // Create enemy visual
                    const wrap = document.createElement('div');
                    wrap.className = 'enemy-single';
                    wrap.style.width = '100%';
                    wrap.style.display = 'flex';
                    wrap.style.flexDirection = 'column';
                    wrap.style.alignItems = 'center';
                    wrap.style.marginBottom = '8px';

                    const nameH = document.createElement('h3');
                    nameH.className = 'w3-text-white';
                    nameH.textContent = (key || 'Enemy') + ` (Lv ${level})`;

                    const barWrap = document.createElement('div');
                    barWrap.className = 'enemy-health-bar w3-light-grey';
                    barWrap.style.width = '80%';
                    barWrap.style.height = '12px';
                    barWrap.style.marginBottom = '4px';
                    const inner = document.createElement('div');
                    inner.className = 'w3-green';
                    inner.style.width = '100%';
                    inner.style.height = '100%';
                    inner.textContent = `HP ${scaled.health}`;
                    barWrap.appendChild(inner);
                    
                    // Add mana bar for spawned enemy
                    const manaBarWrap = document.createElement('div');
                    manaBarWrap.className = 'enemy-mana-bar w3-light-grey';
                    manaBarWrap.style.width = '80%';
                    manaBarWrap.style.height = '10px';
                    manaBarWrap.style.marginBottom = '6px';
                    const manaInner = document.createElement('div');
                    manaInner.className = 'w3-blue';
                    manaInner.style.width = '100%';
                    manaInner.style.height = '100%';
                    manaInner.style.fontSize = '0.7em';
                    const spawnManaDisplay = 50 + (scaled.magic * 10);
                    manaInner.textContent = `MP ${spawnManaDisplay}`;
                    manaBarWrap.appendChild(manaInner);

                    const img = document.createElement('img');
                    img.src = imgPath || (`Enemies/${key.toLowerCase()}.png`);
                    img.alt = key;
                    img.style.maxWidth = '28%';
                    img.style.objectFit = 'contain';
                    img.className = 'hoverable';

                    wrap.appendChild(nameH);
                    wrap.appendChild(barWrap);
                    wrap.appendChild(manaBarWrap);
                    wrap.appendChild(img);

                    // Store scaled stats on element for later (if needed)
                    wrap.dataset.hp = scaled.health;
                    wrap.dataset.maxHp = scaled.health;
                    wrap.dataset.str = scaled.strength;
                    wrap.dataset.speed = scaled.speed;
                    wrap.dataset.mag = scaled.magic;
                    wrap.dataset.def = scaled.defense || base.defense || 0;
                    wrap.dataset.key = key;
                    wrap.dataset.level = level; // Store the level
                    wrap.dataset.transformed = 'false'; // Track transformation state for Divine King
                    wrap.dataset.mana = spawnManaDisplay;
                    wrap.dataset.maxMana = spawnManaDisplay;
                    wrap.dataset.manaCost = 10; // All enemy attacks cost 10 mana

                    // Add hover tooltip functionality
                    let tooltip = document.getElementById('enemy-tooltip');
                    if (!tooltip) {
                        tooltip = document.createElement('div');
                        tooltip.id = 'enemy-tooltip';
                        tooltip.className = 'enemy-tooltip';
                        document.body.appendChild(tooltip);
                    }
                    
                    const showTooltip = (e) => {
                        const isMobile = window.innerWidth <= 768;
                        const rect = wrap.getBoundingClientRect();
                        
                        // Get current stats from dataset (handles transformations)
                        const currentKey = wrap.dataset.key || key;
                        const currentBase = ENEMY_BASE_STATS[currentKey] || base;
                        const currentHp = Number(wrap.dataset.hp) || 0;
                        const currentMaxHp = Number(wrap.dataset.maxHp) || 1;
                        const currentStr = Number(wrap.dataset.str) || 0;
                        const currentMag = Number(wrap.dataset.mag) || 0;
                        const currentSpeed = Number(wrap.dataset.speed) || 0;
                        const currentDef = Number(wrap.dataset.def) || 0;
                        const specialEffect = currentBase.specialEffect || 'No special effect';
                        
                        // Get status effects for this enemy
                        const enemyIdx = Array.from(wrap.parentElement.children).indexOf(wrap);
                        const effects = (typeof enemyStatusEffects !== 'undefined' && enemyStatusEffects[enemyIdx]) ? enemyStatusEffects[enemyIdx] : [];
                        let statusHtml = '';
                        if (effects && effects.length > 0) {
                            const statusIcons = effects.map(e => {
                                const icon = e.type === 'burn' ? 'ðŸ”¥' : 
                                             e.type === 'leech' ? 'ðŸ©¸' : 
                                             e.type === 'bleed' ? 'ðŸ’‰' : 
                                             e.type === 'grim' ? 'ðŸ’€' : 
                                             e.type === 'chill' ? 'â„ï¸' : '?';
                                const stackDisplay = (e.stacks && e.stacks > 1) ? `Ã—${e.stacks}` : '';
                                const label = e.type.charAt(0).toUpperCase() + e.type.slice(1);
                                return `${icon} ${label}${stackDisplay}`;
                            }).join(', ');
                            statusHtml = `<div class="stat-row" style="color: #ffaa00; font-weight: bold;"><span>Status Effects:</span><span>${statusIcons}</span></div>`;
                        }
                        
                        // Calculate damage preview if an attack is selected
                        let damagePreview = '';
                        if (selectedAttackId) {
                            const memberKey = (typeof currentPlayerTurn !== 'undefined' && currentPlayerTurn === 2) ? activeBattleMember2 : activeBattleMember;
                            const attacker = PARTY_STATS[memberKey];
                            const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                            const selectedAttack = attacks.find(a => a.id === selectedAttackId);
                            
                            if (selectedAttack && attacker) {
                                const carriedMult = getCarriedMultiplier(memberKey);
                                let str = Number(attacker.STRENGTH||0) * carriedMult;
                                let mag = Number(attacker.MAGIC||0) * carriedMult;
                                const skill = Number(attacker.SKILL || 0);
                                
                                const strMult = Number(selectedAttack.strMultiplier||0);
                                const magMult = Number(selectedAttack.magicMultiplier||0);
                                const sklMult = Number(selectedAttack.sklMultiplier||0);
                                
                                // Calculate base damage
                                let baseDmg;
                                if (sklMult > 0) {
                                    const flatDamage = (str * strMult + mag * magMult);
                                    const skillMultiplier = (1 + skill * sklMult);
                                    baseDmg = flatDamage * skillMultiplier;
                                } else {
                                    baseDmg = (mag * magMult + str * strMult);
                                }
                                
                                // Apply defense reduction
                                const defenseMultiplier = Math.max(0.5, 1.0 - (Math.log10(currentDef + 1) * 0.05));
                                const damageReduction = currentDef * defenseMultiplier;
                                const damageAfterDefense = baseDmg - damageReduction;
                                const minimumDamage = Math.ceil(baseDmg * 0.1);
                                let estimatedDmg = Math.max(minimumDamage, Math.round(damageAfterDefense));
                                
                                // Account for crit chance on skill attacks
                                const isSkillAttack = sklMult > 0;
                                if (isSkillAttack) {
                                    const baseCritChance = 0.05;
                                    const skillCritBonus = skill * 0.003;
                                    const totalCritChance = baseCritChance + skillCritBonus;
                                    const critMultiplier = 1.5;
                                    const avgDmg = Math.round(estimatedDmg * (1 - totalCritChance) + (estimatedDmg * critMultiplier * totalCritChance));
                                    damagePreview = `<div class="stat-row" style="color: #ffaa00; font-weight: bold;"><span>ðŸ’¥ Estimated Damage:</span><span>${estimatedDmg} (${Math.round(totalCritChance * 100)}% crit â†’ avg ${avgDmg})</span></div>`;
                                } else {
                                    damagePreview = `<div class="stat-row" style="color: #ffaa00; font-weight: bold;"><span>ðŸ’¥ Estimated Damage:</span><span>${estimatedDmg}</span></div>`;
                                }
                            }
                        }
                        
                        tooltip.innerHTML = `
                            <h4>${currentKey} (Level ${level})</h4>
                            <div class="stat-row"><span>Health:</span><span>${currentHp}/${currentMaxHp}</span></div>
                            <div class="stat-row"><span>Strength:</span><span>${currentStr}</span></div>
                            <div class="stat-row"><span>Magic:</span><span>${currentMag}</span></div>
                            <div class="stat-row"><span>Speed:</span><span>${currentSpeed}</span></div>
                            <div class="stat-row"><span>Defense:</span><span>${currentDef}</span></div>
                            ${statusHtml}
                            ${damagePreview}
                            ${specialEffect !== 'No special effect' ? `<div class="special-effect">${specialEffect}</div>` : ''}
                        `;
                        
                        tooltip.classList.add('active');
                        
                        // Position tooltip
                        if (isMobile) {
                            // Below enemy on mobile
                            tooltip.style.left = Math.max(10, rect.left) + 'px';
                            tooltip.style.top = (rect.bottom + 10) + 'px';
                        } else {
                            // To the right on desktop
                            tooltip.style.left = (rect.right + 15) + 'px';
                            tooltip.style.top = rect.top + 'px';
                        }
                    };
                    
                    const hideTooltip = () => {
                        tooltip.classList.remove('active');
                    };
                    
                    wrap.addEventListener('mouseenter', showTooltip);
                    wrap.addEventListener('mouseleave', hideTooltip);
                    wrap.addEventListener('mousemove', showTooltip);

                    // Make enemy clickable for target selection
                    wrap.style.cursor = 'pointer';
                    wrap.onclick = () => {
                        // clear previous highlights
                        getEnemyWrappers().forEach(w=>w.style.outline='');
                        wrap.style.outline = '3px solid red';
                        selectedTarget = wrap;
                        logCombat(`Selected target: ${wrap.querySelector('img').alt}`);
                        // Only perform attack from clicking an enemy if it's the player's turn AND an attack is selected (or no attacks exist)
                        const memberKey = getActiveBattleMember();
                        const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                        const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                        const finalList = (attacks.filter(a=>equipped.has(a.id)).concat(attacks.filter(a=>!equipped.has(a.id)))).slice(0,5);
                        const hasAttacks = finalList.length > 0;
                        if (playerCanAct && typeof window.playerPerformAttackOn === 'function') {
                            if (!hasAttacks || (hasAttacks && selectedAttackId)) {
                                window.playerPerformAttackOn(wrap);
                            } else {
                                // Prompt player to select an attack first
                                logCombat('Please select an attack before targeting an enemy.');
                            }
                        } else if (!playerCanAct) {
                            logCombat('Wait for your turn to attack!');
                        }
                    };

                    enemyArea.insertBefore(wrap, enemiesDiv);
                });
            }

            // Populate attacks area for active battle member
            function renderAttacksForPlayer(){
                const atkArea = document.getElementById('Attacks');
                if (!atkArea) return;
                atkArea.innerHTML = '';
                // Use currentPlayerTurn to determine which player's attacks to show
                const memberKey = (typeof currentPlayerTurn !== 'undefined' && currentPlayerTurn === 2) ? activeBattleMember2 : activeBattleMember;
                const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                // Show only equipped attacks (up to 5)
                const equippedList = attacks.filter(a=>equipped.has(a.id)).slice(0, 5);
                equippedList.forEach(a=>{
                    const slot = document.createElement('div');
                    slot.className = 'attack-slot';
                    
                    // Check cooldown, ammo, and mana status
                    const cooldownKey = `${a.name}_${memberKey}`;
                    const remainingCooldown = attackCooldowns[cooldownKey] || 0;
                    const requiresAmmo = a.requiresAmmo || false;
                    const currentAmmo = Number(PARTY_STATS[memberKey]?.AMMO || 0);
                    const manaCost = a.manaCost || 0;
                    const currentMana = Number(PARTY_STATS[memberKey]?.MANA || 0);
                    
                    // Add status classes
                    if (remainingCooldown > 0) {
                        slot.classList.add('on-cooldown');
                    } else if (requiresAmmo && currentAmmo < 1) {
                        slot.classList.add('no-ammo');
                    } else if (manaCost > currentMana) {
                        slot.classList.add('no-mana');
                    }
                    
                    // Use special icon for Rest, otherwise use item image
                    const attackIcon = a.isRest ? 'Assests/empty-slot.png' : ((ITEM_TABLE && ITEM_TABLE[a.itemName] && ITEM_TABLE[a.itemName].image) || 'Assests/empty-slot.png');
                    slot.innerHTML = `<img src="${attackIcon}" alt="${a.name}"><span>${a.name}</span>`;
                    
                    // Add cooldown overlay if on cooldown
                    if (remainingCooldown > 0) {
                        const overlay = document.createElement('div');
                        overlay.className = 'cooldown-overlay';
                        overlay.textContent = remainingCooldown;
                        slot.appendChild(overlay);
                    }
                    
                    // Add tooltip functionality
                    slot.addEventListener('mouseenter', (e) => showAttackTooltip(e, a));
                    slot.addEventListener('mousemove', (e) => updateTooltipPosition(e));
                    slot.addEventListener('mouseleave', hideAttackTooltip);
                    
                    atkArea.appendChild(slot);
                });
            }
            
            // Show attack tooltip with detailed stats
            function showAttackTooltip(event, attackObj) {
                const tooltip = document.getElementById('attack-tooltip');
                if (!tooltip) return;
                
                // Get current member's stats based on whose turn it is
                const memberKey = (typeof currentPlayerTurn !== 'undefined' && currentPlayerTurn === 2) ? activeBattleMember2 : activeBattleMember;
                const attacker = PARTY_STATS[memberKey];
                if (!attacker) return;
                
                const str = Number(attacker.STRENGTH || 0);
                const mag = Number(attacker.MAGIC || 0);
                const skill = Number(attacker.SKILL || 0);
                
                // Build tooltip content
                let content = `<div class="tooltip-header">${attackObj.name}</div>`;
                
                // Show attack group
                const attackGroup = attackObj.group || 'unknown';
                const groupIcons = {
                    'strength': 'ðŸ’ª Strength',
                    'magic': 'âœ¨ Magic',
                    'skill': 'ðŸŽ¯ Skill',
                    'hybrid': 'âš”ï¸ Hybrid',
                    'utility': 'ðŸ› ï¸ Utility'
                };
                content += `<div class="tooltip-group" style="color: #aaa; font-size: 0.85em;">${groupIcons[attackGroup] || 'â“ Unknown'}</div>`;
                
                // Show cooldown
                const cooldown = attackObj.cooldown || 0;
                if (cooldown > 0) {
                    content += `<div class="tooltip-cooldown">â³ Cooldown: ${cooldown} turn${cooldown > 1 ? 's' : ''}</div>`;
                }
                
                // Show mana cost ONLY if magicMultiplier > 0
                const manaCost = attackObj.manaCost || 0;
                let magMult = attackObj.magicMultiplier || attackObj.magMult || 0;
                if (manaCost > 0 && Number(magMult) > 0) {
                    content += `<div class="tooltip-mana">ðŸ’§ Mana Cost: ${manaCost}</div>`;
                } else if (attackObj.isRest) {
                    content += `<div class="tooltip-special">ðŸ’¤ Restores 30% Max Mana</div>`;
                }
                // Calculate base damage from stats
                const strMult = attackObj.strMultiplier || attackObj.strMult || 0;
                // magMult already declared above
                const sklMult = attackObj.skillMultiplier || 0;
                
                if (strMult > 0 || magMult > 0 || sklMult > 0) {
                    const strDamage = Math.round(str * strMult);
                    const magDamage = Math.round(mag * magMult);
                    const sklDamage = Math.round(skill * sklMult);
                    const totalDamage = strDamage + magDamage + sklDamage;
                    
                    content += `<div class="tooltip-damage">ðŸ’¥ Base Damage: ${totalDamage}`;
                    const parts = [];
                    if (strDamage > 0) parts.push(`${strDamage} STR`);
                    if (magDamage > 0) parts.push(`${magDamage} MAG`);
                    if (sklDamage > 0) parts.push(`${sklDamage} SKL`);
                    if (parts.length > 1) {
                        content += ` (${parts.join(' + ')})`;
                    }
                    content += `</div>`;
                }
                
                // Status effect
                const status = attackObj.statusEffect || attackObj.status;
                if (status) {
                    const statusIcons = {
                        burn: 'ðŸ”¥',
                        leech: 'ðŸ©¸',
                        bleed: 'ðŸ’‰',
                        grim: 'ðŸ’€',
                        chill: 'â„ï¸'
                    };
                    const icon = statusIcons[status.toLowerCase()] || 'âœ¨';
                    content += `<div class="tooltip-status">${icon} Inflicts ${status.toUpperCase()}</div>`;
                }
                
                // AOE indicator
                if (attackObj.aoe === true) {
                    content += `<div class="tooltip-special">ðŸ’¥ Hits ALL enemies (AOE)</div>`;
                }
                
                // Item ability
                if (attackObj.itemAbilityNum) {
                    content += `<div class="tooltip-ability">ðŸŽ¯ Ability #${attackObj.itemAbilityNum}</div>`;
                }
                
                tooltip.innerHTML = content;
                tooltip.classList.add('visible');
                updateTooltipPosition(event);
            }
            
            // Update tooltip position to follow cursor
            function updateTooltipPosition(event) {
                const tooltip = document.getElementById('attack-tooltip');
                if (!tooltip || !tooltip.classList.contains('visible')) return;
                
                const offset = 15;
                let x = event.clientX + offset;
                let y = event.clientY + offset;
                
                // Prevent tooltip from going off-screen
                const tooltipRect = tooltip.getBoundingClientRect();
                if (x + tooltipRect.width > window.innerWidth) {
                    x = event.clientX - tooltipRect.width - offset;
                }
                if (y + tooltipRect.height > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - offset;
                }
                
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }
            
            // Hide attack tooltip
            function hideAttackTooltip() {
                const tooltip = document.getElementById('attack-tooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            }

            // Run updates
            updatePartyDisplay();
            updatePartySlotHighlight();
            updatePlayerArea();
            renderEnemies();
            renderAttacksForPlayer();
            // DO NOT mark initial member as participant - they must deal or take damage first
            
            // Battle music system
            let battleMusic = null;
            let currentMusicTrack = null;
            
            function playBattleMusic() {
                // Check if music is enabled
                const musicEnabled = localStorage.getItem('musicEnabled') === 'true';
                if (!musicEnabled) return;
                
                // Stop any existing music
                if (battleMusic) {
                    battleMusic.pause();
                    battleMusic = null;
                }
                
                let musicPath = null;
                const isBoss = battleData.isBossTile || false;
                
                // Check for specific boss stages
                if (level === 50) {
                    // Divine King stage
                    const enemies = getEnemyWrappers();
                    const hasDemonKing = enemies.some(e => e.dataset.key === 'demonKing');
                    
                    if (hasDemonKing) {
                        musicPath = 'audio/boss/revenge.mp3';
                    } else {
                        musicPath = 'audio/boss/bossIntroduction.mp3';
                    }
                } else if (level === 100) {
                    // Lightning Shark stage
                    musicPath = 'audio/boss/orbitalColossus.mp3';
                } else if (level === 150) {
                    // Overseer stage - music changes on each respawn (health bar)
                    const enemies = getEnemyWrappers();
                    const overseer = enemies.find(e => e.dataset.key === 'overseer');
                    
                    if (overseer) {
                        const barsRemaining = Number(overseer.dataset.barsRemaining) || 3;
                        
                        if (barsRemaining === 3) {
                            musicPath = 'audio/boss/big_boss_2_0.wav';
                        } else if (barsRemaining === 2) {
                            musicPath = 'audio/boss/blackmoonColossus.wav';
                        } else {
                            musicPath = 'audio/boss/juhaniJunkala.wav';
                        }
                    } else {
                        musicPath = 'audio/boss/big_boss_2_0.wav';
                    }
                } else if (isBoss) {
                    // Boss tiles (mini bosses and mid bosses) - random boss music selection
                    const bossTracks = [
                        'audio/boss/greatBoss.ogg',
                        'audio/boss/bossBattle.wav',
                        'audio/boss/heyBoss.mp3'
                    ];
                    musicPath = bossTracks[Math.floor(Math.random() * bossTracks.length)];
                } else {
                    // Regular battles - music based on game mode
                    const gameMode = (typeof getCurrentGameMode === 'function') ? getCurrentGameMode() : 
                                     localStorage.getItem('selectedGameMode') || 'normal';
                    
                    if (isChallenge) {
                        // Challenge mode uses 8bitMetal
                        musicPath = 'audio/background/8bitMetal.wav';
                    } else if (gameMode === 'hell') {
                        // Hell mode uses 8bitMetal
                        musicPath = 'audio/background/8bitMetal.wav';
                    } else if (gameMode === 'hard') {
                        // Hard mode uses franticLevel
                        musicPath = 'audio/background/franticLevel.wav';
                    } else {
                        // Normal mode uses happyLevel
                        musicPath = 'audio/background/happyLevel.wav';
                    }
                }
                
                // Only play music if we selected a track and it's different from current
                if (musicPath && musicPath !== currentMusicTrack) {
                    currentMusicTrack = musicPath;
                    battleMusic = new Audio(musicPath);
                    battleMusic.loop = true;
                    battleMusic.volume = 0.5;
                    
                    const playPromise = battleMusic.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(err => {
                            console.log('Autoplay prevented, waiting for user interaction:', err);
                            // Wait for any user interaction to start music
                            const startMusic = () => {
                                if (battleMusic && localStorage.getItem('musicEnabled') === 'true') {
                                    battleMusic.play().catch(e => console.error('Failed to play battle music:', e));
                                    document.removeEventListener('click', startMusic);
                                    document.removeEventListener('keydown', startMusic);
                                }
                            };
                            document.addEventListener('click', startMusic);
                            document.addEventListener('keydown', startMusic);
                        });
                    }
                }
            }
            
            // Start battle music
            playBattleMusic();

            // Make party slots clickable to switch members during battle
            function enablePartySlotSwitching(){
                const slotIds = ['one', 'two', 'three', 'four', 'five'];
                slotIds.forEach((id, idx) => {
                    const slot = document.getElementById(`slot-${id}`);
                    if (slot) {
                        slot.style.cursor = 'pointer';
                        slot.onclick = () => {
                            const key = ['ONE','TWO','THREE','FOUR','FIVE'][idx];
                            // Check if it's player's turn before allowing switch
                            if (!playerCanAct || !playerWaiting) {
                                logCombat("You can only switch party members during your turn!");
                                return;
                            }
                            switchBattleMember(key);
                        };
                    }
                });
            }
            enablePartySlotSwitching();

                            // -------------------- Combat engine --------------------
                            const DEBUG_COMBAT = true;
                            function logCombat(msg){
                                try { console.log('[combat] '+msg); } catch(e){}
                                if (!DEBUG_COMBAT) return;
                                const box = document.getElementById('combat-debug');
                                if (!box) return;
                                const line = document.createElement('div');
                                line.textContent = msg;
                                box.appendChild(line);
                                box.scrollTop = box.scrollHeight;
                            }

                            let selectedAttackId = null;
                    // Map of enemy wrappers in order
                    function getEnemyWrappers(){
                        return Array.from(document.querySelectorAll('.enemy-single'));
                    }

                    // Make attack slots clickable/selectable
                    function enableAttackSelection(){
                        const atkArea = document.getElementById('Attacks');
                        if (!atkArea) return;
                        atkArea.querySelectorAll('.attack-slot').forEach(slot=>{
                            slot.style.cursor = 'pointer';
                            slot.onclick = () => {
                                // clear previous highlights
                                atkArea.querySelectorAll('.attack-slot').forEach(s=>s.style.outline='');
                                slot.style.outline = '3px solid gold';
                                // find index of slot among children
                                const idx = Array.prototype.indexOf.call(atkArea.children, slot);
                                // selectedAttackId will map to the attack objects displayed order
                                // Use currentPlayerTurn to get the correct player's attacks
                                const memberKey = (typeof currentPlayerTurn !== 'undefined' && currentPlayerTurn === 2) ? activeBattleMember2 : activeBattleMember;
                                const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                                const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                                const equippedList = attacks.filter(a=>equipped.has(a.id)).slice(0, 5);
                                const atk = equippedList[idx];
                                                        selectedAttackId = atk ? atk.id : null;
                                                        // Clear any previously selected enemy â€” selecting attack should not auto-attack
                                                        getEnemyWrappers().forEach(w=>w.style.outline='');
                                                        selectedTarget = null;
                            };
                        });
                    }
                    enableAttackSelection();
                    
                    // Helper function to enable/disable Rest button
                    function updateRestButton(enabled) {
                        const restButton = document.getElementById('rest-button');
                        if (restButton) {
                            restButton.disabled = !enabled;
                            restButton.style.opacity = enabled ? '1' : '0.5';
                            restButton.style.cursor = enabled ? 'pointer' : 'not-allowed';
                        }
                    }
                    
                    // Disable Rest button initially
                    updateRestButton(false);
                    
                    // Add Rest button handler
                    const restButton = document.getElementById('rest-button');
                    if (restButton) {
                        restButton.onclick = () => {
                            // Only allow resting during player's turn
                            if (!playerCanAct || !playerWaiting) {
                                logCombat("âŒ It's not your turn to rest!");
                                return;
                            }
                            
                            // Determine which player is acting
                            const memberKey = (typeof currentPlayerTurn !== 'undefined' && currentPlayerTurn === 2) ? activeBattleMember2 : activeBattleMember;
                            const attacker = PARTY_STATS[memberKey];
                            
                            if (!attacker) {
                                logCombat("âŒ No active player found!");
                                return;
                            }
                            
                            // Restore 60% of max mana
                            const manaRestore = Math.round(Number(attacker.MAX_MANA || 100) * 0.6);
                            
                            // Ability 76: Overcharge - Allow above-max mana, bonus damage when above max
                            const restAbilities = getEquippedAbilities(memberKey);
                            if (restAbilities.includes(76)) {
                                // Allow overcharging beyond max mana
                                const currentMana = Number(attacker.MANA || 0);
                                const maxMana = Number(attacker.MAX_MANA || 100);
                                const newMana = currentMana + manaRestore;
                                attacker.MANA = newMana;
                                
                                if (!overchargedMana[memberKey]) overchargedMana[memberKey] = 0;
                                if (newMana > maxMana) {
                                    overchargedMana[memberKey] = newMana - maxMana;
                                    logCombat(`âš¡ Overcharge: ${attacker.NAME} rests and OVERCHARGES to ${newMana} mana! (+${overchargedMana[memberKey]} over max)`);
                                } else {
                                    logCombat(`ðŸ’¤ ${attacker.NAME} rests and restores ${manaRestore} mana! (${newMana}/${maxMana})`);
                                }
                            } else {
                                // Normal rest: cap at max mana
                                attacker.MANA = Math.min(Number(attacker.MAX_MANA || 100), Number(attacker.MANA || 0) + manaRestore);
                                logCombat(`ðŸ’¤ ${attacker.NAME} rests and restores ${manaRestore} mana! (${attacker.MANA}/${attacker.MAX_MANA})`);
                            }
                            
                            updatePlayerArea();
                            
                            // Disable Rest button after use
                            updateRestButton(false);
                            
                            // Clear attack selection
                            const atkArea = document.getElementById('Attacks');
                            if (atkArea) {
                                atkArea.querySelectorAll('.attack-slot').forEach(s=>s.style.outline='');
                            }
                            
                            // Clear waiting flags - combat system will continue automatically
                            playerCanAct = false;
                            playerWaiting = false;
                            waitingForPlayerAction = false;
                            selectedAttackId = null;
                            selectedTarget = null;
                        };
                    }

                    // Helper function to count alive party members
                    function countAlivePartyMembers() {
                        let count = 0;
                        ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE'].forEach(key => {
                            const m = PARTY_STATS[key];
                            if (m && Number(m.HEALTH) > 0) count++;
                        });
                        return count;
                    }
                    
                    // Helper function to get Carried stat multiplier (ability 6)
                    function getCarriedMultiplier(memberKey) {
                        const equippedAbilities = getEquippedAbilities(memberKey);
                        if (!equippedAbilities.includes(6)) return 1.0;
                        
                        const aliveCount = countAlivePartyMembers();
                        if (aliveCount > 3) {
                            // +20% per ally over 3
                            return 1.0 + ((aliveCount - 3) * 0.2);
                        } else if (aliveCount < 3) {
                            // -40% per ally under 3
                            return Math.max(0.1, 1.0 - ((3 - aliveCount) * 0.4));
                        }
                        return 1.0;
                    }

                    // Helper to update enemy bar visuals when hp changes
                    function updateEnemyBar(wrap){
                        const bar = wrap.querySelector('.enemy-health-bar .w3-green');
                        if (!bar) return;
                        const cur = Number(wrap.dataset.hp);
                        const max = Number(wrap.dataset.maxHp) || 1;
                        const pct = Math.max(0, Math.min(100, Math.round((cur/max)*100)));
                        bar.style.width = pct + '%';
                        bar.textContent = `HP ${Math.max(0,cur)}/${max}`;
                        
                        // Update mana bar
                        const manaBar = wrap.querySelector('.enemy-mana-bar .w3-blue');
                        if (manaBar) {
                            const curMana = Number(wrap.dataset.mana) || 0;
                            const maxMana = Number(wrap.dataset.maxMana) || 1;
                            const manaPct = Math.max(0, Math.min(100, Math.round((curMana/maxMana)*100)));
                            manaBar.style.width = manaPct + '%';
                            manaBar.textContent = `MP ${Math.max(0,curMana)}`;
                        }
                        
                        // Update status effect display after health update
                        updateStatusEffectDisplay();
                    }
                    
                    // Display active status effects on enemies and players
                    function updateStatusEffectDisplay(){
                        // Safety check - only run if status effects are initialized
                        if (typeof enemyStatusEffects === 'undefined' || typeof playerStatusEffects === 'undefined') return;
                        
                        // Update status effects for both players separately
                        const member1Key = activeBattleMember;
                        const member2Key = activeBattleMember2;
                        
                        // Player 1 status effects
                        const effects1 = playerStatusEffects[member1Key];
                        const player1Display = document.getElementById('player-1-status');
                        if (player1Display) {
                            if (effects1 && effects1.length > 0) {
                                const icons = effects1.map(e => {
                                    const icon = e.type === 'burn' ? 'ðŸ”¥' : 
                                                 e.type === 'leech' ? 'ðŸ©¸' : 
                                                 e.type === 'bleed' ? 'ðŸ’‰' : 
                                                 e.type === 'grim' ? 'ðŸ’€' : 
                                                 e.type === 'chill' ? 'â„ï¸' : '?';
                                    const stackDisplay = (e.stacks && e.stacks > 1) ? `Ã—${e.stacks}` : '';
                                    const turnsDisplay = e.turnsLeft && e.turnsLeft < 999 ? `(${e.turnsLeft})` : '';
                                    return `<span class="status-icon" title="${e.type.toUpperCase()}${stackDisplay} ${turnsDisplay}">${icon}${stackDisplay}</span>`;
                                }).join('');
                                player1Display.innerHTML = icons;
                                player1Display.style.display = 'block';
                            } else {
                                player1Display.style.display = 'none';
                            }
                        }
                        
                        // Player 2 status effects
                        const effects2 = playerStatusEffects[member2Key];
                        const player2Display = document.getElementById('player-2-status');
                        if (player2Display) {
                            if (effects2 && effects2.length > 0) {
                                const icons = effects2.map(e => {
                                    const icon = e.type === 'burn' ? 'ðŸ”¥' : 
                                                 e.type === 'leech' ? 'ðŸ©¸' : 
                                                 e.type === 'bleed' ? 'ðŸ’‰' : 
                                                 e.type === 'grim' ? 'ðŸ’€' : 
                                                 e.type === 'chill' ? 'â„ï¸' : '?';
                                    const stackDisplay = (e.stacks && e.stacks > 1) ? `Ã—${e.stacks}` : '';
                                    const turnsDisplay = e.turnsLeft && e.turnsLeft < 999 ? `(${e.turnsLeft})` : '';
                                    return `<span class="status-icon" title="${e.type.toUpperCase()}${stackDisplay} ${turnsDisplay}">${icon}${stackDisplay}</span>`;
                                }).join('');
                                player2Display.innerHTML = icons;
                                player2Display.style.display = 'block';
                            } else {
                                player2Display.style.display = 'none';
                            }
                        }
                        
                        // Update turn indicator glow
                        const player1Wrapper = document.getElementById('player-1-wrapper');
                        const player2Wrapper = document.getElementById('player-2-wrapper');
                        if (typeof currentPlayerTurn !== 'undefined') {
                            if (currentPlayerTurn === 1 && player1Wrapper) {
                                player1Wrapper.classList.add('active-turn');
                                if (player2Wrapper) player2Wrapper.classList.remove('active-turn');
                            } else if (currentPlayerTurn === 2 && player2Wrapper) {
                                player2Wrapper.classList.add('active-turn');
                                if (player1Wrapper) player1Wrapper.classList.remove('active-turn');
                            }
                        }
                    }

                            // Track whether player is allowed to act this turn (set by scheduler)
                            let playerCanAct = false;
                            let playerWaiting = false; // avoids re-prompting repeatedly
                            let selectedTarget = null;
                            let waitingForPlayerAction = false; // Flag to pause queue until player acts

                    // Combat scheduler using speed-based attack ratios (GCD method)
                    // Helper: compute GCD for ratio simplification
                    function gcd(a, b) {
                        while (b) { const t = b; b = a % b; a = t; }
                        return a;
                    }
                    
                    // Get effective speed (note: chill no longer affects speed, only damage output)
                    function getEffectiveSpeed(targetType, targetKey, baseSpeed) {
                        const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                        if (!effectsArray) return baseSpeed;
                        const chill = effectsArray.find(e => e.type === 'chill');
                        if (chill) {
                            return Math.max(1, Math.round(baseSpeed * 0.75)); // Visual indicator only
                        }
                        return baseSpeed;
                    }

                    let combatRunning = true;
                    let actionQueue = [];
                    let queueIndex = 0;
                    let playerAttacksPerCycle = 0;
                    
                    // Update turn order display UI
                    function updateTurnOrderDisplay() {
                        const container = document.getElementById('turn-order-queue');
                        if (!container) return;
                        
                        container.innerHTML = '';
                        
                        // Show next 8 turns in the queue
                        const displayCount = Math.min(8, actionQueue.length);
                        for (let i = 0; i < displayCount; i++) {
                            const idx = (queueIndex + i) % actionQueue.length;
                            const action = actionQueue[idx];
                            
                            const box = document.createElement('div');
                            box.className = 'turn-box';
                            
                            if (action.type === 'p') {
                                // Player turn
                                box.classList.add('player-turn');
                                const img = document.createElement('img');
                                img.src = 'Assests/player.png';
                                img.alt = `Player ${action.playerNum}`;
                                box.appendChild(img);
                                
                                // Add player number label
                                const numLabel = document.createElement('div');
                                numLabel.className = 'player-number';
                                numLabel.textContent = action.playerNum;
                                box.appendChild(numLabel);
                            } else if (action.type === 'e') {
                                // Enemy turn - check if enemy is still alive
                                box.classList.add('enemy-turn');
                                const enemies = getEnemyWrappers();
                                const enemyWrap = enemies[action.index];
                                // Only show the turn box if the enemy exists and is alive
                                if (enemyWrap && Number(enemyWrap.dataset.hp) > 0) {
                                    const enemyImg = enemyWrap.querySelector('img');
                                    const img = document.createElement('img');
                                    img.src = enemyImg ? enemyImg.src : 'Enemies/skull.png';
                                    img.alt = 'Enemy';
                                    box.appendChild(img);
                                    
                                    // Add enemy number
                                    const numLabel = document.createElement('div');
                                    numLabel.className = 'enemy-number';
                                    numLabel.textContent = `#${action.index + 1}`;
                                    box.appendChild(numLabel);
                                } else {
                                    // Enemy is dead, skip adding this box entirely
                                    continue;
                                }
                            }
                            
                            // Highlight the current/next turn
                            if (i === 0) {
                                box.classList.add('active');
                            }
                            
                            container.appendChild(box);
                        }
                    }

                    // Recalculate action queue based on current active member speed and ALL enemy speeds
                    function recalculateActionQueue() {
                        const member1 = PARTY_STATS[activeBattleMember];
                        const member2 = PARTY_STATS[activeBattleMember2];
                        if (!member1 || !member2) return;
                        const enemies = getEnemyWrappers();
                        if (enemies.length === 0) return;

                        // Get both players' speeds
                        const basePlayer1Speed = Math.max(1, Number(member1.SPEED) || 1);
                        const pSpeed1 = getEffectiveSpeed('player', activeBattleMember, basePlayer1Speed);
                        
                        const basePlayer2Speed = Math.max(1, Number(member2.SPEED) || 1);
                        const pSpeed2 = getEffectiveSpeed('player', activeBattleMember2, basePlayer2Speed);

                        // Collect all enemy speeds
                        const enemySpeeds = enemies.map((wrap, idx) => {
                            const baseSpeed = Math.max(1, Number(wrap.dataset.speed) || Number(wrap.dataset.str) || 1);
                            const effectiveSpeed = getEffectiveSpeed('enemy', idx, baseSpeed);
                            return { wrap, index: idx, speed: effectiveSpeed };
                        }).filter(e => Number(e.wrap.dataset.hp) > 0); // Only alive enemies

                        if (enemySpeeds.length === 0) return;

                        // Find GCD of all speeds (both players + all enemies)
                        let allSpeeds = [Math.round(pSpeed1), Math.round(pSpeed2), ...enemySpeeds.map(e => Math.round(e.speed))];
                        let g = allSpeeds[0];
                        for (let i = 1; i < allSpeeds.length; i++) {
                            g = gcd(g, allSpeeds[i]);
                        }

                        // Calculate attacks per cycle for both players
                        playerAttacksPerCycle = Math.round(pSpeed1) / g;
                        const player2AttacksPerCycle = Math.round(pSpeed2) / g;

                        // Create action queue: {type:'p', playerNum:1|2} for players, {type:'e', index:N, enemyId:name} for enemies
                        actionQueue = [];
                        const player1Actions = [];
                        const player2Actions = [];
                        const enemyActionsByEnemy = {}; // Track actions per individual enemy
                        
                        for (let i = 0; i < playerAttacksPerCycle; i++) player1Actions.push({type:'p', playerNum:1});
                        for (let i = 0; i < player2AttacksPerCycle; i++) player2Actions.push({type:'p', playerNum:2});
                        
                        // Add actions for each enemy based on their individual speed
                        let totalEnemyActions = 0;
                        enemySpeeds.forEach(enemyData => {
                            const enemyAttacks = Math.round(enemyData.speed) / g;
                            const enemyName = enemyData.wrap.querySelector('img') ? enemyData.wrap.querySelector('img').alt : `Enemy${enemyData.index}`;
                            enemyActionsByEnemy[enemyData.index] = {
                                actions: [],
                                name: enemyName,
                                count: enemyAttacks
                            };
                            for (let i = 0; i < enemyAttacks; i++) {
                                enemyActionsByEnemy[enemyData.index].actions.push({ type: 'e', index: enemyData.index, enemyId: enemyName });
                                totalEnemyActions++;
                            }
                        });
                        
                        // Interleave both players and all enemy actions evenly
                        const totalActions = player1Actions.length + player2Actions.length + totalEnemyActions;
                        
                        // Create sorted list of all action sources with their counts
                        const actionSources = [
                            { type: 'player1', actions: player1Actions, remaining: player1Actions.length, ratio: player1Actions.length / totalActions },
                            { type: 'player2', actions: player2Actions, remaining: player2Actions.length, ratio: player2Actions.length / totalActions }
                        ];
                        
                        Object.keys(enemyActionsByEnemy).forEach(enemyIdx => {
                            const enemyData = enemyActionsByEnemy[enemyIdx];
                            actionSources.push({
                                type: 'enemy',
                                enemyIndex: parseInt(enemyIdx),
                                actions: enemyData.actions,
                                remaining: enemyData.count,
                                ratio: enemyData.count / totalActions,
                                name: enemyData.name
                            });
                        });
                        
                        // Always start with player 1
                        if (actionSources[0].remaining > 0) {
                            actionQueue.push(actionSources[0].actions.shift());
                            actionSources[0].remaining--;
                        }
                        
                        // Distribute remaining actions evenly
                        while (actionQueue.length < totalActions) {
                            // Calculate how much each source has contributed relative to their target
                            actionSources.forEach(source => {
                                const currentCount = actionQueue.filter(a => {
                                    if (source.type === 'player1') return a.type === 'p' && a.playerNum === 1;
                                    if (source.type === 'player2') return a.type === 'p' && a.playerNum === 2;
                                    return a.type === 'e' && a.index === source.enemyIndex;
                                }).length;
                                source.deficit = (source.ratio * actionQueue.length) - currentCount;
                            });
                            
                            // Sort by deficit (highest first) - but filter out sources with no remaining actions
                            const availableSources = actionSources.filter(s => s.remaining > 0);
                            if (availableSources.length === 0) break;
                            
                            availableSources.sort((a, b) => b.deficit - a.deficit);
                            
                            // Add action from the source with highest deficit
                            const nextSource = availableSources[0];
                            actionQueue.push(nextSource.actions.shift());
                            nextSource.remaining--;
                        }
                        
                        queueIndex = 0;
                        
                        const totalEnemyAttacks = actionQueue.filter(a => typeof a === 'object' && a.type === 'e').length;
                        logCombat(`Action queue recalculated: Player1 ${playerAttacksPerCycle}/cycle, Player2 ${player2AttacksPerCycle}/cycle, Total Enemy attacks ${totalEnemyAttacks}/cycle (${enemySpeeds.length} enemies)`);
                        
                        // Update turn order display
                        updateTurnOrderDisplay();
                    }

                    // Update queue when switching members WITHOUT resetting queueIndex
                    function updateActionQueueForSwitch() {
                        // Simply rebuild the queue but preserve the current position
                        const savedIndex = queueIndex;
                        recalculateActionQueue();
                        // Restore position, but ensure it's valid
                        queueIndex = Math.min(savedIndex, actionQueue.length - 1);
                        if (queueIndex < 0) queueIndex = 0;
                        logCombat(`Queue updated for switch (position preserved: ${queueIndex}/${actionQueue.length})`);
                    }

                    function startCombatLoop(){
                        const member = PARTY_STATS[getActiveBattleMember()];
                        if (!member) return;
                        // Gather active enemy wrappers and their stats
                        const enemies = getEnemyWrappers().map(w=>({wrap:w, hp: Number(w.dataset.hp), maxHp: Number(w.dataset.maxHp), str: Number(w.dataset.str)||0}));

                        // If no enemies, nothing to do
                        if (enemies.length === 0) return;

                        // Initialize action queue
                        recalculateActionQueue();

                        function pickNextActor(){
                            // Pick from queue; skip dead enemies instead of rebuilding
                            while (queueIndex < actionQueue.length) {
                                const action = actionQueue[queueIndex];
                                
                                // Check if this action is valid
                                if (action.type === 'p') {
                                    // Player action is always valid
                                    queueIndex++;
                                    updateTurnOrderDisplay();
                                    return { type: 'player', playerNum: action.playerNum };
                                } else if (action.type === 'e') {
                                    // Check if enemy is still alive
                                    const allEnemies = getEnemyWrappers();
                                    const enemyWrap = allEnemies[action.index];
                                    if (enemyWrap && Number(enemyWrap.dataset.hp) > 0) {
                                        // Enemy is alive, use this turn
                                        queueIndex++;
                                        updateTurnOrderDisplay();
                                        return { type: 'enemy', enemyIndex: action.index };
                                    } else {
                                        // Enemy is dead, skip this turn
                                        queueIndex++;
                                        continue;
                                    }
                                }
                                
                                // Unknown action type, skip
                                queueIndex++;
                            }
                            
                            // Queue depleted, regenerate
                            queueIndex = 0;
                            recalculateActionQueue();
                            
                            // Try again with new queue
                            if (actionQueue.length > 0) {
                                return pickNextActor();
                            }
                            
                            // Fallback
                            return { type: 'enemy', enemyIndex: 0 };
                        }

                                function getFirstAliveEnemy(){
                                    const arr = getEnemyWrappers();
                                    for (const w of arr){
                                        if (Number(w.dataset.hp) > 0) return w;
                                    }
                                    return null;
                                }

                                // Coral ability tracking - consecutive attacks for bonus damage (max 80%)
                                let consecutiveAttacks = 0;
                                
                                // Overuse ability tracking (ability 7) - consecutive attacks for 200% bonus
                                let overuseConsecutive = 0;
                                
                                // After Shock ability tracking (ability 12) - opponent's next attack ignored
                                let afterShockActive = false;
                                let afterShockCooldown = 0;
                                
                                // Pixel Combo ability tracking (ability 13)
                                let pixelComboCount = 0;
                                let pixelComboActive = false;
                                
                // Burn ground effect tracking (ability 8) - enemies in burn zone
                const burnGroundEffects = {}; // {enemyIndex: {duration, damage}}
                
                // Enhance ability tracking (ability 19) - permanent stat boosts for the battle
                const enhancedStats = {}; // {memberKey: {strength, magic, speed, defense, health}}
                
                // Insight ability tracking (ability 63) - marked enemies take 15% more damage
                const insightMarkedEnemies = new Set(); // Set of enemyIndex values
                
                // Resurrection tracking (abilities 68, 34, 74) - can only resurrect once per battle
                let resurrectionUsed = false;
                
                // Tri-Element tracking (ability 72) - status effects only on first attack
                const triElementUsedBy = new Set(); // Set of memberKeys who have used it
                
                // Overcharge tracking (ability 76) - allow above-max mana
                const overchargedMana = {}; // {memberKey: extraMana}
                
                // Helper function to get item data from attack object
                                function getItemFromAttack(attackObj) {
                                    if (!attackObj || !attackObj.itemName) return null;
                                    
                                    // Look up the item from INVENTORY or ITEM_TABLE
                                    let itemData = null;
                                    if (typeof INVENTORY !== 'undefined') {
                                        itemData = INVENTORY.find(i => i.name === attackObj.itemName);
                                    }
                                    if (!itemData && typeof ITEM_TABLE !== 'undefined') {
                                        itemData = ITEM_TABLE[attackObj.itemName];
                                    }
                                    
                                    return itemData;
                                }
                                
                                // Helper function to count alive party members for Carried ability
                                function countAlivePartyMembers() {
                                    let count = 0;
                                    ['ONE','TWO','THREE','FOUR','FIVE'].forEach(key => {
                                        const m = PARTY_STATS[key];
                                        if (m && Number(m.HEALTH) > 0) count++;
                                    });
                                    return count;
                                }
                                
                                // Helper function to get Carried stat multiplier (ability 6)
                                function getCarriedMultiplier(memberKey) {
                                    const equippedAbilities = getEquippedAbilities(memberKey);
                                    if (!equippedAbilities.includes(6)) return 1.0;
                                    
                                    const aliveCount = countAlivePartyMembers();
                                    if (aliveCount > 3) {
                                        // +20% per ally over 3
                                        return 1.0 + ((aliveCount - 3) * 0.2);
                                    } else if (aliveCount < 3) {
                                        // -40% per ally under 3
                                        return Math.max(0.1, 1.0 - ((3 - aliveCount) * 0.4));
                                    }
                                    return 1.0;
                                }
                                
                                // Initialize battle stats including ammo
                                function initializeBattleStats() {
                                    // Set initial ammo for players with skill stat
                                    [activeBattleMember, activeBattleMember2].forEach(memberKey => {
                                        if (memberKey && PARTY_STATS[memberKey]) {
                                            const member = PARTY_STATS[memberKey];
                                            if (Number(member.SKILL || 0) > 0) {
                                                member.AMMO = 5;
                                            } else {
                                                member.AMMO = 0;
                                            }
                                            ammoGenerationCounter[memberKey] = 0;
                                        }
                                    });
                                    updatePlayerArea();
                                }
                                
                                // Call initialization when battle starts
                                setTimeout(() => initializeBattleStats(), 100);

                                // Perform a player attack on a specific enemy wrapper (called when player clicks an enemy)
                                function playerPerformAttackOn(enemyWrap){
                                    if (!enemyWrap) return false;
                                    
                                    // Determine which player is acting based on turn
                                    const memberKey = currentPlayerTurn === 1 ? activeBattleMember : activeBattleMember2;
                                    
                                    // Ensure current member is counted as participant
                                    try { battleParticipants.add(memberKey); } catch(e) {}
                                    
                                    const atkArea = document.getElementById('Attacks');
                                    const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                                    const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                                    const equippedList = attacks.filter(a=>equipped.has(a.id)).slice(0, 5);

                                    let attackObj = null;
                                    if (selectedAttackId) attackObj = attacks.find(a=>a.id === selectedAttackId && equipped.has(a.id)) || equippedList[0] || null;
                                    else attackObj = equippedList[0] || null;
                                    if (!attackObj) attackObj = { name: 'slap', strMultiplier: 1, magicMultiplier: 0, itemName: null, manaCost: 0 };
                                    
                                    // Merge with ATTACK_STATS to get special properties like statusBonus
                                    if (attackObj.name && typeof ATTACK_STATS !== 'undefined' && ATTACK_STATS[attackObj.name]) {
                                        attackObj = Object.assign({}, ATTACK_STATS[attackObj.name], attackObj);
                                    }
                                    
                                    const attacker = PARTY_STATS[memberKey];
                                    
                                    // Handle Rest action
                                    if (attackObj.isRest || attackObj.name === 'Rest') {
                                        const manaRestore = Math.round(Number(attacker.MAX_MANA || 100) * 0.6);
                                        attacker.MANA = Math.min(Number(attacker.MAX_MANA || 100), Number(attacker.MANA || 0) + manaRestore);
                                        logCombat(`ðŸ’¤ ${attacker.NAME} rests and restores ${manaRestore} mana! (${attacker.MANA}/${attacker.MAX_MANA})`);
                                        updatePlayerArea();
                                        
                                        // Clear waiting flags
                                        playerCanAct = false;
                                        playerWaiting = false;
                                        waitingForPlayerAction = false;
                                        return true;
                                    }
                                    
                                    // Get equipped abilities to check for Blood Price before mana calculations
                                    const equippedAbilitiesPreCheck = getEquippedAbilities(memberKey);
                                    
                                    // Ability 73: Blood Price - Convert 15% HP to 3x damage bonus
                                    let bloodPriceDamageBonus = 0;
                                    if (equippedAbilitiesPreCheck.includes(73)) {
                                        const currentHP = Number(attacker.HEALTH || 0);
                                        const hpCost = Math.ceil(currentHP * 0.15);
                                        
                                        if (currentHP > hpCost) { // Don't kill yourself
                                            attacker.HEALTH = currentHP - hpCost;
                                            bloodPriceDamageBonus = hpCost * 3; // 3x multiplier
                                            updatePlayerArea();
                                            logCombat(`ðŸ©¸ Blood Price: Sacrificed ${hpCost} HP for +${bloodPriceDamageBonus} damage!`);
                                        }
                                    }
                                    
                                    // Check mana cost
                                    const manaCost = attackObj.manaCost || 0;
                                    const currentMana = Number(attacker.MANA || 0);
                                    
                                    // Check cooldown
                                    const cooldown = attackObj.cooldown || 0;
                                    const cooldownKey = `${attackObj.name}_${memberKey}`;
                                    const remainingCooldown = attackCooldowns[cooldownKey] || 0;
                                    
                                    if (remainingCooldown > 0) {
                                        logCombat(`âŒ ${attackObj.name} is on cooldown! (${remainingCooldown} turn${remainingCooldown > 1 ? 's' : ''} remaining)`);
                                        return false;
                                    }
                                    
                                    // Check ammo requirement
                                    const requiresAmmo = attackObj.requiresAmmo || false;
                                    const currentAmmo = Number(attacker.AMMO || 0);
                                    
                                    if (requiresAmmo && currentAmmo < 1) {
                                        logCombat(`âŒ Out of ammo! ${attackObj.name} requires 1 ammo (you have ${currentAmmo})`);
                                        return false;
                                    }
                                    
                                    // Check if this is an AOE attack - need to check BEFORE deducting mana
                                    const isAOE = attackObj.aoe === true;
                                    const aliveEnemyCount = isAOE ? Array.from(getEnemyWrappers()).filter(e => Number(e.dataset.hp) > 0).length : 1;
                                    
                                    // AOE attacks cost more mana ONLY if magic-based
                                    // Strength-only attacks (magicMultiplier == 0) do NOT cost mana
                                    let finalManaCost = manaCost;
                                    let finalCooldown = cooldown;
                                    if (isAOE && aliveEnemyCount > 1) {
                                        const strMult = Number(attackObj.strMultiplier || 0);
                                        const magMult = Number(attackObj.magicMultiplier || 0);
                                        const totalMult = strMult + magMult;
                                        const effectiveMult = totalMult * aliveEnemyCount;
                                        // Only apply mana cost if magicMultiplier > 0
                                        if (magMult > 0) {
                                            finalManaCost = Math.round(effectiveMult * 10);
                                        } else {
                                            finalManaCost = 0;
                                        }
                                        // Recalculate cooldown based on effective strength multiplier
                                        if (strMult > 0 && magMult === 0) {
                                            const effectiveStrMult = strMult * aliveEnemyCount;
                                            if (effectiveStrMult <= 1.0) finalCooldown = 0;
                                            else if (effectiveStrMult <= 2.0) finalCooldown = 1;
                                            else if (effectiveStrMult <= 3.0) finalCooldown = 2;
                                            else if (effectiveStrMult <= 4.0) finalCooldown = 3;
                                            else finalCooldown = 4;
                                        }
                                    }
                                    
                                    if (finalManaCost > currentMana) {
                                        logCombat(`âŒ Not enough mana! ${attackObj.name} costs ${finalManaCost} mana (you have ${currentMana})`);
                                        return false;
                                    }
                                    
                                    // Deduct mana cost ONLY if magicMultiplier > 0
                                    if (finalManaCost > 0 && Number(attackObj.magicMultiplier || 0) > 0) {
                                        attacker.MANA = currentMana - finalManaCost;
                                        updatePlayerArea();
                                        if (isAOE && aliveEnemyCount > 1) {
                                            logCombat(`ðŸ’§ AOE mana cost: ${finalManaCost} (${aliveEnemyCount} targets, ${(attackObj.magicMultiplier || 0) * aliveEnemyCount}x effective)`);
                                        }
                                    }
                                    
                                    // Set cooldown for this attack
                                    if (finalCooldown > 0) {
                                        attackCooldowns[cooldownKey] = finalCooldown;
                                        if (isAOE && aliveEnemyCount > 1) {
                                            logCombat(`â³ AOE cooldown: ${finalCooldown} turns (${aliveEnemyCount} targets, ${(attackObj.strMultiplier || 0) * aliveEnemyCount}x effective)`);
                                        }
                                    }
                                    
                                    // Deduct ammo if required
                                    if (requiresAmmo) {
                                        attacker.AMMO = currentAmmo - 1;
                                        updatePlayerArea();
                                        logCombat(`ðŸŽ¯ Ammo used: ${currentAmmo - 1} remaining`);
                                    }
                                    
                                    // Increment ammo generation counter
                                    if (!ammoGenerationCounter[memberKey]) ammoGenerationCounter[memberKey] = 0;
                                    ammoGenerationCounter[memberKey]++;
                                    
                                    // Generate ammo every 2 attacks
                                    if (ammoGenerationCounter[memberKey] >= 2 && Number(attacker.SKILL || 0) > 0) {
                                        attacker.AMMO = Number(attacker.AMMO || 0) + 1;
                                        ammoGenerationCounter[memberKey] = 0;
                                        updatePlayerArea();
                                        logCombat(`ðŸŽ¯ Ammo generated! (${attacker.AMMO} total)`);
                                    }
                                    
                                    const targetEnemies = isAOE ? Array.from(getEnemyWrappers()).filter(e => Number(e.dataset.hp) > 0) : [enemyWrap];
                                    
                                    // Get equipped abilities once before loop
                                    const equippedAbilities = getEquippedAbilities(memberKey);
                                    
                                    if (isAOE) {
                                        logCombat(`ðŸ’¥ ${attackObj.name} - AOE ATTACK hits all enemies!`);
                                    }
                                    
                                    // Loop through all target enemies (single for normal attacks, all for AOE)
                                    targetEnemies.forEach((currentEnemyWrap, targetIndex) => {

                                    const enemyDefense = Number(currentEnemyWrap.dataset.def) || 0;
                                    const attacker = PARTY_STATS[memberKey];
                                    
                                    // Check for attack-specific abilities (10: MultiStrike, 19: Enhance) - only on first target for AOE
                                    const attackSourceItem = targetIndex === 0 ? getItemFromAttack(attackObj) : null;
                                    const attackAbility = (targetIndex === 0 && attackSourceItem) ? attackSourceItem.ability : 0;
                                    console.log(`[Attack Ability] Attack: ${attackObj.name}, ItemName: ${attackObj.itemName}, SourceItem:`, attackSourceItem, `Ability: ${attackAbility}`);
                                    
                                    // Ability 19: Enhance - Each attack enhances stats with decaying multiplier (100%, 90%, 81%, etc.)
                                    if (attackAbility === 19 && attackSourceItem) {
                                        console.log(`[Enhance] Triggered! Count before: ${enhancedStats[memberKey] ? enhancedStats[memberKey].count : 0}`);
                                        
                                        if (!enhancedStats[memberKey]) {
                                            enhancedStats[memberKey] = { count: 0 };
                                        }
                                        
                                        // Calculate decaying multiplier: 100%, 90%, 81%, 72.9%, etc. (0.9^n)
                                        const decayMultiplier = Math.pow(0.9, enhancedStats[memberKey].count);
                                        
                                        // Get stats from the actual attack source item (equipped) - use floats for precision
                                        const strBoost = Number(attackSourceItem.strength || 0) * decayMultiplier;
                                        const magBoost = Number(attackSourceItem.magic || 0) * decayMultiplier;
                                        const spdBoost = Number(attackSourceItem.speed || 0) * decayMultiplier;
                                        const defBoost = Number(attackSourceItem.defense || 0) * decayMultiplier;
                                        const hpBoost = Number(attackSourceItem.health || 0) * decayMultiplier;
                                        
                                        console.log(`[Enhance] Item stats:`, attackSourceItem, `Multiplier: ${decayMultiplier}, Boosts:`, {strBoost, magBoost, spdBoost, defBoost, hpBoost});
                                        console.log(`[Enhance] Stats BEFORE:`, {STR: attacker.STRENGTH, MAG: attacker.MAGIC, SPD: attacker.SPEED, DEF: attacker.DEFENSE, HP: attacker.HEALTH, MAX_HP: attacker.MAX_HEALTH});
                                        
                                        // Always apply enhancement, even if individual stats round to 0
                                        if (strBoost >= 0.01 || magBoost >= 0.01 || spdBoost >= 0.01 || defBoost >= 0.01 || hpBoost >= 0.01) {
                                            // Apply enhancements with floating point precision
                                            attacker.STRENGTH = Number(attacker.STRENGTH || 0) + strBoost;
                                            attacker.MAGIC = Number(attacker.MAGIC || 0) + magBoost;
                                            attacker.SPEED = Number(attacker.SPEED || 0) + spdBoost;
                                            attacker.DEFENSE = Number(attacker.DEFENSE || 0) + defBoost;
                                            attacker.MAX_HEALTH = Number(attacker.MAX_HEALTH || 0) + hpBoost;
                                            attacker.HEALTH = Number(attacker.HEALTH || 0) + hpBoost;
                                            
                                            console.log(`[Enhance] Stats AFTER:`, {STR: attacker.STRENGTH, MAG: attacker.MAGIC, SPD: attacker.SPEED, DEF: attacker.DEFENSE, HP: attacker.HEALTH, MAX_HP: attacker.MAX_HEALTH});
                                            
                                            enhancedStats[memberKey].count++;
                                            
                                            // Update stats display in battle UI
                                            updatePlayerStatsDisplay();
                                            updatePlayerArea();
                                            
                                            const percentBoost = Math.round(decayMultiplier * 100);
                                            const displayStr = strBoost >= 0.5 ? Math.round(strBoost) : strBoost.toFixed(1);
                                            const displayMag = magBoost >= 0.5 ? Math.round(magBoost) : magBoost.toFixed(1);
                                            const displaySpd = spdBoost >= 0.5 ? Math.round(spdBoost) : spdBoost.toFixed(1);
                                            const displayDef = defBoost >= 0.5 ? Math.round(defBoost) : defBoost.toFixed(1);
                                            const displayHp = hpBoost >= 0.5 ? Math.round(hpBoost) : hpBoost.toFixed(1);
                                            logCombat(`âœ¨ Enhance (${percentBoost}%): +${displayStr} STR, +${displayMag} MAG, +${displaySpd} SPD, +${displayDef} DEF, +${displayHp} HP`);
                                        } else {
                                            console.log(`[Enhance] Skipped - all boosts below 0.01`);
                                        }
                                    }
                                    
                                    // Apply Carried multiplier (ability 6) to stats
                                    const carriedMult = getCarriedMultiplier(memberKey);
                                    let str = Number(attacker.STRENGTH||0) * carriedMult;
                                    let mag = Number(attacker.MAGIC||0) * carriedMult;
                                    let spd = Number(attacker.SPEED||0) * carriedMult;
                                    let def = Number(attacker.DEFENSE||0) * carriedMult;
                                    
                                    // Ally support stat buffs
                                    const allyKey = memberKey === activeBattleMember ? activeBattleMember2 : activeBattleMember;
                                    const ally = PARTY_STATS[allyKey];
                                    const allyAbilities = ally && Number(ally.HEALTH) > 0 ? getEquippedAbilities(allyKey) : [];
                                    
                                    // Ability 52: Precognition - Grant ally +10% damage and +10% defense
                                    if (allyAbilities.includes(52)) {
                                        str = str * 1.1;
                                        mag = mag * 1.1;
                                        def = def * 1.1;
                                        if (targetIndex === 0) logCombat(`ðŸ”® Precognition: +10% damage & defense from ally!`);
                                    }
                                    
                                    // Ability 49: Versatility - Share 15% of ally's highest stat
                                    if (allyAbilities.includes(49) && ally) {
                                        const allyStats = [
                                            Number(ally.STRENGTH||0),
                                            Number(ally.MAGIC||0),
                                            Number(ally.SPEED||0),
                                            Number(ally.DEFENSE||0)
                                        ];
                                        const highestStat = Math.max(...allyStats);
                                        const sharedBonus = Math.round(highestStat * 0.15);
                                        str += sharedBonus;
                                        mag += sharedBonus;
                                        if (targetIndex === 0) logCombat(`ðŸ“š Versatility: +${sharedBonus} stats shared from ally!`);
                                    }
                                    
                                    // Ability 51: Balance - Grant both players +20% speed
                                    if (equippedAbilities.includes(51) || allyAbilities.includes(51)) {
                                        spd = spd * 1.2;
                                        if (targetIndex === 0) logCombat(`âš–ï¸ Balance: +20% speed!`);
                                    }
                                    
                                    const strMult = Number(attackObj.strMultiplier||0);
                                    const magMult = Number(attackObj.magicMultiplier||0);
                                    const sklMult = Number(attackObj.skillMultiplier||0);
                                    
                                    // Get skill stat for damage calculation and crit bonus
                                    const skill = Number(attacker.SKILL || 0);
                                    
                                    // Get enemy index for status tracking
                                    const enemyIndex = Array.from(getEnemyWrappers()).indexOf(currentEnemyWrap);
                                    
                    // Apply bleed multiplier if present
                    const bleedMult = getBleedMultiplier('enemy', enemyIndex);
                    
                    // Calculate base damage with MULTIPLICATIVE skill scaling
                    // Formula: (STRÃ—strMult + MAGÃ—magMult) Ã— (1 + SKILLÃ—sklMult) Ã— bleedMult
                    let baseDmg;
                    if (sklMult > 0) {
                        // Ensure sklMult is at least 0.15
                        const effectiveSklMult = Math.max(sklMult, 0.15);
                        // Skill attack: baseStat * (sklMult * skill)
                        let skillDmg = 0;
                        // If both strMult and magMult are present, use both
                        if (strMult > 0 && magMult > 0) {
                            skillDmg = (str * strMult) * (effectiveSklMult * skill) + (mag * magMult) * (effectiveSklMult * skill);
                        } else if (strMult > 0) {
                            skillDmg = (str * strMult) * (effectiveSklMult * skill);
                        } else if (magMult > 0) {
                            skillDmg = (mag * magMult) * (effectiveSklMult * skill);
                        }
                        baseDmg = skillDmg * bleedMult;
                    } else {
                        // Non-skill attack: additive damage
                        baseDmg = (mag * magMult + str * strMult) * bleedMult;
                    }
                    
                    // AOE attacks deal 50% damage to balance multi-target effectiveness
                    if (isAOE) {
                        baseDmg = baseDmg * 0.5;
                    }
                    
                    // Ability 63: Insight - Mark enemy for 15% more damage (permanent for battle)
                    if (equippedAbilities.includes(63) && !insightMarkedEnemies.has(enemyIndex)) {
                        insightMarkedEnemies.add(enemyIndex);
                        logCombat(`ðŸ‘ï¸ Insight: Enemy marked! +15% damage from all sources`);
                    }
                    
                    // Apply Insight damage bonus if enemy is marked
                    if (insightMarkedEnemies.has(enemyIndex)) {
                        baseDmg = baseDmg * 1.15;
                    }
                    
                    // Apply chill effect BEFORE defense: 25% damage reduction if enemy is chilled
                    const enemyEffects = enemyStatusEffects[enemyIndex];
                    if (enemyEffects && enemyEffects.find(e => e.type === 'chill')) {
                        baseDmg = baseDmg * 0.75;
                        logCombat(`â„ï¸ Enemy chilled: -25% damage output`);
                    }
                    
                    // Apply defense with inverted logarithmic scaling (higher multiplier at low defense)
                    // Damage Reduction = Defense * (1.0 - log10(Defense + 1) * 0.05)
                    // This gives very strong early defense that gradually becomes less efficient
                    const defenseMultiplier = Math.max(0.5, 1.0 - (Math.log10(enemyDefense + 1) * 0.05));
                    const damageReduction = enemyDefense * defenseMultiplier;
                    const damageAfterDefense = baseDmg - damageReduction;
                    
                    // Ensure minimum 10% of base damage always gets through
                    const minimumDamage = Math.ceil(baseDmg * 0.1);
                    let dmg = Math.max(minimumDamage, Math.round(damageAfterDefense));
                    if (isNaN(dmg)) dmg = minimumDamage || 1;
                    
                    // Calculate critical hit chance
                    // Skill attacks ALWAYS have crit enabled
                    const isSkillAttack = (attackObj.group === 'skill' || sklMult > 0);
                    const baseCritChance = 0.05; // 5% base
                    const skillCritBonus = skill * 0.003; // +0.3% per skill point
                    const totalCritChance = baseCritChance + skillCritBonus;
                    
                    // Roll for critical hit (all skill attacks can crit)
                    const critRoll = Math.random();
                    const isCriticalHit = isSkillAttack && critRoll < totalCritChance;
                    
                    if (isCriticalHit) {
                        const critMultiplier = 2.0; // 200% damage on crit
                        dmg = Math.round(dmg * critMultiplier);
                        logCombat(`ðŸ’¥ CRITICAL HIT! (${Math.round(totalCritChance * 100)}% chance)`);
                    }
                    
                    // Apply Blood Price damage bonus (ability 73) if active
                    if (typeof bloodPriceDamageBonus !== 'undefined' && bloodPriceDamageBonus > 0) {
                        dmg = dmg + bloodPriceDamageBonus;
                    }
                    
                    // Apply Overcharge damage bonus (ability 76) if mana is above max
                    if (overchargedMana[memberKey] && overchargedMana[memberKey] > 0) {
                        const overchargeDamage = Math.round(overchargedMana[memberKey] * 1.5); // 1.5x damage per overcharged mana
                        dmg = dmg + overchargeDamage;
                        logCombat(`âš¡ Overcharge Bonus: +${overchargeDamage} damage from ${overchargedMana[memberKey]} excess mana!`);
                    }                                    // ===== ITEM ABILITIES =====
                                    // Abilities already loaded before forEach loop
                                    console.log(`[Abilities] Member ${memberKey} equipped abilities:`, equippedAbilities);
                                    
                                    // Ability 13: Pixel Combo - ONLY applies to "Combo" attack from Pixel Sword
                                    let pixelComboMultiplier = 1.0;
                                    const isComboAttack = attackObj.name === 'Combo' || (attackObj.itemName && attackObj.itemName === 'Pixel Sword');
                                    if (equippedAbilities.includes(13) && isComboAttack) {
                                        pixelComboMultiplier = pixelComboCount >= 8 ? 1.0 : 0.5;
                                    }
                                    dmg = Math.round(dmg * pixelComboMultiplier);
                                    
                                    // Ability 7: Overuse - Consecutive attacks deal 200% bonus but 20% recoil
                                    let overuseSelfDamage = 0;
                                    if (equippedAbilities.includes(7)) {
                                        const overuseBonus = Math.round(dmg * 2.0); // 200% bonus
                                        dmg += overuseBonus;
                                        overuseSelfDamage = Math.round(dmg * 0.2); // 20% recoil
                                        overuseConsecutive++;
                                        logCombat(`âš”ï¸ Overuse: +${overuseBonus} damage (200% bonus)`);
                                    } else {
                                        overuseConsecutive = 0;
                                    }
                                    
                                    // Ability 2: Coral - Consecutive attacks deal bonus damage (20% per turn, max 80%)
                                    if (equippedAbilities.includes(2)) {
                                        const coralBonus = Math.min(consecutiveAttacks * 0.2, 0.8); // Max 80%
                                        if (coralBonus > 0) {
                                            const bonusDmg = Math.round(dmg * coralBonus);
                                            dmg += bonusDmg;
                                            logCombat(`ðŸŒŠ Coral Bonus: +${bonusDmg} damage (${Math.round(coralBonus * 100)}%)`);
                                        }
                                        consecutiveAttacks++;
                                    } else {
                                        consecutiveAttacks = 0; // Reset if coral not equipped
                                    }
                                    
                                    // Ability 6: Carried - Log if multiplier is active
                                    if (equippedAbilities.includes(6) && carriedMult !== 1.0) {
                                        const aliveCount = countAlivePartyMembers();
                                        logCombat(`ðŸ‘¥ Carried: ${aliveCount} allies (${Math.round((carriedMult - 1) * 100)}% stat bonus)`);
                                    }
                                    
                                    // Ability 17: Perfectly Timed - 50% chance to critically strike for 150% damage
                                    if (equippedAbilities.includes(17)) {
                                        const critRoll = Math.random();
                                        if (critRoll < 0.5) {
                                            const critBonus = Math.round(dmg * 0.5);
                                            dmg += critBonus;
                                            logCombat(`ðŸ’¥ CRITICAL STRIKE! +${critBonus} damage (150% total)`);
                                            console.log(`[Perfectly Timed] Critical strike! Roll: ${critRoll.toFixed(3)} < 0.5 | Bonus: ${critBonus} | Total damage: ${dmg}`);
                                        } else {
                                            console.log(`[Perfectly Timed] No crit. Roll: ${critRoll.toFixed(3)} >= 0.5`);
                                        }
                                    }
                                    
                                    // ===== NEW SET 2 ABILITIES (22-46) =====
                                    
                                    // Ability 22: Fury - Deal +10% damage per 10% HP missing (max +90% at 10% HP)
                                    if (equippedAbilities.includes(22)) {
                                        const hpPercent = Number(attacker.HEALTH || 0) / Number(attacker.MAX_HEALTH || 1);
                                        const hpMissing = Math.max(0, 1.0 - hpPercent);
                                        const furyBonus = Math.min(0.9, hpMissing * 0.9); // 10% per 10% missing, max 90%
                                        if (furyBonus > 0) {
                                            const bonusDmg = Math.round(dmg * furyBonus);
                                            dmg += bonusDmg;
                                            logCombat(`ðŸ˜¡ Fury: +${bonusDmg} damage (${Math.round(furyBonus * 100)}% at ${Math.round(hpPercent * 100)}% HP)`);
                                        }
                                    }
                                    
                                    // Ability 24: Execute - Deal 300% damage to enemies below 25% HP
                                    const enemyHpPercent = Number(currentEnemyWrap.dataset.hp) / Number(currentEnemyWrap.dataset.maxHp || 1);
                                    if (equippedAbilities.includes(24) && enemyHpPercent < 0.25) {
                                        const executeBonus = Math.round(dmg * 2.0); // 200% bonus = 300% total
                                        dmg += executeBonus;
                                        logCombat(`âš¡ EXECUTE! +${executeBonus} damage (enemy below 25% HP)`);
                                    }
                                    
                                    // Ability 29: Corruption - Deal +50% damage to enemies with status effects
                                    const targetEffects2 = enemyStatusEffects[enemyIndex] || [];
                                    if (equippedAbilities.includes(29) && targetEffects2.length > 0) {
                                        const corruptionBonus = Math.round(dmg * 0.5);
                                        dmg += corruptionBonus;
                                        logCombat(`â˜ ï¸ Corruption: +${corruptionBonus} damage (${targetEffects2.length} status effects)`);
                                    }
                                    
                                    // Ability 32: Berserker - Gain +5% damage per consecutive attack (max +50%)
                                    if (equippedAbilities.includes(32)) {
                                        if (!window.berserkerStacks) window.berserkerStacks = {};
                                        if (!window.berserkerStacks[memberKey]) window.berserkerStacks[memberKey] = 0;
                                        
                                        window.berserkerStacks[memberKey] = Math.min(10, window.berserkerStacks[memberKey] + 1);
                                        const berserkerBonus = window.berserkerStacks[memberKey] * 0.05; // 5% per stack, max 50%
                                        if (berserkerBonus > 0) {
                                            const bonusDmg = Math.round(dmg * berserkerBonus);
                                            dmg += bonusDmg;
                                            logCombat(`ðŸ”¥ Berserker: +${bonusDmg} damage (${window.berserkerStacks[memberKey]} stacks, ${Math.round(berserkerBonus * 100)}%)`);
                                        }
                                    }
                                    
                                    // Ability 40: Critical Mass - Every 5th attack deals 400% damage
                                    if (equippedAbilities.includes(40)) {
                                        if (!window.criticalMassCount) window.criticalMassCount = {};
                                        if (!window.criticalMassCount[memberKey]) window.criticalMassCount[memberKey] = 0;
                                        
                                        window.criticalMassCount[memberKey]++;
                                        if (window.criticalMassCount[memberKey] >= 5) {
                                            const massBonus = Math.round(dmg * 3.0); // 300% bonus = 400% total
                                            dmg += massBonus;
                                            logCombat(`ðŸ’¥ CRITICAL MASS! +${massBonus} damage (5th attack!)`);
                                            window.criticalMassCount[memberKey] = 0;
                                        }
                                    }
                                    
                                    // Ability 44: Reaper - Deal bonus damage equal to 5% of enemy max HP
                                    if (equippedAbilities.includes(44)) {
                                        const reaperBonus = Math.round(Number(currentEnemyWrap.dataset.maxHp || 0) * 0.05);
                                        dmg += reaperBonus;
                                        logCombat(`ðŸ’€ Reaper: +${reaperBonus} damage (5% enemy max HP)`);
                                    }
                                    
                                    // Special Attack: Plague Strike - Bonus damage per status effect on target
                                    if (attackObj.statusBonus === true) {
                                        const targetEffects = enemyStatusEffects[enemyIndex] || [];
                                        const statusCount = targetEffects.length;
                                        console.log('[Plague Strike] Enemy index:', enemyIndex, 'Status effects:', targetEffects, 'Count:', statusCount);
                                        if (statusCount > 0) {
                                            const plagueBonus = Math.round(dmg * 0.3 * statusCount); // 30% per status
                                            dmg += plagueBonus;
                                            logCombat(`â˜ ï¸ Plague Strike: +${plagueBonus} damage (${statusCount} status effect${statusCount !== 1 ? 's' : ''})`);
                                        } else {
                                            logCombat(`â˜ ï¸ Plague Strike: No status effects on target for bonus damage`);
                                        }
                                    }
                                    
                                    // Special Attack: Soul Reaper - Bonus damage per dead ally
                                    if (attackObj.deadAllyBonus === true) {
                                        const totalAllies = 5;
                                        const aliveAllies = countAlivePartyMembers();
                                        const deadAllies = totalAllies - aliveAllies;
                                        if (deadAllies > 0) {
                                            const reaperBonus = Math.round(dmg * 0.5 * deadAllies); // 50% per dead ally
                                            dmg += reaperBonus;
                                            logCombat(`ðŸ’€ Soul Reaper: +${reaperBonus} damage (${deadAllies} fallen allies)`);
                                        }
                                    }
                                    
                                    // Play attack sound effect
                                    const musicEnabled = localStorage.getItem('musicEnabled') === 'true';
                                    if (musicEnabled) {
                                        const attackSound = new Audio('audio/soundEffects/attack.wav');
                                        attackSound.volume = 0.5;
                                        attackSound.play().catch(err => console.log('Could not play attack sound:', err));
                                    }

                                    logCombat(`Player uses ${attackObj.name} on ${currentEnemyWrap.querySelector('img').alt} and deals ${dmg} damage${bleedMult > 1 ? ' (BLEED +' + Math.round((bleedMult - 1) * 100) + '%)' : ''}`);
                                    
                                    // Show damage popup on enemy
                                    const enemyImg = currentEnemyWrap.querySelector('img');
                                    if (enemyImg) {
                                        showDamagePopup(enemyImg, dmg);
                                    }
                                    
                                    // Special Attack: Venomous Barrage - Multi-hit attack
                                    if (attackObj.multiHit && attackObj.multiHit > 1) {
                                        const additionalHits = attackObj.multiHit - 1; // First hit already dealt
                                        for (let i = 0; i < additionalHits; i++) {
                                            // Each additional hit deals damage and applies status
                                            const hitDmg = Math.round(dmg * 0.8); // 80% damage per additional hit
                                            currentEnemyWrap.dataset.hp = Math.max(0, Number(currentEnemyWrap.dataset.hp) - hitDmg);
                                            updateEnemyBar(currentEnemyWrap);
                                            logCombat(`ðŸ Venomous Barrage hit ${i + 2}: ${hitDmg} damage`);
                                            
                                            // Show damage popup for additional hits
                                            if (enemyImg) {
                                                setTimeout(() => showDamagePopup(enemyImg, hitDmg), (i + 1) * 250);
                                            }
                                            
                                            // Apply status effect for each hit
                                            const attackStatus = attackObj.statusEffect || attackObj.status;
                                            if (attackStatus && attackStatus !== 'none') {
                                                applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, attackStatus, baseDmg);
                                            }
                                        }
                                    }
                                    
                                    // Apply status effect from attack (use baseDmg for burn to bypass defense)
                                    // Check both 'status' (from ATTACK_STATS) and 'statusEffect' (from SPECIAL_ATTACKS)
                                    const attackStatus = attackObj.statusEffect || attackObj.status;
                                    if (attackStatus && attackStatus !== 'none') {
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, attackStatus, baseDmg);
                                    }
                                    
                                    // Ability 1: Bleed - Each attack gives bleed status (can stack with attack's bleed)
                                    if (equippedAbilities.includes(1)) {
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'bleed', baseDmg);
                                        logCombat('ðŸ©¸ Bleed ability activated!');
                                    }
                                    
                                    // Ability 5: Plasma - Every attack grants random status effect
                                    if (equippedAbilities.includes(5)) {
                                        const plasmaStatuses = ['burn', 'leech', 'bleed', 'grim', 'chill'];
                                        const randomStatus = plasmaStatuses[Math.floor(Math.random() * plasmaStatuses.length)];
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, randomStatus, baseDmg);
                                        logCombat(`âš¡ Plasma: Applied ${randomStatus}!`);
                                    }
                                    
                                    // Ability 72: Tri-Element - Apply burn+chill+stun ONLY on first attack with item
                                    if (equippedAbilities.includes(72) && !triElementUsedBy.has(memberKey)) {
                                        triElementUsedBy.add(memberKey);
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'burn', baseDmg);
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'chill', baseDmg);
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'stun', baseDmg);
                                        logCombat(`ðŸ”¥â„ï¸ðŸ’« Tri-Element: Applied burn, chill, AND stun! (first use only)`);
                                    }
                                    
                                    // Ability 8: Burn - Set ground aflame (35% magic damage per turn)
                                    if (equippedAbilities.includes(8)) {
                                        const burnDmg = Math.round(Number(attacker.MAGIC||0) * 0.35);
                                        burnGroundEffects[enemyIndex] = { duration: 3, damage: burnDmg };
                                        logCombat(`ðŸ”¥ Burn: Ground aflame! ${burnDmg} damage/turn for 3 turns`);
                                    }
                                    
                                    // Ability 12: After Shock - Next enemy attack ignored (2 turn cooldown)
                                    if (equippedAbilities.includes(12) && afterShockCooldown === 0) {
                                        afterShockActive = true;
                                        afterShockCooldown = 2;
                                        logCombat(`âš¡ After Shock: Next enemy attack will be ignored!`);
                                    }
                                    
                                    // Apply Overuse self-damage
                                    if (overuseSelfDamage > 0) {
                                        attacker.HEALTH = Math.max(1, Number(attacker.HEALTH) - overuseSelfDamage);
                                        updatePlayerArea();
                                        logCombat(`ðŸ’” Overuse recoil: ${overuseSelfDamage} self-damage`);
                                    }
                                    
                                    // Decrement bleed duration
                                    decrementBleed('enemy', enemyIndex);
                                    
                                    // Always apply damage to enemy when attacking
                                    const curHp = Number(currentEnemyWrap.dataset.hp) - dmg;
                                    currentEnemyWrap.dataset.hp = Math.max(0, curHp);
                                    updateEnemyBar(currentEnemyWrap);
                                    
                                    // Check for Lifesteal enchantment on equipped items
                                    let hasLifesteal = false;
                                    // memberKey already defined in outer scope
                                    const member = PARTY_STATS[memberKey];
                                    if (member) {
                                        const slots = ['HELMET', 'CHEST', 'LEGS', 'BOOTS', 'MAINHAND', 'OFFHAND'];
                                        for (const slot of slots) {
                                            const itemName = member[slot];
                                            if (itemName) {
                                                const item = INVENTORY.find(i => i.name === itemName && i.equipped);
                                                if (item && item.enchantment === 'Lifesteal') {
                                                    hasLifesteal = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Apply Lifesteal: Heal for 10% of damage dealt (post-defense)
                                    if (hasLifesteal) {
                                        const healAmount = Math.ceil(dmg * 0.1);
                                        const currentHealth = Number(attacker.HEALTH || 0);
                                        const maxHealth = Number(attacker.MAX_HEALTH || 1);
                                        const newHealth = Math.min(maxHealth, currentHealth + healAmount);
                                        attacker.HEALTH = newHealth;
                                        updatePlayerArea();
                                        logCombat(`ðŸ’‰ Lifesteal: Healed ${healAmount} HP (${newHealth}/${maxHealth})`);
                                        
                                        // Add healing animation
                                        const playerImgId = (memberKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                        const playerImg = document.getElementById(playerImgId);
                                        if (playerImg) {
                                            playerImg.classList.add('healing');
                                            setTimeout(() => playerImg.classList.remove('healing'), 500);
                                        }
                                    }
                                    
                                    // Ability 31: Life Drain - Heal 20% of damage dealt
                                    if (equippedAbilities.includes(31)) {
                                        const drainAmount = Math.ceil(dmg * 0.2);
                                        const currentHealth = Number(attacker.HEALTH || 0);
                                        const maxHealth = Number(attacker.MAX_HEALTH || 1);
                                        const newHealth = Math.min(maxHealth, currentHealth + drainAmount);
                                        attacker.HEALTH = newHealth;
                                        updatePlayerArea();
                                        
                                        // Add healing animation
                                        const playerImgId = (memberKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                        const playerImg = document.getElementById(playerImgId);
                                        if (playerImg) {
                                            playerImg.classList.add('healing');
                                            setTimeout(() => playerImg.classList.remove('healing'), 500);
                                        }
                                        logCombat(`ðŸ©¸ Life Drain: Healed ${drainAmount} HP (${newHealth}/${maxHealth})`);
                                    }
                                    
                                    // Ability 67: Siphon - Steal random stat (STR/MAG/SPD/DEF only, not Health) for 2 turns
                                    if (equippedAbilities.includes(67)) {
                                        const siphonableStats = ['STR', 'MAG', 'SPD', 'DEF'];
                                        const randomStat = siphonableStats[Math.floor(Math.random() * siphonableStats.length)];
                                        const siphonAmount = Math.ceil(currentEnemyWrap.dataset[randomStat.toLowerCase()] * 0.1);
                                        
                                        // Apply stat reduction to enemy
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'siphon-' + randomStat.toLowerCase(), siphonAmount);
                                        
                                        // Boost player stat temporarily
                                        if (!enhancedStats[memberKey]) enhancedStats[memberKey] = {};
                                        const statMap = {STR: 'STRENGTH', MAG: 'MAGIC', SPD: 'SPEED', DEF: 'DEFENSE'};
                                        const fullStatName = statMap[randomStat];
                                        attacker[fullStatName] = Number(attacker[fullStatName] || 0) + siphonAmount;
                                        updatePlayerArea();
                                        
                                        logCombat(`ðŸŒ€ Siphon: Stole ${siphonAmount} ${randomStat} for 2 turns!`);
                                    }
                                    
                                    // Ability 97: Knockback (Hand Cannon) - Stun enemy for 1 turn
                                    if (equippedAbilities.includes(97)) {
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'stun', dmg);
                                        logCombat(`ðŸ’« Knockback: Enemy stunned for 1 turn!`);
                                    }
                                    
                                    // Ability 103: Arcane Bullets - Absorb entire mana bar, damage capped at 100 mana
                                    if (equippedAbilities.includes(103) && Number(attacker.MANA || 0) > 0) {
                                        const manaAbsorbed = Number(attacker.MANA);
                                        const manaForDamage = Math.min(manaAbsorbed, 100);
                                        const bonusDamage = Math.round(manaForDamage * 2); // 2x damage per mana point
                                        
                                        attacker.MANA = 0;
                                        updatePlayerArea();
                                        
                                        dmg = dmg + bonusDamage;
                                        currentEnemyWrap.dataset.hp = Math.max(0, Number(currentEnemyWrap.dataset.hp) - bonusDamage);
                                        updateEnemyBar(currentEnemyWrap);
                                        
                                        logCombat(`âœ¨ Arcane Bullets: Absorbed ${manaAbsorbed} mana, +${bonusDamage} bonus damage (capped at 100 mana)`);
                                    }
                                    
                                    // Ability 84: Soul Shackles - 15% stat reduction to enemy (no ability suppression)
                                    if (equippedAbilities.includes(84)) {
                                        const statReduction = 0.15;
                                        currentEnemyWrap.dataset.str = Math.round(Number(currentEnemyWrap.dataset.str || 0) * (1 - statReduction));
                                        currentEnemyWrap.dataset.mag = Math.round(Number(currentEnemyWrap.dataset.mag || 0) * (1 - statReduction));
                                        currentEnemyWrap.dataset.spd = Math.round(Number(currentEnemyWrap.dataset.spd || 0) * (1 - statReduction));
                                        currentEnemyWrap.dataset.def = Math.round(Number(currentEnemyWrap.dataset.def || 0) * (1 - statReduction));
                                        logCombat(`â›“ï¸ Soul Shackles: Enemy stats reduced by 15%!`);
                                    }
                                    
                                    // Ability 85: Dual Strike - ONLY applies to Dual Revolvers attack (Double Shot)
                                    if (equippedAbilities.includes(85) && attackObj.name === 'Double Shot' && Number(currentEnemyWrap.dataset.hp) > 0) {
                                        // Second strike with Dual Revolvers
                                        const str2 = Number(attacker.STRENGTH || 0) * carriedMult;
                                        const mag2 = Number(attacker.MAGIC || 0) * carriedMult;
                                        const skill2 = Number(attacker.SKILL || 0);
                                        const bleedMult2 = getBleedMultiplier('enemy', enemyIndex);
                                        let dmg2 = Math.round((str2 * strMult + mag2 * magMult + skill2 * sklMult) * bleedMult2);
                                        
                                        // Apply defense
                                        const defMult2 = Math.max(0.5, 1.0 - (Math.log10(enemyDefense + 1) * 0.05));
                                        const dmgReduction2 = enemyDefense * defMult2;
                                        dmg2 = Math.max(Math.ceil((str2 * strMult + mag2 * magMult + skill2 * sklMult) * bleedMult2 * 0.1), Math.round((str2 * strMult + mag2 * magMult + skill2 * sklMult) * bleedMult2 - dmgReduction2));
                                        
                                        currentEnemyWrap.dataset.hp = Math.max(0, Number(currentEnemyWrap.dataset.hp) - dmg2);
                                        updateEnemyBar(currentEnemyWrap);
                                        logCombat(`ðŸ”«ðŸ”« Dual Strike: Second shot deals ${dmg2} damage!`);
                                    }
                                    
                                    // Ability 88: Gravity Hammer (Gravity Well item) - Multi-hit up to 3 enemies
                                    if (equippedAbilities.includes(88)) {
                                        const allEnemies = Array.from(getEnemyWrappers()).filter(e => Number(e.dataset.hp) > 0);
                                        const additionalTargets = allEnemies.filter(e => e !== currentEnemyWrap).slice(0, 2); // Up to 2 more
                                        
                                        additionalTargets.forEach((extraEnemy, idx) => {
                                            const extraEnemyIdx = Array.from(getEnemyWrappers()).indexOf(extraEnemy);
                                            const extraDef = Number(extraEnemy.dataset.def || 0);
                                            const extraBleedMult = getBleedMultiplier('enemy', extraEnemyIdx);
                                            
                                            // 60% damage to additional targets
                                            let extraDmg = Math.round((str * strMult + mag * magMult + skill * sklMult) * extraBleedMult * 0.6);
                                            const extraDefMult = Math.max(0.5, 1.0 - (Math.log10(extraDef + 1) * 0.05));
                                            const extraDmgReduction = extraDef * extraDefMult;
                                            extraDmg = Math.max(Math.ceil(extraDmg * 0.1), Math.round(extraDmg - extraDmgReduction));
                                            
                                            extraEnemy.dataset.hp = Math.max(0, Number(extraEnemy.dataset.hp) - extraDmg);
                                            updateEnemyBar(extraEnemy);
                                            logCombat(`ðŸŒ€ Gravity Hammer: Hit enemy ${idx + 2} for ${extraDmg} damage!`);
                                        });
                                    }
                                    
                                    // Ability 95: Speed Force - Divide damage by attack count, level-scaled speed requirement
                                    if (equippedAbilities.includes(95)) {
                                        // Calculate required speed: 10 Ã— level scale factor
                                        const levelScaleFactor = (1 + (PARTY_STATS[memberKey].LEVEL || 1) * 0.05);
                                        const requiredSpeed = Math.round(10 * levelScaleFactor);
                                        const currentSpeed = Number(attacker.SPEED || 0);
                                        
                                        if (currentSpeed >= requiredSpeed) {
                                            // Calculate number of attacks based on speed (1 per required speed)
                                            const attackCount = Math.floor(currentSpeed / requiredSpeed);
                                            const damagePerHit = Math.ceil(dmg / attackCount);
                                            
                                            logCombat(`âš¡ Speed Force: ${attackCount} rapid strikes! (${requiredSpeed} speed each)`);
                                            
                                            // Apply damage in multiple hits
                                            for (let i = 1; i < attackCount; i++) {
                                                if (Number(currentEnemyWrap.dataset.hp) <= 0) break;
                                                
                                                currentEnemyWrap.dataset.hp = Math.max(0, Number(currentEnemyWrap.dataset.hp) - damagePerHit);
                                                updateEnemyBar(currentEnemyWrap);
                                                logCombat(`âš¡ Strike ${i + 1}: ${damagePerHit} damage`);
                                            }
                                            
                                            // First hit already counted in main damage
                                            dmg = damagePerHit;
                                        } else {
                                            logCombat(`âš¡ Speed Force: Insufficient speed (need ${requiredSpeed}, have ${currentSpeed})`);
                                        }
                                    }
                                    
                                    // Ability 33: Arcane Surge - Casting magic restores 10% of mana cost
                                    if (equippedAbilities.includes(33) && magMult > 0 && manaCost > 0) {
                                        const manaRestore = Math.ceil(manaCost * 0.1);
                                        attacker.MANA = Math.min(Number(attacker.MAX_MANA || 100), Number(attacker.MANA || 0) + manaRestore);
                                        updatePlayerArea();
                                        logCombat(`ðŸ”® Arcane Surge: Restored ${manaRestore} mana`);
                                    }
                                    
                                    // Ability 35: Frozen Heart - 40% chance to freeze enemies hit for 1 turn
                                    if (equippedAbilities.includes(35) && Math.random() < 0.4) {
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'chill', baseDmg);
                                        logCombat(`â„ï¸ Frozen Heart: Enemy frozen!`);
                                    }
                                    
                                    // Ability 39: Mana Burn - Physical attacks drain 20% of enemy max mana
                                    if (equippedAbilities.includes(39) && strMult > 0) {
                                        const manaBurn = Math.ceil(Number(currentEnemyWrap.dataset.maxMana || 100) * 0.2);
                                        currentEnemyWrap.dataset.mana = Math.max(0, Number(currentEnemyWrap.dataset.mana || 0) - manaBurn);
                                        logCombat(`ðŸ”¥ Mana Burn: Drained ${manaBurn} enemy mana`);
                                    }
                                    
                                    // Ability 43: Elemental Chaos - Attacks randomly deal fire, ice, or lightning damage (+30%)
                                    if (equippedAbilities.includes(43)) {
                                        const elements = ['burn', 'chill', 'bleed'];
                                        const randomElement = elements[Math.floor(Math.random() * elements.length)];
                                        const chaosBonus = Math.round(dmg * 0.3);
                                        dmg += chaosBonus;
                                        applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, randomElement, baseDmg);
                                        const elementNames = {burn: 'ðŸ”¥ Fire', chill: 'â„ï¸ Ice', bleed: 'âš¡ Lightning'};
                                        logCombat(`ðŸŒ€ Elemental Chaos: ${elementNames[randomElement]} +${chaosBonus} damage!`);
                                    }
                                    
                                    // Ability 25: Meteor Strike - 20% chance to deal 200% AOE damage to all enemies
                                    if (equippedAbilities.includes(25) && Math.random() < 0.2 && !isAOE) {
                                        logCombat(`â˜„ï¸ METEOR STRIKE! AOE explosion hits all enemies!`);
                                        const allEnemies = Array.from(getEnemyWrappers()).filter(e => Number(e.dataset.hp) > 0);
                                        allEnemies.forEach((meteEnemy, meteIndex) => {
                                            if (meteEnemy !== currentEnemyWrap) {
                                                const meteorDmg = Math.round(dmg * 2.0); // 200% of original damage
                                                const meteHp = Number(meteEnemy.dataset.hp);
                                                meteEnemy.dataset.hp = Math.max(0, meteHp - meteorDmg);
                                                updateEnemyBar(meteEnemy);
                                                logCombat(`â˜„ï¸ Meteor hits for ${meteorDmg} damage!`);
                                                
                                                // Check if enemy was defeated and trigger necromancer resurrection
                                                if (Number(meteEnemy.dataset.hp) <= 0) {
                                                    logCombat('Enemy defeated!');
                                                    handleEnemyDefeat(meteEnemy, meteIndex);
                                                }
                                            }
                                        });
                                    }
                                    
                                    // Ability 36: Thunder God - Lightning attacks chain to 2 random enemies for 50% damage
                                    if (equippedAbilities.includes(36) && magMult > 0 && !isAOE) {
                                        const allEnemies = Array.from(getEnemyWrappers()).filter(e => 
                                            Number(e.dataset.hp) > 0 && e !== currentEnemyWrap
                                        );
                                        const chainTargets = allEnemies.sort(() => Math.random() - 0.5).slice(0, 2);
                                        chainTargets.forEach((chainEnemy) => {
                                            const chainDmg = Math.round(dmg * 0.5);
                                            const chainHp = Number(chainEnemy.dataset.hp);
                                            chainEnemy.dataset.hp = Math.max(0, chainHp - chainDmg);
                                            updateEnemyBar(chainEnemy);
                                            logCombat(`âš¡ Thunder chain: ${chainDmg} damage!`);
                                        });
                                    }
                                    
                                    // Ability 23: Temporal Shift - 30% chance to take two turns in a row
                                    if (equippedAbilities.includes(23) && Math.random() < 0.3) {
                                        if (!window.temporalShiftActive) window.temporalShiftActive = {};
                                        window.temporalShiftActive[memberKey] = true;
                                        logCombat(`â° TEMPORAL SHIFT: ${attacker.NAME} will attack again!`);
                                    }
                                    
                                    // Ability 41: Time Warp - Reduce all cooldowns by 1 turn when attacking
                                    if (equippedAbilities.includes(41)) {
                                        if (afterShockCooldown > 0) {
                                            afterShockCooldown = Math.max(0, afterShockCooldown - 1);
                                            logCombat(`âŒ› Time Warp: Cooldowns reduced!`);
                                        }
                                    }
                                    
                                    // Ability 46: Apocalypse - Deal 150% damage to all enemies when HP drops below 20%
                                    const playerHpPercent = Number(attacker.HEALTH || 0) / Number(attacker.MAX_HEALTH || 1);
                                    if (equippedAbilities.includes(46) && playerHpPercent < 0.2 && !isAOE) {
                                        if (!window.apocalypseTriggered) window.apocalypseTriggered = {};
                                        if (!window.apocalypseTriggered[memberKey]) {
                                            window.apocalypseTriggered[memberKey] = true;
                                            logCombat(`ðŸ’€ APOCALYPSE ACTIVATED!`);
                                            const allEnemies = Array.from(getEnemyWrappers()).filter(e => Number(e.dataset.hp) > 0);
                                            allEnemies.forEach((apoEnemy) => {
                                                const apoDmg = Math.round(dmg * 1.5);
                                                const apoHp = Number(apoEnemy.dataset.hp);
                                                apoEnemy.dataset.hp = Math.max(0, apoHp - apoDmg);
                                                updateEnemyBar(apoEnemy);
                                                logCombat(`ðŸ’€ Apocalypse: ${apoDmg} damage to all enemies!`);
                                            });
                                        }
                                    }
                                    
                                    // Tree People multi-hit: Attacks once per alive party member (plus multistrike bonus)
                                    const isTreePeopleAttack = attackObj.name === 'Tree People';
                                    if (isTreePeopleAttack && Number(currentEnemyWrap.dataset.hp) > 0) {
                                        // Count alive party members
                                        let aliveCount = 0;
                                        ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE'].forEach(m => {
                                            const memberStats = PARTY_STATS[m];
                                            if (memberStats && Number(memberStats.HEALTH || 0) > 0) {
                                                aliveCount++;
                                            }
                                        });
                                        
                                        console.log(`[Tree People] Alive party members: ${aliveCount}`, PARTY_STATS);
                                        
                                        // Start at 1 because we already hit once, subtract 1 from alive count
                                        let extraHits = Math.max(0, aliveCount - 1);
                                        
                                        // Add 1 extra hit if MultiStrike ability is active
                                        const hasMultiStrike = attackAbility === 10 && attackSourceItem;
                                        if (hasMultiStrike) {
                                            extraHits += 1;
                                            logCombat(`ðŸŒ³âš”ï¸ Tree People + MultiStrike: ${aliveCount + 1} total strikes!`);
                                        } else {
                                            logCombat(`ðŸŒ³ Tree People: ${aliveCount} strike${aliveCount !== 1 ? 's' : ''} (one per alive member)`);
                                        }
                                        
                                        // Execute extra hits
                                        for (let i = 0; i < extraHits; i++) {
                                            if (Number(currentEnemyWrap.dataset.hp) <= 0) break; // Stop if enemy dies
                                            
                                            // Recalculate damage for each hit
                                            const strHit = Number(attacker.STRENGTH||0) * carriedMult;
                                            const magHit = Number(attacker.MAGIC||0) * carriedMult;
                                            const bleedMultHit = getBleedMultiplier('enemy', enemyIndex);
                                            let baseDmgHit = (magHit * magMult + strHit * strMult) * bleedMultHit;
                                            
                                            // Apply chill if present
                                            const enemyEffectsHit = enemyStatusEffects[enemyIndex];
                                            if (enemyEffectsHit && enemyEffectsHit.find(e => e.type === 'chill')) {
                                                baseDmgHit = baseDmgHit * 0.75;
                                            }
                                            
                                            // Apply defense
                                            const defenseMultiplier = Math.max(0.5, 1.0 - (Math.log10(enemyDefense + 1) * 0.05));
                                            const damageReduction = enemyDefense * defenseMultiplier;
                                            const damageAfterDefense = baseDmgHit - damageReduction;
                                            const minimumDamage = Math.ceil(baseDmgHit * 0.1);
                                            let dmgHit = Math.max(minimumDamage, Math.round(damageAfterDefense));
                                            if (isNaN(dmgHit)) dmgHit = minimumDamage || 1;
                                            
                                            // Apply damage
                                            const curHpHit = Number(currentEnemyWrap.dataset.hp) - dmgHit;
                                            currentEnemyWrap.dataset.hp = Math.max(0, curHpHit);
                                            updateEnemyBar(currentEnemyWrap);
                                            logCombat(`ðŸŒ³ Strike ${i + 2}: ${dmgHit} damage!`);
                                            
                                            // Apply leech status on each hit
                                            applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, 'leech', dmgHit);
                                        }
                                    }
                                    
                                    // Ability 10: MultiStrike - Attack twice ONLY with this specific attack (skip if Tree People already handled it)
                                    const isMultiStrikeAttack = !isTreePeopleAttack && attackAbility === 10 && attackSourceItem;
                                    if (isMultiStrikeAttack && Number(currentEnemyWrap.dataset.hp) > 0) {
                                        // Recalculate damage for second strike (same formula)
                                        const str2 = Number(attacker.STRENGTH||0) * carriedMult;
                                        const mag2 = Number(attacker.MAGIC||0) * carriedMult;
                                        const bleedMult2 = getBleedMultiplier('enemy', enemyIndex);
                                        let dmg2 = Math.round((mag2 * magMult + str2 * strMult - enemyDefense) * bleedMult2);
                                        if (isNaN(dmg2) || dmg2 < 1) dmg2 = 1;
                                        
                                        const curHp2 = Number(currentEnemyWrap.dataset.hp) - dmg2;
                                        currentEnemyWrap.dataset.hp = Math.max(0, curHp2);
                                        updateEnemyBar(currentEnemyWrap);
                                        logCombat(`âš”ï¸âš”ï¸ MultiStrike: Second hit deals ${dmg2} damage!`);
                                        
                                        // Apply attack status on second hit too
                                        const attackStatus = attackObj.statusEffect || attackObj.status;
                                        if (attackStatus && attackStatus !== 'none') {
                                            applyStatusEffect(currentEnemyWrap, 'enemy', enemyIndex, attackStatus, dmg2);
                                        }
                                    }

                                                // Play hit animation on the enemy image
                                                try {
                                                    const img = currentEnemyWrap.querySelector('img');
                                                    if (img) {
                                                        img.classList.remove('hit-animation');
                                                        // Force reflow to restart animation
                                                        void img.offsetWidth;
                                                        img.classList.add('hit-animation');
                                                        setTimeout(()=> img.classList.remove('hit-animation'), 700);
                                                    }
                                                } catch(e){}

                                    // Check if this enemy dies
                                    if (Number(currentEnemyWrap.dataset.hp) <= 0) {
                                        const enemyName = currentEnemyWrap.querySelector('img') ? currentEnemyWrap.querySelector('img').alt : '';
                                        const enemyKey = currentEnemyWrap.dataset.key || enemyName;
                                        
                                        // Check if this is Divine King (phase 1) - transform to phase 2
                                        const isDivineKing = enemyName.toLowerCase().includes('divineking') || 
                                                           (currentEnemyWrap.dataset.key && currentEnemyWrap.dataset.key.toLowerCase() === 'divineking');
                                        
                                        // Check if this is a crawler with two lives
                                        const isCrawler = enemyKey.toLowerCase().includes('crawler');
                                        const crawlerFirstLife = !currentEnemyWrap.dataset.crawlerSecondForm;
                                        
                                        // Crawler mechanic: Transform to second form on first death
                                        if (isCrawler && crawlerFirstLife) {
                                            logCombat('ðŸ¦Ž Crawler survives! Transforming to frenzied form!');
                                            
                                            const crawlerStats = ENEMY_BASE_STATS['crawler'];
                                            if (crawlerStats && crawlerStats.secondForm) {
                                                const level = battleData.level || 1;
                                                const baseScale = Math.pow(level, 0.9);
                                                const scaleMultiplier = baseScale;
                                                
                                                const secondForm = crawlerStats.secondForm;
                                                currentEnemyWrap.dataset.hp = Math.max(1, Math.round(secondForm.health * scaleMultiplier));
                                                currentEnemyWrap.dataset.maxHp = currentEnemyWrap.dataset.hp;
                                                currentEnemyWrap.dataset.str = Math.round(secondForm.strength * scaleMultiplier);
                                                currentEnemyWrap.dataset.mag = Math.round(secondForm.magic * scaleMultiplier);
                                                currentEnemyWrap.dataset.speed = Math.round(secondForm.speed * scaleMultiplier);
                                                currentEnemyWrap.dataset.def = 0; // No defense in second form
                                                currentEnemyWrap.dataset.crawlerSecondForm = 'true';
                                                
                                                updateEnemyBar(currentEnemyWrap);
                                                recalculateActionQueue();
                                                
                                                logCombat('Crawler is now fragile but extremely fast!');
                                                return;
                                            }
                                        }
                                        
                                        // Only transform if not already transformed (check for phase flag)
                                        const alreadyTransformed = currentEnemyWrap.dataset.transformed === 'true';
                                        
                                        if (isDivineKing && !alreadyTransformed) {
                                            logCombat('âš¡ Divine King transforms into Demon King! âš¡');
                                            
                                            // Transform to Demon King (phase 2)
                                            const demonKingStats = ENEMY_BASE_STATS['demonKing'] || { health:600, strength:25, magic:25, speed:5, defense:30 };
                                            const level = battleData.level || 100;
                                            const baseScale = Math.pow(level, 0.9); // Use exponential scaling
                                            const scaleMultiplier = baseScale * 1.3; // Boss on boss tile
                                            
                                            // Update enemy to demon king
                                            currentEnemyWrap.dataset.hp = Math.max(1, Math.round(demonKingStats.health * scaleMultiplier));
                                            currentEnemyWrap.dataset.maxHp = currentEnemyWrap.dataset.hp;
                                            currentEnemyWrap.dataset.str = Math.round(demonKingStats.strength * scaleMultiplier);
                                            currentEnemyWrap.dataset.mag = Math.round(demonKingStats.magic * scaleMultiplier);
                                            currentEnemyWrap.dataset.speed = Math.round(demonKingStats.speed * scaleMultiplier);
                                            currentEnemyWrap.dataset.def = Math.round((demonKingStats.defense || 0) * scaleMultiplier);
                                            currentEnemyWrap.dataset.key = 'demonKing';
                                            currentEnemyWrap.dataset.transformed = 'true'; // Mark as transformed to prevent re-triggering
                                            
                                            // Update image
                                            const img = currentEnemyWrap.querySelector('img');
                                            if (img) {
                                                img.src = 'Enemies/demonKing.png';
                                                img.alt = 'demonKing';
                                            }
                                            
                                            // Update name display
                                            const nameH = currentEnemyWrap.querySelector('h3');
                                            if (nameH) {
                                                nameH.textContent = `Demon King (Lv ${level})`;
                                            }
                                            
                                            // Update health bar
                                            updateEnemyBar(currentEnemyWrap);
                                            
                                            // Clear status effects for transformation
                                            delete enemyStatusEffects[enemyIndex];
                                            
                                            // Recalculate action queue with new speed
                                            recalculateActionQueue();
                                            
                                            // Change music to revenge.mp3
                                            if (typeof playBattleMusic === 'function') {
                                                playBattleMusic();
                                            }
                                            
                                        logCombat('Phase 2 begins! The Demon King rises!');
                                        return;
                                    }
                                    
                                    logCombat('Enemy defeated!');
                                    
                                    // ===== ON-KILL ABILITIES =====
                                    
                                    // Ability 26: Death's Touch - Instantly kill enemies below 15% HP
                                    if (equippedAbilities.includes(26) && enemyHpPercent > 0 && enemyHpPercent < 0.15) {
                                        logCombat(`â˜ ï¸ DEATH'S TOUCH! Enemy executed instantly!`);
                                    }
                                    
                                    // Ability 27: Annihilation - Each kill permanently increases all stats by +5%
                                    if (equippedAbilities.includes(27)) {
                                        const statBoost = 1.05;
                                        attacker.STRENGTH = Number(attacker.STRENGTH || 0) * statBoost;
                                        attacker.MAGIC = Number(attacker.MAGIC || 0) * statBoost;
                                        attacker.SPEED = Number(attacker.SPEED || 0) * statBoost;
                                        attacker.DEFENSE = Number(attacker.DEFENSE || 0) * statBoost;
                                        attacker.MAX_HEALTH = Number(attacker.MAX_HEALTH || 0) * statBoost;
                                        updatePlayerStatsDisplay();
                                        updatePlayerArea();
                                        logCombat(`ðŸ’¥ Annihilation: All stats increased by 5%!`);
                                    }
                                    
                                    // Ability 37: Vampiric - Heal 15% max HP on kill
                                    if (equippedAbilities.includes(37)) {
                                        const vampiricHeal = Math.ceil(Number(attacker.MAX_HEALTH || 100) * 0.15);
                                        attacker.HEALTH = Math.min(Number(attacker.MAX_HEALTH || 100), Number(attacker.HEALTH || 0) + vampiricHeal);
                                        updatePlayerArea();
                                        logCombat(`ðŸ§› Vampiric: Healed ${vampiricHeal} HP on kill!`);
                                    }
                                    
                                    // Ability 42: Soul Harvest - Gain +10 max HP permanently per kill
                                    if (equippedAbilities.includes(42)) {
                                        attacker.MAX_HEALTH = Number(attacker.MAX_HEALTH || 0) + 10;
                                        attacker.HEALTH = Number(attacker.HEALTH || 0) + 10;
                                        updatePlayerStatsDisplay();
                                        updatePlayerArea();
                                        logCombat(`ðŸ’š Soul Harvest: +10 Max HP (now ${Math.round(attacker.MAX_HEALTH)})`);
                                    }
                                    
                                    // Ability 50: Godslayer - Heal to full HP on kill
                                    if (equippedAbilities.includes(50)) {
                                        attacker.HEALTH = Number(attacker.MAX_HEALTH || 100);
                                        updatePlayerArea();
                                        logCombat(`âš¡ GODSLAYER: Healed to full HP (${Math.round(attacker.HEALTH)}/${Math.round(attacker.MAX_HEALTH)})!`);
                                    }
                                    
                                    // Use centralized enemy defeat handler for necromancer resurrection and cleanup
                                    handleEnemyDefeat(currentEnemyWrap, enemyIndex);
                                }
                                    
                                }); // End forEach for targetEnemies
                                
                                // After attacking all targets, handle post-attack logic
                                // Ability 13: Pixel Combo mini-game
                                if (equippedAbilities.includes(13)) {
                                    showPixelComboMiniGame(enemyWrap);
                                    return true; // Wait for mini-game to complete
                                }

                                // After attacking, clear selectedAttackId so player must re-select an attack next time
                                selectedAttackId = null;
                                
                                // Add delay before enemy turn (800ms for combat flow)
                                setTimeout(() => {
                                    // After attacking, consume selection and reset waiting flag to resume queue
                                    playerCanAct = false;
                                    playerWaiting = false;
                                    waitingForPlayerAction = false;
                                }, 800);
                                
                                return true;
                            }                                    // Expose attack performer so click handlers outside can call it when appropriate
                                    try{ window.playerPerformAttackOn = playerPerformAttackOn; } catch(e){}

                        // Centralized enemy defeat and necromancer resurrection logic
                        function handleEnemyDefeat(enemyWrap, enemyIndex) {
                            // Check if this enemy is a corpse (invulnerable until necromancer dies)
                            if (enemyWrap.dataset.corpse === 'true') {
                                // Corpses cannot die, reset HP to minimum
                                enemyWrap.dataset.hp = 1;
                                updateEnemyBar(enemyWrap);
                                logCombat('ðŸ’€ Corpse cannot die while necromancer lives!');
                                return true; // Prevent death
                            }
                            
                            // Check for multi-health bar enemies (hBars > 1)
                            const enemyKey = enemyWrap.dataset.key || (enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : '');
                            const baseStats = ENEMY_BASE_STATS[enemyKey];
                            
                            if (baseStats && baseStats.hBars > 1) {
                                // Initialize bars remaining if not set
                                if (!enemyWrap.dataset.barsRemaining) {
                                    enemyWrap.dataset.barsRemaining = baseStats.hBars;
                                }
                                
                                const barsLeft = Number(enemyWrap.dataset.barsRemaining);
                                
                                if (barsLeft > 1) {
                                    // Respawn with new health bar
                                    const newBarsRemaining = barsLeft - 1;
                                    enemyWrap.dataset.barsRemaining = newBarsRemaining;
                                    
                                    // Restore to full HP
                                    enemyWrap.dataset.hp = enemyWrap.dataset.maxHp;
                                    updateEnemyBar(enemyWrap);
                                    
                                    logCombat(`ðŸ’€ ${enemyKey} respawns! ${newBarsRemaining} health bar${newBarsRemaining > 1 ? 's' : ''} remaining!`);
                                    
                                    // Change music for overseer based on bars remaining
                                    if (enemyKey === 'overseer' && level === 150 && typeof playBattleMusic === 'function') {
                                        playBattleMusic();
                                    }
                                    
                                    return true; // Prevent death
                                }
                                // If barsLeft === 1, continue to actual defeat
                            }
                            
                            // Register enemy defeat for index tracking
                            const defeatedKey = enemyWrap.dataset.key || (enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : '');
                            if (typeof registerEnemyDefeated === 'function' && defeatedKey) {
                                registerEnemyDefeated(defeatedKey);
                            }
                            
                            // Necromancer resurrection mechanic
                            const allEnemies = getEnemyWrappers();
                            const necromancerWrap = allEnemies.find(w => {
                                const key = w.dataset.key || (w.querySelector('img') ? w.querySelector('img').alt : '');
                                return key.toLowerCase().includes('necromancer') && Number(w.dataset.hp) > 0;
                            });
                            
                            if (necromancerWrap && !enemyWrap.dataset.corpse) {
                                // Get necromancer level
                                const necromancerLevel = battleData.level || 1;
                                
                                // Get necromancer stats for the corpse
                                const necromancerStats = ENEMY_BASE_STATS['necromancer'] || { health: 50, strength: 5, magic: 5, speed: 3, defense: 0 };
                                const scaleMultiplier = Math.pow(necromancerLevel, 0.9);
                                
                                // Resurrect as corpse with necromancer-level stats and mark as invulnerable
                                const corpseHp = Math.max(1, Math.round(necromancerStats.health * scaleMultiplier * 0.5));
                                enemyWrap.dataset.hp = corpseHp;
                                enemyWrap.dataset.maxHp = corpseHp;
                                enemyWrap.dataset.str = Math.round(necromancerStats.strength * scaleMultiplier * 0.5);
                                enemyWrap.dataset.mag = Math.round(necromancerStats.magic * scaleMultiplier * 0.5);
                                enemyWrap.dataset.speed = Math.round(necromancerStats.speed * scaleMultiplier);
                                enemyWrap.dataset.def = 0;
                                enemyWrap.dataset.corpse = 'true'; // Mark as corpse (invulnerable)
                                
                                // Add visual indicator
                                const nameH = enemyWrap.querySelector('h3');
                                if (nameH && !nameH.textContent.includes('Corpse')) {
                                    const originalName = nameH.textContent.replace(/\(Lv \d+\)/, '').trim();
                                    nameH.textContent = `Corpse ${originalName} (Lv ${necromancerLevel})`;
                                }
                                
                                updateEnemyBar(enemyWrap);
                                logCombat('ðŸ§Ÿ Necromancer resurrects fallen ally as an invulnerable corpse!');
                                return true; // Enemy was resurrected
                            }
                            
            // If this is a necromancer dying, kill all corpses
            const isNecromancer = defeatedKey.toLowerCase().includes('necromancer');
            if (isNecromancer) {
                logCombat('ðŸ’€ Necromancer defeated! All corpses crumble to dust...');
                allEnemies.forEach(w => {
                    if (w.dataset.corpse === 'true') {
                        w.dataset.hp = 0;
                        w.remove();
                    }
                });
            }
            
            // Piranha death attack ability
            if (defeatedKey.toLowerCase() === 'piranha') {
                const target = PARTY_STATS[getActiveBattleMember()];
                const memberKey = getActiveBattleMember();
                const piranhaStr = Number(enemyWrap.dataset.str) || 1;
                const deathBiteDamage = Math.round(piranhaStr * 1.2); // 120% strength as final attack
                
                // Apply defense
                let defense = Number(target.DEFENSE || 0);
                const defenseMultiplier = Math.max(0.5, 1.0 - (Math.log10(defense + 1) * 0.05));
                const damageReduction = defense * defenseMultiplier;
                const damageAfterDefense = deathBiteDamage - damageReduction;
                const minimumDamage = Math.ceil(deathBiteDamage * 0.1);
                let finalDmg = Math.max(minimumDamage, Math.round(damageAfterDefense));
                
                target.HEALTH -= finalDmg;
                target.HEALTH = Math.max(0, target.HEALTH);
                updatePlayerArea();
                logCombat(`ðŸŸ Death Bite: Piranha's final attack deals ${finalDmg} damage!`);
                
                // Check if player died
                if (target.HEALTH <= 0) {
                    logCombat(`â˜ ï¸ ${target.NAME} has been defeated!`);
                    handleMemberDeath();
                }
            }
            
            // Play death animation before removing enemy
            const enemyImg = enemyWrap.querySelector('img');
            if (enemyImg) {
                enemyImg.classList.add('enemy-dying');
                setTimeout(() => {
                    // Hide the defeated enemy completely (remove from DOM)
                    enemyWrap.remove();
                    // Clear status effects for defeated enemy
                    delete enemyStatusEffects[enemyIndex];
                    
                    // Update turn order display to remove dead enemy's turn boxes
                    updateTurnOrderDisplay();
                    
                    const anyAlive = getEnemyWrappers().some(w => Number(w.dataset.hp) > 0);
                    if (!anyAlive) {
                        logCombat('All enemies defeated! Redirecting to home...');
                        combatRunning = false;
                        // Handle victory: award EXP, generate loot, show victory modal, and then unlock/redirect
                        try {
                            const level = battleData.level || 1;
                            showVictoryRewards(level);
                        } catch (e) {
                            console.error('Error showing victory rewards:', e);
                        }
                    }
                }, 800); // Wait for death animation to complete
            } else {
                // No image found, remove immediately (fallback)
                enemyWrap.remove();
                delete enemyStatusEffects[enemyIndex];
                updateTurnOrderDisplay();
                
                const anyAlive = getEnemyWrappers().some(w => Number(w.dataset.hp) > 0);
                if (!anyAlive) {
                    logCombat('All enemies defeated! Redirecting to home...');
                    combatRunning = false;
                    // Handle victory: award EXP, generate loot, show victory modal, and then unlock/redirect
                    try {
                        const level = battleData.level || 1;
                        showVictoryRewards(level);
                    } catch (e) {
                        console.error('Error showing victory rewards:', e);
                        // Fallback: just unlock and go home
                        try { if (typeof window.clearLevelAndUnlock === 'function') window.clearLevelAndUnlock(battleData.level||1); } catch(_){}
                        setTimeout(()=> window.location.href = 'home.html', 1500);
                    }
                    return true;
                }
                return false; // Enemy was removed but battle continues
            }
        }

                        // Apply status effect to a target (enemy or player)
                        function applyStatusEffect(target, targetType, targetKey, effectType, baseDamage) {
                            // targetType: 'enemy' or 'player'
                            // targetKey: enemy index or member key
                            // effectType: from attack.status
                            // baseDamage: the original damage dealt for calculating effect strength
                            
                            if (!effectType || effectType === 'none' || effectType === 'player buff') return;
                            
                            // Check for ability 21 (Sea Shield) immunity to leech, burn, and chill
                            if (targetType === 'player') {
                                const memberKey = targetKey;
                                const activeAbilities = getEquippedAbilities(memberKey);
                                if (activeAbilities.includes(21)) {
                                    // Sea Shield grants immunity to leech, burn, and chill
                                    if (effectType === 'leech' || effectType === 'burn' || effectType === 'chill') {
                                        logCombat(`ðŸŒŠ Sea Shield: Immune to ${effectType}!`);
                                        return; // Block the status effect
                                    }
                                }
                            }
                            
                            let effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray) {
                                effectsArray = [];
                                if (targetType === 'enemy') enemyStatusEffects[targetKey] = effectsArray;
                                else playerStatusEffects[targetKey] = effectsArray;
                            }
                            
                            // Handle different effect types
                            if (effectType === 'burn') {
                                // Burn: 50% of pre-defense damage, 3 turns, stacks, bypasses defense
                                effectsArray.push({ type: 'burn', turnsLeft: 3, damagePerTurn: Math.round(baseDamage * 0.5) });
                                logCombat(`Applied BURN (${Math.round(baseDamage * 0.5)} dmg/turn for 3 turns)`);
                            } else if (effectType === 'leech') {
                                // Leech: 10% of actual damage dealt (post-defense), heals player, 3 turns, stacks, bypasses defense
                                effectsArray.push({ type: 'leech', turnsLeft: 3, damagePerTurn: Math.round(baseDamage * 0.1) });
                                logCombat(`Applied LEECH (${Math.round(baseDamage * 0.1)} dmg+heal/turn for 3 turns)`);
                            } else if (effectType === 'bleed') {
                                // Bleed: 5% stacking damage multiplier, 3 turns
                                // Find existing bleed on this target to stack
                                const existingBleed = effectsArray.find(e => e.type === 'bleed');
                                if (existingBleed) {
                                    existingBleed.stacks = (existingBleed.stacks || 1) + 1;
                                    existingBleed.turnsLeft = 3; // refresh duration
                                    logCombat(`BLEED stacked to ${existingBleed.stacks}x (${existingBleed.stacks * 5}% bonus damage)`);
                                } else {
                                    effectsArray.push({ type: 'bleed', turnsLeft: 3, stacks: 1 });
                                    logCombat(`Applied BLEED (5% bonus damage, stacks)`);
                                }
                            } else if (effectType === 'grim') {
                                // Grim: 2% max HP per turn, bypasses defense, lasts until death, stacks
                                const maxHp = targetType === 'enemy' ? Number(target.dataset.maxHp || 100) : Number(target.MAX_HEALTH || 100);
                                effectsArray.push({ type: 'grim', turnsLeft: 999, damagePerTurn: Math.max(1, Math.round(maxHp * 0.02)) });
                                logCombat(`Applied GRIM (${Math.round(maxHp * 0.02)} dmg/turn until death, stacks)`);
                            } else if (effectType === 'chill') {
                                // Chill: Reduces damage output by 25% for 3 turns
                                effectsArray.push({ type: 'chill', turnsLeft: 3 });
                                logCombat(`Applied CHILL (25% damage reduction for 3 turns)`);
                                
                                // Add visual chill effect (blue overlay)
                                if (targetType === 'enemy') {
                                    const enemyImg = target.querySelector('img');
                                    if (enemyImg) enemyImg.classList.add('chilled');
                                } else {
                                    // targetKey is memberKey for players
                                    const playerImgId = (targetKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                    const playerImg = document.getElementById(playerImgId);
                                    if (playerImg) playerImg.classList.add('chilled');
                                }
                                // No queue recalculation - this was causing the bug
                            } else if (effectType === 'random') {
                                // Random effect: pick one of burn, leech, bleed
                                const randomEffects = ['burn', 'leech', 'bleed'];
                                const chosen = randomEffects[Math.floor(Math.random() * randomEffects.length)];
                                applyStatusEffect(target, targetType, targetKey, chosen, baseDamage);
                            } else if (effectType === 'chaos') {
                                // Chaos: Apply 2-4 random different status effects
                                const allStatuses = ['burn', 'leech', 'bleed', 'grim', 'chill'];
                                const numEffects = Math.floor(Math.random() * 3) + 2; // 2-4 effects
                                const shuffled = allStatuses.sort(() => Math.random() - 0.5);
                                const selectedEffects = shuffled.slice(0, numEffects);
                                
                                selectedEffects.forEach(effect => {
                                    applyStatusEffect(target, targetType, targetKey, effect, baseDamage);
                                });
                                logCombat(`ðŸŒ€ Chaos applied ${numEffects} status effects!`);
                            }
                        }
                        
                        // Process ally support abilities at start of turn
                        function processAllySupportAbilities(memberKey) {
                            const player = PARTY_STATS[memberKey];
                            const allyKey = memberKey === activeBattleMember ? activeBattleMember2 : activeBattleMember;
                            const ally = PARTY_STATS[allyKey];
                            
                            if (!player || !ally || Number(ally.HEALTH) <= 0) return; // Ally must be alive
                            
                            const abilities = getEquippedAbilities(memberKey);
                            
                            // Ability 47: Sage's Wisdom - Restore 5% max mana to both players per turn
                            if (abilities.includes(47)) {
                                const playerManaRestore = Math.ceil(Number(player.MAX_MANA || 100) * 0.05);
                                const allyManaRestore = Math.ceil(Number(ally.MAX_MANA || 100) * 0.05);
                                player.MANA = Math.min(Number(player.MAX_MANA || 100), Number(player.MANA || 0) + playerManaRestore);
                                ally.MANA = Math.min(Number(ally.MAX_MANA || 100), Number(ally.MANA || 0) + allyManaRestore);
                                updatePlayerArea();
                                logCombat(`ðŸ“– Sage's Wisdom: Restored ${playerManaRestore}/${allyManaRestore} mana to both players!`);
                            }
                            
                            // Ability 53: Regeneration - Restore 3% max HP to both players per turn
                            if (abilities.includes(53)) {
                                const playerHeal = Math.ceil(Number(player.MAX_HEALTH || 100) * 0.03);
                                const allyHeal = Math.ceil(Number(ally.MAX_HEALTH || 100) * 0.03);
                                player.HEALTH = Math.min(Number(player.MAX_HEALTH || 100), Number(player.HEALTH || 0) + playerHeal);
                                ally.HEALTH = Math.min(Number(ally.MAX_HEALTH || 100), Number(ally.HEALTH || 0) + allyHeal);
                                updatePlayerArea();
                                logCombat(`ðŸ’š Regeneration: Healed ${playerHeal}/${allyHeal} HP to both players!`);
                                
                                // Show heal popups on both players
                                const player1Img = document.getElementById('player-1');
                                const player2Img = document.getElementById('player-2');
                                if (player1Img) {
                                    showDamagePopup(player1Img, playerHeal, 'heal');
                                }
                                if (player2Img) {
                                    showDamagePopup(player2Img, allyHeal, 'heal');
                                }
                            }
                        }
                        
                        // Process status effects for a target at start of their turn
                        function processStatusEffects(target, targetType, targetKey) {
                            const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray || effectsArray.length === 0) return;
                            
                            const toRemove = [];
                            
                            effectsArray.forEach((effect, idx) => {
                                if (effect.type === 'burn') {
                                    // Burn bypasses defense - deals full damage
                                    const dmg = effect.damagePerTurn || 0;
                                    
                                    if (targetType === 'enemy') {
                                        const curHp = Number(target.dataset.hp) - dmg;
                                        target.dataset.hp = Math.max(0, curHp);
                                        updateEnemyBar(target);
                                        logCombat(`ðŸ”¥ BURN deals ${dmg} true damage to enemy`);
                                        // Show burn damage popup on enemy
                                        const enemyImg = target.querySelector('img');
                                        if (enemyImg) {
                                            showDamagePopup(enemyImg, dmg, 'burn');
                                        }
                                    } else {
                                        target.HEALTH = Math.max(0, Number(target.HEALTH) - dmg);
                                        updatePlayerArea();
                                        logCombat(`ðŸ”¥ BURN deals ${dmg} true damage to ${target.NAME}`);
                                        // Show burn damage popup on player
                                        const memberKey = targetKey;
                                        const playerImgId = (memberKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                        const pimg = document.getElementById(playerImgId);
                                        if (pimg) {
                                            showDamagePopup(pimg, dmg, 'burn');
                                        }
                                    }
                                    effect.turnsLeft--;
                                    if (effect.turnsLeft <= 0) toRemove.push(idx);
                                } else if (effect.type === 'leech') {
                                    // Leech bypasses defense - deals and heals full damage
                                    const dmg = effect.damagePerTurn || 0;
                                    
                                    if (targetType === 'enemy') {
                                        const curHp = Number(target.dataset.hp) - dmg;
                                        target.dataset.hp = Math.max(0, curHp);
                                        updateEnemyBar(target);
                                        // Heal the active player member for the same amount
                                        const activeMember = PARTY_STATS[getActiveBattleMember()];
                                        if (activeMember) {
                                            activeMember.HEALTH = Math.min(Number(activeMember.MAX_HEALTH), Number(activeMember.HEALTH) + dmg);
                                            updatePlayerArea();
                                            // Show heal popup on player
                                            const playerImgId = 'player-1';
                                            const pimg = document.getElementById(playerImgId);
                                            if (pimg) {
                                                showDamagePopup(pimg, dmg, 'heal');
                                            }
                                        }
                                        logCombat(`ðŸ©¸ LEECH deals ${dmg} true damage and heals player ${dmg} HP`);
                                        // Show leech damage popup on enemy
                                        const enemyImg = target.querySelector('img');
                                        if (enemyImg) {
                                            showDamagePopup(enemyImg, dmg, 'leech');
                                        }
                                    }
                                    effect.turnsLeft--;
                                    if (effect.turnsLeft <= 0) toRemove.push(idx);
                                } else if (effect.type === 'grim') {
                                    // Deal max HP damage bypassing defense
                                    const dmg = effect.damagePerTurn || 0;
                                    if (targetType === 'enemy') {
                                        const curHp = Number(target.dataset.hp) - dmg;
                                        target.dataset.hp = Math.max(0, curHp);
                                        updateEnemyBar(target);
                                        logCombat(`GRIM deals ${dmg} true damage to enemy`);
                                        // Show grim damage popup on enemy
                                        const enemyImg = target.querySelector('img');
                                        if (enemyImg) {
                                            showDamagePopup(enemyImg, dmg, 'grim');
                                        }
                                    } else {
                                        target.HEALTH = Math.max(0, Number(target.HEALTH) - dmg);
                                        updatePlayerArea();
                                        logCombat(`GRIM deals ${dmg} true damage to ${target.NAME}`);
                                        // Show grim damage popup on player
                                        const memberKey = targetKey;
                                        const playerImgId = (memberKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                        const pimg = document.getElementById(playerImgId);
                                        if (pimg) {
                                            showDamagePopup(pimg, dmg, 'grim');
                                        }
                                    }
                                    // Grim doesn't decrement turns (lasts until death)
                                } else if (effect.type === 'chill') {
                                    // Chill reduces damage output, decrement duration (no queue recalculation needed)
                                    effect.turnsLeft--;
                                    if (effect.turnsLeft <= 0) {
                                        toRemove.push(idx);
                                        logCombat('CHILL expired');
                                        
                                        // Remove visual chill effect
                                        if (targetType === 'enemy') {
                                            const enemyImg = target.querySelector('img');
                                            if (enemyImg) enemyImg.classList.remove('chilled');
                                        } else {
                                            // targetKey is memberKey for players
                                            const playerImgId = (targetKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                            const playerImg = document.getElementById(playerImgId);
                                            if (playerImg) playerImg.classList.remove('chilled');
                                        }
                                    }
                                }
                                // Bleed is applied as damage multiplier during attack, not as DoT
                            });
                            
                            // Remove expired effects (in reverse to preserve indices)
                            toRemove.sort((a, b) => b - a).forEach(idx => effectsArray.splice(idx, 1));
                        }
                        
                        // Get bleed multiplier for a target
                        function getBleedMultiplier(targetType, targetKey) {
                            const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray) return 1.0;
                            const bleed = effectsArray.find(e => e.type === 'bleed');
                            if (!bleed) return 1.0;
                            // 5% per stack
                            return 1.0 + (bleed.stacks || 1) * 0.05;
                        }
                        
                        // Decrement bleed duration
                        function decrementBleed(targetType, targetKey) {
                            const effectsArray = targetType === 'enemy' ? enemyStatusEffects[targetKey] : playerStatusEffects[targetKey];
                            if (!effectsArray) return;
                            const bleed = effectsArray.find(e => e.type === 'bleed');
                            if (bleed) {
                                bleed.turnsLeft--;
                                if (bleed.turnsLeft <= 0) {
                                    const idx = effectsArray.indexOf(bleed);
                                    if (idx > -1) effectsArray.splice(idx, 1);
                                    logCombat('BLEED expired');
                                }
                            }
                        }
                        
                        // Pixel Combo mini-game (ability 13)
                        function showPixelComboMiniGame(lastTargetWrap) {
                            const optionCount = pixelComboCount >= 8 ? 3 : 4;
                            const enemies = getEnemyWrappers().filter(w => Number(w.dataset.hp) > 0);
                            
                            // Create overlay
                            const overlay = document.createElement('div');
                            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
                            
                            const panel = document.createElement('div');
                            panel.style.cssText = 'background:#222;border:3px solid #00ff00;padding:20px;border-radius:10px;text-align:center;color:#fff;';
                            
                            const title = document.createElement('h2');
                            title.textContent = 'ðŸŽ® PIXEL COMBO! ðŸŽ®';
                            title.style.color = '#00ff00';
                            panel.appendChild(title);
                            
                            const info = document.createElement('p');
                            info.textContent = `Choose the correct symbol to attack again! (${pixelComboCount} combo)`;
                            panel.appendChild(info);
                            
                            const btnContainer = document.createElement('div');
                            btnContainer.style.cssText = 'display:flex;gap:10px;margin-top:20px;';
                            
                            // Generate symbols (one correct, rest infected)
                            const correctSymbol = 'âœ“';
                            const infectedSymbol = 'â˜ ';
                            const symbols = [];
                            symbols.push(correctSymbol);
                            for (let i = 1; i < optionCount; i++) {
                                symbols.push(infectedSymbol);
                            }
                            
                            // Shuffle
                            for (let i = symbols.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
                            }
                            
                            symbols.forEach(symbol => {
                                const btn = document.createElement('button');
                                btn.textContent = symbol;
                                btn.style.cssText = 'font-size:48px;width:80px;height:80px;cursor:pointer;background:#333;border:2px solid #666;border-radius:5px;color:#fff;';
                                btn.onmouseover = () => btn.style.background = '#444';
                                btn.onmouseout = () => btn.style.background = '#333';
                                
                                btn.onclick = () => {
                                    document.body.removeChild(overlay);
                                    
                                    if (symbol === correctSymbol) {
                                        // Success! Increment combo and attack again
                                        pixelComboCount++;
                                        logCombat(`âœ“ Pixel Combo Success! (${pixelComboCount} streak)`);

                                        // Check if all enemies are dead before attacking again
                                        const aliveEnemies = getEnemyWrappers().filter(w => Number(w.dataset.hp) > 0);
                                        if (aliveEnemies.length === 0) {
                                            logCombat('All enemies defeated! Redirecting to home...');
                                            combatRunning = false;
                                            try {
                                                const level = battleData.level || 1;
                                                showVictoryRewards(level);
                                            } catch (e) {
                                                console.error('Error showing victory rewards:', e);
                                                try { if (typeof window.clearLevelAndUnlock === 'function') window.clearLevelAndUnlock(battleData.level||1); } catch(_){}
                                                setTimeout(()=> window.location.href = 'home.html', 1500);
                                            }
                                            return;
                                        }

                                        // If the original target is dead, end the combo sequence (do not attack again)
                                        if (Number(lastTargetWrap.dataset.hp) <= 0) {
                                            logCombat('Combo ended: target eliminated.');
                                            selectedAttackId = null;
                                            playerCanAct = false;
                                            playerWaiting = false;
                                            waitingForPlayerAction = false;
                                            return;
                                        }
                                        // Otherwise, attack again on the same target if alive, otherwise first alive enemy
                                        // Remove the dead target from possible targets
                                        const filteredAliveEnemies = aliveEnemies.filter(w => w !== lastTargetWrap);
                                        const target = Number(lastTargetWrap.dataset.hp) > 0 ? lastTargetWrap : filteredAliveEnemies[0];
                                        if (target) {
                                            setTimeout(() => playerPerformAttackOn(target), 100);
                                        } else {
                                            // End turn if no targets
                                            selectedAttackId = null;
                                            playerCanAct = false;
                                            playerWaiting = false;
                                            waitingForPlayerAction = false;
                                        }
                                    } else {
                                        // Failed! Reset combo
                                        logCombat(`â˜  Pixel Combo Failed! Combo reset.`);
                                        pixelComboCount = 0;

                                        // Check if all enemies are dead after failed combo
                                        const aliveEnemies = getEnemyWrappers().filter(w => Number(w.dataset.hp) > 0);
                                        if (aliveEnemies.length === 0) {
                                            logCombat('All enemies defeated! Redirecting to home...');
                                            combatRunning = false;
                                            try {
                                                const level = battleData.level || 1;
                                                showVictoryRewards(level);
                                            } catch (e) {
                                                console.error('Error showing victory rewards:', e);
                                                try { if (typeof window.clearLevelAndUnlock === 'function') window.clearLevelAndUnlock(battleData.level||1); } catch(_){}
                                                setTimeout(()=> window.location.href = 'home.html', 1500);
                                            }
                                            return;
                                        }

                                        // End turn
                                        selectedAttackId = null;
                                        playerCanAct = false;
                                        playerWaiting = false;
                                        waitingForPlayerAction = false;
                                    }
                                };
                                
                                btnContainer.appendChild(btn);
                            });
                            
                            panel.appendChild(btnContainer);
                            overlay.appendChild(panel);
                            document.body.appendChild(overlay);
                        }

                        function performPlayerAction(playerNum){
                            // Called by the scheduler when it's the player's turn. We set flags so the UI can accept a target click.
                            if (playerWaiting) return; // already waiting for the player's click

                            // Determine which player is acting
                            const memberKey = playerNum === 1 ? activeBattleMember : activeBattleMember2;
                            const target = PARTY_STATS[memberKey];

                            // --- Passive Leech Aura (Leech Crown, ability 80) ---
                            const equippedAbilities = getEquippedAbilities(memberKey);
                            if (equippedAbilities.includes(80)) {
                                let totalDrained = 0;
                                const enemies = getEnemyWrappers().filter(e => Number(e.dataset.hp) > 0);
                                enemies.forEach(enemyWrap => {
                                    const maxHp = Number(enemyWrap.dataset.maxHp) || 1;
                                    const drainAmt = Math.max(1, Math.round(maxHp * 0.03)); // 3% max HP, min 1
                                    const curHp = Number(enemyWrap.dataset.hp);
                                    enemyWrap.dataset.hp = Math.max(0, curHp - drainAmt);
                                    updateEnemyBar(enemyWrap);
                                    totalDrained += drainAmt;
                                    // Show leech popup on enemy
                                    const enemyImg = enemyWrap.querySelector('img');
                                    if (enemyImg) showDamagePopup(enemyImg, drainAmt, 'leech');
                                });
                                if (totalDrained > 0) {
                                    target.HEALTH = Math.min(Number(target.MAX_HEALTH), Number(target.HEALTH) + totalDrained);
                                    updatePlayerArea();
                                    // Show heal popup on player
                                    const playerImgId = (memberKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                    const pimg = document.getElementById(playerImgId);
                                    if (pimg) showDamagePopup(pimg, totalDrained, 'heal');
                                    logCombat(`ðŸ‘‘ Leeching Aura: Drained ${totalDrained} HP from all enemies and healed ${target.NAME}`);
                                }
                            }

                            // Process status effects on player at start of their turn
                            processStatusEffects(target, 'player', memberKey);

                            // Process ally support abilities at start of turn
                            processAllySupportAbilities(memberKey);

                            // Check if player died from status effects
                            if (Number(target.HEALTH) <= 0) {
                                logCombat(`${target.NAME} was defeated by status effects!`);
                                handleMemberDeath();
                                return;
                            }

                            playerCanAct = true;
                            playerWaiting = true;
                            currentPlayerTurn = playerNum; // Store which player's turn it is

                            // Update attack list to show current player's attacks
                            renderAttacksForPlayer();
                            enableAttackSelection();

                            // Enable Rest button
                            if (typeof updateRestButton === 'function') {
                                updateRestButton(true);
                            }

                            logCombat(`Player ${playerNum} turn: select an attack then click an enemy to perform the action.`);

                            // Auto-battle logic: automatically select and perform action
                            if (window.autoBattleEnabled) {
                                setTimeout(() => {
                                    performAutoBattleAction(playerNum, memberKey, target);
                                }, 800); // Delay to let player see what's happening
                            }
                        }
                        
                        // Auto-battle: Toggle on/off
                        let autoBattleEnabled = false;
                        window.autoBattleEnabled = false;
                        
                        function toggleAutoBattle() {
                            autoBattleEnabled = !autoBattleEnabled;
                            window.autoBattleEnabled = autoBattleEnabled;
                            
                            const btn = document.getElementById('auto-battle-btn');
                            if (btn) {
                                if (autoBattleEnabled) {
                                    btn.textContent = 'Auto Battle: ON';
                                    btn.classList.add('active');
                                    logCombat('ðŸ¤– Auto Battle ENABLED - Player will automatically attack');
                                } else {
                                    btn.textContent = 'Auto Battle: OFF';
                                    btn.classList.remove('active');
                                    logCombat('ðŸ¤– Auto Battle DISABLED - Manual control restored');
                                }
                            }
                        }
                        window.toggleAutoBattle = toggleAutoBattle;
                        
                        // Auto-battle: Perform automatic action
                        function performAutoBattleAction(playerNum, memberKey, target) {
                            if (!window.autoBattleEnabled || !playerCanAct || !playerWaiting) return;
                            
                            // Get current mana
                            const currentMana = Number(target.MANA || 0);
                            const maxMana = Number(target.MAX_MANA || 100);
                            
                            // Check if we need to rest (mana below 30%)
                            if (currentMana < maxMana * 0.3) {
                                // Rest to restore mana
                                const manaRestore = Math.round(maxMana * 0.6);
                                target.MANA = Math.min(maxMana, currentMana + manaRestore);
                                logCombat(`ðŸ’¤ [AUTO] ${target.NAME} rests and restores ${manaRestore} mana! (${target.MANA}/${maxMana})`);
                                updatePlayerArea();
                                
                                // Clear waiting flags
                                playerCanAct = false;
                                playerWaiting = false;
                                waitingForPlayerAction = false;
                                selectedAttackId = null;
                                selectedTarget = null;
                                return;
                            }
                            
                            // Get available attacks
                            const attacks = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_INVENTORY : [];
                            const equipped = (PARTY_ATTACKS && PARTY_ATTACKS[memberKey]) ? PARTY_ATTACKS[memberKey].ATTACK_EQUIPPED : new Set();
                            const equippedList = attacks.filter(a => equipped.has(a.id)).slice(0, 5);
                            
                            if (equippedList.length === 0) {
                                logCombat('âš ï¸ [AUTO] No attacks available!');
                                playerCanAct = false;
                                playerWaiting = false;
                                waitingForPlayerAction = false;
                                return;
                            }
                            
                            // Filter attacks by mana cost, cooldown, and ammo
                            const affordableAttacks = equippedList.filter(atk => {
                                const manaCost = atk.manaCost || 0;
                                const cooldownKey = `${atk.name}_${memberKey}`;
                                const onCooldown = (attackCooldowns[cooldownKey] || 0) > 0;
                                const requiresAmmo = atk.requiresAmmo || false;
                                const currentAmmo = Number(target.AMMO || 0);
                                
                                // Check all requirements
                                if (manaCost > currentMana) return false;
                                if (onCooldown) return false;
                                if (requiresAmmo && currentAmmo < 1) return false;
                                
                                return true;
                            });
                            
                            // If no affordable attacks, rest
                            if (affordableAttacks.length === 0) {
                                const manaRestore = Math.round(maxMana * 0.6);
                                target.MANA = Math.min(maxMana, currentMana + manaRestore);
                                logCombat(`ðŸ’¤ [AUTO] ${target.NAME} rests (no usable attacks) and restores ${manaRestore} mana!`);
                                updatePlayerArea();
                                
                                playerCanAct = false;
                                playerWaiting = false;
                                waitingForPlayerAction = false;
                                selectedAttackId = null;
                                selectedTarget = null;
                                return;
                            }
                            
                            // Select a random attack from affordable attacks
                            const selectedAttack = affordableAttacks[Math.floor(Math.random() * affordableAttacks.length)];
                            selectedAttackId = selectedAttack.id;
                            
                            // Get alive enemies
                            const allEnemies = getEnemyWrappers();
                            const aliveEnemies = allEnemies.filter(e => Number(e.dataset.hp) > 0);
                            
                            if (aliveEnemies.length === 0) {
                                logCombat('âš ï¸ [AUTO] No targets available!');
                                playerCanAct = false;
                                playerWaiting = false;
                                waitingForPlayerAction = false;
                                return;
                            }
                            
                            // Select random target (or lowest HP target for strategic play)
                            const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
                            
                            // Perform the attack
                            logCombat(`ðŸ¤– [AUTO] ${target.NAME} uses ${selectedAttack.name}`);
                            
                            setTimeout(() => {
                                if (typeof window.playerPerformAttackOn === 'function') {
                                    window.playerPerformAttackOn(targetEnemy);
                                }
                            }, 400); // Small delay before attack
                        }

                        function performEnemyAction(enemyIndex){
                            const allEnemies = getEnemyWrappers();
                            const enemyWrap = allEnemies[enemyIndex];
                            
                            // Skip if this enemy is dead
                            if (!enemyWrap || Number(enemyWrap.dataset.hp) <= 0) return;
                            
                            // Declare enemy key and level at function scope
                            const enemyKey = enemyWrap.dataset.key || (enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : '');
                            const level = Number(enemyWrap.dataset.level) || 1;
                            
                            // Process status effects on this enemy at start of its turn
                            processStatusEffects(enemyWrap, 'enemy', enemyIndex);
                            
                            // Check if enemy died from status effects
                            if (Number(enemyWrap.dataset.hp) <= 0) {
                                logCombat('Enemy defeated by status effects!');
                                
                                // Use centralized enemy defeat handler for necromancer resurrection and cleanup
                                handleEnemyDefeat(enemyWrap, enemyIndex);
                                return;
                            }
                            
                            // ===== ENEMY SPECIAL ABILITIES (START OF TURN) =====
                            // (enemyKey and level already declared at function scope)
                            
                            // Elder Ent: Gain 10% bonus magic stats each turn (compounds)
                            if (enemyKey === 'elderEnt') {
                                const currentMag = Number(enemyWrap.dataset.mag) || 0;
                                const magBoost = Math.max(1, Math.round(currentMag * 0.1));
                                enemyWrap.dataset.mag = currentMag + magBoost;
                                logCombat(`ðŸŒ³ Ancient Growth: Elder Ent gained ${magBoost} magic (now ${Number(enemyWrap.dataset.mag)})!`);
                            }
                            
                            // Worldroot: Spawn a Vine Lasher (15 levels lower, min level 1)
                            if (enemyKey === 'Worldroot') {
                                const spawnLevel = Math.max(1, level - 15);
                                spawnEnemy('vineLasher', spawnLevel);
                                logCombat(`ðŸŒ² Nature's Call: Worldroot summoned a Vine Lasher (Lv ${spawnLevel})!`);
                            }
                            
                            // King: 50% chance to spawn King's Guard OR attack normally
                            // Only the King itself can summon guards (not the guards themselves)
                            if (enemyKey === 'King') {
                                // Store base stats if not already stored (first time)
                                if (!enemyWrap.dataset.baseStr) {
                                    enemyWrap.dataset.baseStr = enemyWrap.dataset.str;
                                    enemyWrap.dataset.baseMag = enemyWrap.dataset.mag;
                                    enemyWrap.dataset.baseSpeed = enemyWrap.dataset.speed;
                                    enemyWrap.dataset.baseDef = enemyWrap.dataset.def;
                                }
                                
                                // Count alive King's Guards (not including the King)
                                const allEnemies = getEnemyWrappers();
                                const kingsGuardCount = allEnemies.filter(w => {
                                    const wKey = w.dataset.key || (w.querySelector('img') ? w.querySelector('img').alt : '');
                                    return wKey === 'kingsGuard' && Number(w.dataset.hp) > 0;
                                }).length;
                                
                                // Always update King's stats based on guard count
                                if (kingsGuardCount > 0) {
                                    // Apply stat boost from BASE stats, not current stats (prevents exponential growth)
                                    const statBoost = 0.1 * kingsGuardCount;
                                    const baseStr = Number(enemyWrap.dataset.baseStr) || 0;
                                    const baseMag = Number(enemyWrap.dataset.baseMag) || 0;
                                    const baseSpeed = Number(enemyWrap.dataset.baseSpeed) || 0;
                                    const baseDef = Number(enemyWrap.dataset.baseDef) || 0;
                                    
                                    enemyWrap.dataset.str = Math.round(baseStr * (1 + statBoost));
                                    enemyWrap.dataset.mag = Math.round(baseMag * (1 + statBoost));
                                    enemyWrap.dataset.speed = Math.round(baseSpeed * (1 + statBoost));
                                    enemyWrap.dataset.def = Math.round(baseDef * (1 + statBoost));
                                }
                                
                                // 50% chance to summon a guard (max 8 guards total)
                                if (kingsGuardCount < 8 && Math.random() < 0.5) {
                                    const spawnLevel = Math.max(1, level - 15);
                                    spawnEnemy('kingsGuard', spawnLevel);
                                    logCombat(`ðŸ‘‘ Royal Command: King summoned King's Guard #${kingsGuardCount + 1} (${(kingsGuardCount + 1) * 10}% stats)!`);
                                    // King used its turn to summon - skip the rest of the attack
                                    return;
                                }
                                // Otherwise, King attacks normally (continue to attack code below)
                            }
                            
                            // Shark: Blood Frenzy - gain 15% strength for each bleeding player
                            if (enemyKey === 'shark') {
                                let bleedingCount = 0;
                                
                                // Count bleeding players
                                for (const memberKey in playerStatusEffects) {
                                    const effects = playerStatusEffects[memberKey] || [];
                                    if (effects.some(e => e.type === 'bleed')) {
                                        bleedingCount++;
                                    }
                                }
                                
                                if (bleedingCount > 0) {
                                    const frenzyBoost = 0.15 * bleedingCount;
                                    const baseStr = Number(enemyWrap.dataset.str) || 0;
                                    const boostedStr = Math.round(baseStr * (1 + frenzyBoost));
                                    enemyWrap.dataset.str = boostedStr;
                                    logCombat(`ðŸ¦ˆ Blood Frenzy: Shark gains ${(frenzyBoost * 100).toFixed(0)}% strength from ${bleedingCount} bleeding target(s)!`);
                                }
                            }
                            
                            // Enemy mana system - check if enemy needs to rest
                            const enemyMana = Number(enemyWrap.dataset.mana || 0);
                            const enemyMaxMana = Number(enemyWrap.dataset.maxMana || 50);
                            const enemyManaCost = Number(enemyWrap.dataset.manaCost || 10);
                            
                            if (enemyMana < enemyManaCost) {
                                // Enemy must rest to restore mana
                                const manaRestore = Math.round(enemyMaxMana * 0.4); // Enemies restore 40%
                                enemyWrap.dataset.mana = Math.min(enemyMaxMana, enemyMana + manaRestore);
                                updateEnemyBar(enemyWrap); // Update mana bar immediately
                                const enemyName = enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : 'Enemy';
                                logCombat(`ðŸ’¤ ${enemyName} #${enemyIndex + 1} rests and restores ${manaRestore} mana!`);
                                return;
                            }
                            
                            // Deduct mana for enemy attack
                            enemyWrap.dataset.mana = enemyMana - enemyManaCost;
                            updateEnemyBar(enemyWrap); // Update mana bar immediately after deduction
                            
            // Enemy attack: use whichever stat is higher (strength or magic)
            const enemyStr = Number(enemyWrap.dataset.str) || 1;
            const enemyMag = Number(enemyWrap.dataset.mag) || 0;
            
            // Determine which stat is stronger and build attack accordingly
            const atk = enemyStr >= enemyMag 
                ? { strMultiplier: 1, magicMultiplier: 0 } 
                : { strMultiplier: 0, magicMultiplier: 1 };
            
            // Smart targeting: choose between both players
            const player1 = PARTY_STATS[activeBattleMember];
            const player2 = PARTY_STATS[activeBattleMember2];
            let target = null;
            let targetKey = null;
            
            // Check if both players are alive
            const p1Alive = player1 && Number(player1.HEALTH) > 0;
            const p2Alive = player2 && Number(player2.HEALTH) > 0;
            
            if (p1Alive && p2Alive) {
                // Both alive - calculate HP percentages
                const p1HpPercent = Number(player1.HEALTH) / Number(player1.MAX_HEALTH || 1);
                const p2HpPercent = Number(player2.HEALTH) / Number(player2.MAX_HEALTH || 1);
                
                // If one player is below 40% HP, 80% chance to target them
                if (p1HpPercent < 0.4 && Math.random() < 0.8) {
                    target = player1;
                    targetKey = activeBattleMember;
                } else if (p2HpPercent < 0.4 && Math.random() < 0.8) {
                    target = player2;
                    targetKey = activeBattleMember2;
                } else {
                    // Otherwise random targeting
                    if (Math.random() < 0.5) {
                        target = player1;
                        targetKey = activeBattleMember;
                    } else {
                        target = player2;
                        targetKey = activeBattleMember2;
                    }
                }
            } else if (p1Alive) {
                target = player1;
                targetKey = activeBattleMember;
            } else if (p2Alive) {
                target = player2;
                targetKey = activeBattleMember2;
            } else {
                // Both dead, skip attack
                return;
            }
            
            // Count the targeted member as participant when they get attacked
            try { battleParticipants.add(targetKey); } catch(e) {}
                            // Debug: log queue position, speed info, and enemy name before enemy attacks
                            try {
                                const enemyName = enemyWrap.querySelector('img') ? enemyWrap.querySelector('img').alt : 'Unknown Enemy';
                                const enemySpeed = getEffectiveSpeed('enemy', enemyIndex, Number(enemyWrap.dataset.speed) || 1);
                                const attackType = enemyStr >= enemyMag ? 'STR' : 'MAG';
                                const attackStat = enemyStr >= enemyMag ? enemyStr : enemyMag;
                                const targetName = target.NAME || 'Player';
                                logCombat(`${enemyName} #${enemyIndex + 1} (${attackType}:${attackStat}, SPD:${enemySpeed}) attacking ${targetName} â€” queue pos: ${queueIndex}/${actionQueue.length}`);
                            } catch(e){}
                            let defense = Number(target.DEFENSE || 0);
                            
                            // Ability 20: Spell Shield - Add 25% of magic stat to defense
                            const activeAbilities = getEquippedAbilities(targetKey);
                            if (activeAbilities.includes(20)) {
                                const magicStat = Number(target.MAGIC || 0);
                                const magicDefenseBonus = Math.round(magicStat * 0.25);
                                defense += magicDefenseBonus;
                                logCombat(`ðŸ›¡ï¸ Spell Shield: +${magicDefenseBonus} defense from magic (${magicStat} Ã— 0.25)`);
                            }
                            
            // Calculate base damage before defense
            let baseDmg = enemyMag * atk.magicMultiplier + enemyStr * atk.strMultiplier;
            // Apply chill effect BEFORE defense: 25% damage reduction if enemy is chilled
                            const enemyEffects = enemyStatusEffects[enemyIndex];
                            if (enemyEffects && enemyEffects.find(e => e.type === 'chill')) {
                                baseDmg = baseDmg * 0.75;
                                logCombat(`â„ï¸ Enemy chilled: -25% damage output`);
                            }
                            
                            // Apply ally support: Protective Aura (ability 48) - 15% damage reduction
                            const allyKey = targetKey === activeBattleMember ? activeBattleMember2 : activeBattleMember;
                            const ally = PARTY_STATS[allyKey];
                            if (ally && ally.HEALTH > 0) {
                                const allyAbilities = getEquippedAbilities(allyKey);
                                if (allyAbilities.includes(48)) {
                                    baseDmg = baseDmg * 0.85;
                                    logCombat('ðŸ›¡ï¸ Protective Aura: Ally reduces damage by 15%!');
                                }
                            }
                            
                            // Apply defense with inverted logarithmic scaling (higher multiplier at low defense)
                            // Damage Reduction = Defense * (1.0 - log10(Defense + 1) * 0.05)
                            const defenseMultiplier = Math.max(0.5, 1.0 - (Math.log10(defense + 1) * 0.05));
                            const damageReduction = defense * defenseMultiplier;
                            const damageAfterDefense = baseDmg - damageReduction;
                            
                            // Ensure minimum 10% of base damage always gets through
                            const minimumDamage = Math.ceil(baseDmg * 0.1);
                            let dmg = Math.max(minimumDamage, Math.round(damageAfterDefense));
                            if (isNaN(dmg)) dmg = minimumDamage || 1;                            // Store original damage and check if this was a magic attack
                            const originalDmg = dmg;
                            const isMagicAttack = atk.magicMultiplier > 0;
                            
            // Ability 12: After Shock - Ignore enemy attack if active
            if (afterShockActive) {
                afterShockActive = false;
                logCombat(`âš¡ After Shock: Enemy attack ignored!`);
                dmg = 0;
            }
            
            // Decrement After Shock cooldown
            if (afterShockCooldown > 0) {
                afterShockCooldown--;
            }
            
            // Decrement all attack cooldowns at end of turn
            for (const cooldownKey in attackCooldowns) {
                if (attackCooldowns[cooldownKey] > 0) {
                    attackCooldowns[cooldownKey]--;
                    if (attackCooldowns[cooldownKey] === 0) {
                        delete attackCooldowns[cooldownKey];
                    }
                }
            }
            
            // Player Lightning Status - Ignore enemy attack if active (from Lightning Shark)
            if (typeof playerLightningActive !== 'undefined' && playerLightningActive) {
                playerLightningActive = false;
                logCombat(`âš¡ Lightning Shield: Enemy attack ignored!`);
                dmg = 0;
            }
            
            // Decrement player lightning cooldown
            if (typeof playerLightningCooldown !== 'undefined' && playerLightningCooldown > 0) {
                playerLightningCooldown--;
            }
            
            // ===== DEFENSIVE ABILITIES (BEFORE DAMAGE) =====
            
            // Ability 30: Ethereal - 25% chance to dodge all damage
            if (activeAbilities.includes(30) && Math.random() < 0.25) {
                logCombat(`ðŸ‘» Ethereal: ${target.NAME} dodged the attack!`);
                dmg = 0;
            }
            
            // Ability 38: Shield Bash - Counter physical attacks with 30% defense as damage
            if (activeAbilities.includes(38) && atk.strMultiplier > 0 && dmg > 0) {
                const bashDmg = Math.round(defense * 0.3);
                const enemyHp = Number(enemyWrap.dataset.hp);
                enemyWrap.dataset.hp = Math.max(0, enemyHp - bashDmg);
                updateEnemyBar(enemyWrap);
                logCombat(`ðŸ›¡ï¸ Shield Bash: Countered with ${bashDmg} damage!`);
            }
            
            // Ability 34: Phoenix - Revive once per battle at 30% HP when killed
            // Ability 68: Resurrection - Revive once per battle at 50% HP when killed
            // Ability 74: Rebirth - Revive once per battle at 40% HP when killed
            // NOTE: Only ONE resurrection can occur per battle across ALL resurrection abilities
            if ((activeAbilities.includes(34) || activeAbilities.includes(68) || activeAbilities.includes(74)) && dmg >= Number(target.HEALTH || 0)) {
                if (!resurrectionUsed) {
                    let reviveHp;
                    let abilityName;
                    
                    if (activeAbilities.includes(68)) {
                        reviveHp = Math.ceil(Number(target.MAX_HEALTH || 100) * 0.5);
                        abilityName = 'RESURRECTION';
                    } else if (activeAbilities.includes(74)) {
                        reviveHp = Math.ceil(Number(target.MAX_HEALTH || 100) * 0.4);
                        abilityName = 'REBIRTH';
                    } else {
                        reviveHp = Math.ceil(Number(target.MAX_HEALTH || 100) * 0.3);
                        abilityName = 'PHOENIX';
                    }
                    
                    target.HEALTH = reviveHp;
                    resurrectionUsed = true;
                    updatePlayerArea();
                    logCombat(`ðŸ”¥ ${abilityName}: ${target.NAME} revived at ${Math.round(reviveHp / target.MAX_HEALTH * 100)}% HP! (once per battle)`);
                    dmg = 0; // Cancel the killing blow
                } else {
                    // No resurrection available, switch to next member
                    switchToNextMember(targetKey);
                }
            } else if (dmg >= Number(target.HEALTH || 0)) {
                // Member died without resurrection, switch to next member
                switchToNextMember(targetKey);
            }
            
            // Auto-switch to next member on death
            function switchToNextMember(deadMemberKey) {
                // Find next alive member
                const memberKeys = ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE'];
                const deadIndex = memberKeys.indexOf(deadMemberKey);
                
                // Check which slot the dead member was in
                const wasPlayer1 = (deadMemberKey === activeBattleMember);
                const wasPlayer2 = (deadMemberKey === activeBattleMember2);
                
                if (!wasPlayer1 && !wasPlayer2) return; // Not an active player
                
                // Find next alive member not already active
                for (let i = deadIndex + 1; i < memberKeys.length; i++) {
                    const candidateKey = memberKeys[i];
                    const candidate = PARTY_STATS[candidateKey];
                    
                    if (candidate && Number(candidate.HEALTH || 0) > 0 && 
                        candidateKey !== activeBattleMember && candidateKey !== activeBattleMember2) {
                        
                        // Switch the slot
                        if (wasPlayer1) {
                            activeBattleMember = candidateKey;
                            logCombat(`ðŸ’€ ${PARTY_STATS[deadMemberKey].NAME} fell! ${candidate.NAME} takes their place!`);
                        } else {
                            activeBattleMember2 = candidateKey;
                            logCombat(`ðŸ’€ ${PARTY_STATS[deadMemberKey].NAME} fell! ${candidate.NAME} takes their place!`);
                        }
                        
                        updatePlayerArea();
                        updatePlayerStatsDisplay();
                        renderAttacksForPlayer();
                        updatePartySlotHighlight();
                        return;
                    }
                }
                
                logCombat(`ðŸ’€ ${PARTY_STATS[deadMemberKey].NAME} fell! No replacement available.`);
            }
            
            // Ability 45: Divine Intervention - Survive lethal damage once per battle at 1 HP
            if (activeAbilities.includes(45) && dmg >= Number(target.HEALTH || 0)) {
                if (!window.divineUsed) window.divineUsed = {};
                if (!window.divineUsed[targetKey]) {
                    target.HEALTH = 1;
                    window.divineUsed[targetKey] = true;
                    updatePlayerArea();
                    logCombat(`âœ¨ DIVINE INTERVENTION: ${target.NAME} survives at 1 HP!`);
                    dmg = 0;
                }
            }
            
                            // Apply burn ground damage to this enemy
                            if (burnGroundEffects[enemyIndex]) {
                                const burn = burnGroundEffects[enemyIndex];
                                const burnDmg = burn.damage;
                                const curEnemyHp = Number(enemyWrap.dataset.hp);
                                enemyWrap.dataset.hp = Math.max(0, curEnemyHp - burnDmg);
                                updateEnemyBar(enemyWrap);
                                logCombat(`ðŸ”¥ Burn ground: ${burnDmg} damage to enemy #${enemyIndex + 1}`);
                                
                                burn.duration--;
                                if (burn.duration <= 0) {
                                    delete burnGroundEffects[enemyIndex];
                                    logCombat(`ðŸ”¥ Burn ground expired on enemy #${enemyIndex + 1}`);
                                }
                            }
                            
                            target.HEALTH = (Number(target.HEALTH) || Number(target.MAX_HEALTH) || 0) - dmg;
                            
                            // Vampiric Onslaught (challenge ID 2): Enemies heal for damage they deal to players
                            if (isChallenge && battleData.challengeId === 2 && dmg > 0) {
                                const healAmount = dmg;
                                const newHp = Math.min(Number(enemyWrap.dataset.maxHp), Number(enemyWrap.dataset.hp) + healAmount);
                                enemyWrap.dataset.hp = newHp;
                                updateEnemyBar(enemyWrap);
                                logCombat(`ðŸ©¸ Vampiric: Enemy heals ${healAmount} HP from attack!`);
                            }
            
            // Apply special enemy status effects using the targeted player's key
            // (enemyKey already declared at function scope)
            const enemyBaseStats = ENEMY_BASE_STATS[enemyKey];
            if (enemyBaseStats && enemyBaseStats.attackStatus) {
                // Frozen corpse applies chill on attack
                if (enemyBaseStats.attackStatus === 'chill') {
                    applyStatusEffect(target, 'player', targetKey, 'chill', dmg);
                    logCombat(`â„ï¸ Frozen Touch: ${target.NAME} has been chilled! (25% damage reduction for 3 turns)`);
                }
                // Dragon applies burn on attack
                if (enemyBaseStats.attackStatus === 'burn') {
                    applyStatusEffect(target, 'player', targetKey, 'burn', dmg);
                    logCombat(`ðŸ‰ Dragon's Inferno: ${target.NAME} has been burned! (3% max HP damage per turn)`);
                }
            }
            
            // Mage: Apply random status effect
            if (enemyKey === 'Mage') {
                const randomStatuses = ['burn', 'bleed', 'chill'];
                const chosenStatus = randomStatuses[Math.floor(Math.random() * randomStatuses.length)];
                applyStatusEffect(target, 'player', targetKey, chosenStatus, dmg);
                logCombat(`ðŸ”® Arcane Curse: Mage applied ${chosenStatus.toUpperCase()}!`);
            }
            
            // Alien: Apply burn status effect
            if (enemyKey === 'alien') {
                applyStatusEffect(target, 'player', targetKey, 'burn', dmg);
                logCombat(`ðŸ‘½ Alien Fire: Applied BURN!`);
            }
            
            // Crawler: Apply bleed status effect
            if (enemyKey === 'crawler') {
                applyStatusEffect(target, 'player', targetKey, 'bleed', dmg);
                logCombat(`ðŸ¦‚ Venomous Bite: Applied BLEED!`);
            }
            
            // Vine Lasher: Apply leech status effect
            if (enemyKey === 'vineLasher') {
                applyStatusEffect(target, 'player', targetKey, 'leech', dmg);
                logCombat(`ðŸŒ¿ Draining Vines: Applied LEECH!`);
            }
            
            // Cursed Knight: Apply grim status effect
            if (enemyKey === 'cursedKnight') {
                applyStatusEffect(target, 'player', targetKey, 'grim', dmg);
                logCombat(`âš”ï¸ Cursed Blade: Applied GRIM!`);
            }
            
            // Lightning Shark: Apply lightning status (ignore next attack with 2 turn cooldown)
            if (enemyKey === 'lightning_shark') {
                // Initialize lightning cooldown if not exists
                if (typeof playerLightningCooldown === 'undefined') window.playerLightningCooldown = 0;
                if (playerLightningCooldown <= 0) {
                    window.playerLightningActive = true;
                    window.playerLightningCooldown = 2;
                    logCombat(`âš¡ Lightning Shock: Player's next enemy attack will be ignored!`);
                }
            }                            // Update player health UI
                            updatePlayerArea();
                                        // Play hit animation on player image
                                        try {
                                            // Determine which player image to animate based on target
                                            const playerImgId = (targetKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                            const pimg = document.getElementById(playerImgId);
                                            if (pimg) {
                                                pimg.classList.remove('hit-animation');
                                                void pimg.offsetWidth;
                                                pimg.classList.add('hit-animation');
                                                setTimeout(()=> pimg.classList.remove('hit-animation'), 700);
                                            }
                                        } catch(e){}
                                        
                                        // Show damage popup on player
                                        if (dmg > 0) {
                                            const playerImgId = (targetKey === activeBattleMember2) ? 'player-2' : 'player-1';
                                            const pimg = document.getElementById(playerImgId);
                                            if (pimg) {
                                                showDamagePopup(pimg, dmg);
                                            }
                                        }
                                        
                                        // ===== DEFENSIVE ITEM ABILITIES =====
                                        // Check if player survived to trigger defensive abilities
                                        const playerSurvived = Number(target.HEALTH) > 0;
                                        const equippedAbilities = getEquippedAbilities(targetKey);
                                        
                                        // Ability 3: Magi Reflect - Reflect 10% of holder's magic damage if survived magic attack
                                        if (playerSurvived && isMagicAttack && equippedAbilities.includes(3)) {
                                            const playerMagic = Number(target.MAGIC || 0);
                                            const reflectDmg = Math.max(1, Math.round(playerMagic * 0.1));
                                            const curEnemyHp = Number(enemyWrap.dataset.hp);
                                            enemyWrap.dataset.hp = Math.max(0, curEnemyHp - reflectDmg);
                                            updateEnemyBar(enemyWrap);
                                            logCombat(`ðŸ”® Magi Reflect: ${reflectDmg} magic damage reflected!`);
                                        }
                                        
                                        // Ability 4: Spikes - Counter with 20% STR damage + apply bleed
                                        if (equippedAbilities.includes(4)) {
                                            const playerStr = Number(target.STRENGTH || 0);
                                            const spikeDmg = Math.max(1, Math.round(playerStr * 0.2));
                                            const curEnemyHp = Number(enemyWrap.dataset.hp);
                                            enemyWrap.dataset.hp = Math.max(0, curEnemyHp - spikeDmg);
                                            updateEnemyBar(enemyWrap);
                                            
                                            // Apply bleed to the enemy
                                            applyStatusEffect(enemyWrap, 'enemy', enemyIndex, 'bleed', spikeDmg);
                                            logCombat(`ðŸŒµ Spikes: ${spikeDmg} counter damage + bleed!`);
                                        }
                                        
                                        if (Number(target.HEALTH) <= 0) {
                                                const activeMember = PARTY_STATS[getActiveBattleMember()];
                                                logCombat(`${activeMember.NAME} has been defeated! Choose another member...`);
                                                handleMemberDeath();
                                                return;
                                        }
                        }

                        // Handle when active member dies - prompt for member switch
                        function handleMemberDeath(){
                            combatRunning = false;
                            
                            // Check if ALL party members are dead (not just switchable ones)
                            const allMembersDead = ['ONE','TWO','THREE','FOUR','FIVE'].every(key => {
                                const m = PARTY_STATS[key];
                                return !m || Number(m.HEALTH) <= 0;
                            });
                            
                            if (allMembersDead) {
                                logCombat('All party members defeated! Battle lost...');
                                combatRunning = false;
                                
                                // Count defeated enemies
                                const allEnemies = getEnemyWrappers();
                                const totalEnemies = allEnemies.length;
                                const defeatedEnemies = allEnemies.filter(w => Number(w.dataset.hp) <= 0).length;
                                
                                // Calculate partial rewards: 10% base + 30% per enemy defeated
                                const level = battleData.level || 1;
                                const baseExp = Math.max(10, Math.round(100 * level));
                                const defeatExpPercent = 0.10 + (0.30 * (defeatedEnemies / totalEnemies));
                                const partialExp = Math.round(baseExp * defeatExpPercent);
                                
                                // Award partial exp to participants
                                const expInfo = awardExpToParticipants(level, partialExp);
                                
                                // Show defeat modal
                                showDefeatModal(defeatedEnemies, totalEnemies, expInfo, level);
                                return;
                            }
                            
                            // Filter alive members, excluding currently active ones
                            const aliveMembers = ['ONE','TWO','THREE','FOUR','FIVE'].filter(key => {
                                const m = PARTY_STATS[key];
                                // Exclude currently active members and only include alive members
                                return m && Number(m.HEALTH) > 0 && key !== activeBattleMember && key !== activeBattleMember2;
                            });
                            
                            // If no members to switch to, resume combat with remaining active members
                            if (aliveMembers.length === 0) {
                                combatRunning = true;
                                logCombat('No members available to switch! Continuing with remaining active members...');
                                // Recalculate queue and resume combat
                                const savedIndex = queueIndex;
                                recalculateActionQueue();
                                queueIndex = Math.min(savedIndex, actionQueue.length - 1);
                                if (queueIndex < 0) queueIndex = 0;
                                setTimeout(combatTick, COMBAT_TICK_MS);
                                return;
                            }

                            // Create overlay to force member selection
                            const overlay = document.createElement('div');
                            overlay.style.position = 'fixed';
                            overlay.style.top = '0';
                            overlay.style.left = '0';
                            overlay.style.width = '100%';
                            overlay.style.height = '100%';
                            overlay.style.background = 'rgba(0,0,0,0.8)';
                            overlay.style.display = 'flex';
                            overlay.style.flexDirection = 'column';
                            overlay.style.justifyContent = 'center';
                            overlay.style.alignItems = 'center';
                            overlay.style.zIndex = '99999';

                            const dialog = document.createElement('div');
                            dialog.style.background = 'rgba(50,50,50,0.95)';
                            dialog.style.border = '3px solid rgb(255,215,0)';
                            dialog.style.borderRadius = '10px';
                            dialog.style.padding = '30px';
                            dialog.style.textAlign = 'center';
                            dialog.style.color = 'white';

                            const title = document.createElement('h2');
                            title.textContent = 'Choose a Party Member to Continue';
                            title.style.marginBottom = '20px';
                            title.style.color = 'rgb(255,215,0)';
                            dialog.appendChild(title);

                            const buttonContainer = document.createElement('div');
                            buttonContainer.style.display = 'flex';
                            buttonContainer.style.gap = '10px';
                            buttonContainer.style.flexWrap = 'wrap';
                            buttonContainer.style.justifyContent = 'center';

                            aliveMembers.forEach((key, idx) => {
                                const member = PARTY_STATS[key];
                                const btn = document.createElement('button');
                                btn.textContent = `${member.NAME} (Lv${member.LEVEL})`;
                                btn.style.padding = '12px 20px';
                                btn.style.fontSize = '16px';
                                btn.style.background = 'rgba(100,200,100,0.8)';
                                btn.style.color = 'white';
                                btn.style.border = '2px solid rgba(100,200,100,1)';
                                btn.style.borderRadius = '5px';
                                btn.style.cursor = 'pointer';
                                btn.style.transition = 'all 0.3s';
                                btn.onmouseover = () => {
                                    btn.style.background = 'rgba(100,200,100,1)';
                                    btn.style.transform = 'scale(1.05)';
                                };
                                btn.onmouseout = () => {
                                    btn.style.background = 'rgba(100,200,100,0.8)';
                                    btn.style.transform = 'scale(1)';
                                };
                                btn.onclick = () => {
                                    switchBattleMember(key, true); // true = emergency switch, bypass turn check
                                    overlay.remove();
                                    combatRunning = true;
                                    // Reset player action flags to allow combat to proceed
                                    playerCanAct = false;
                                    playerWaiting = false;
                                    waitingForPlayerAction = false;
                                    // Recalculate action queue for new member and preserve position
                                    const savedIndex = queueIndex;
                                    recalculateActionQueue();
                                    queueIndex = Math.min(savedIndex, actionQueue.length - 1);
                                    if (queueIndex < 0) queueIndex = 0;
                                    logCombat(`Queue recalculated after death (position: ${queueIndex}/${actionQueue.length})`);
                                    // Resume combat after short delay
                                    setTimeout(combatTick, COMBAT_TICK_MS);
                                };
                                buttonContainer.appendChild(btn);
                            });

                            dialog.appendChild(buttonContainer);
                            overlay.appendChild(dialog);
                            document.body.appendChild(overlay);
                        }

                        const COMBAT_TICK_MS = 1400; // slower tick so actions are visible and damage popups can be seen

                        // Loop tick
                        function combatTick(){
                            if (!combatRunning) return;
                            // if no alive enemies or active player dead -> end
                            const aliveEnemy = getFirstAliveEnemy();
                            if (!aliveEnemy) { combatRunning = false; return; }
                            const activeMember = PARTY_STATS[getActiveBattleMember()];
                            const playerAlive = activeMember && Number(activeMember.HEALTH) > 0;
                            if (!playerAlive) { logCombat('Current member is KO\'d!'); handleMemberDeath(); return; }

                            // If waiting for player to complete their action, skip this tick
                            if (waitingForPlayerAction) {
                                setTimeout(combatTick, COMBAT_TICK_MS);
                                return;
                            }

                            const actor = pickNextActor();
                            if (actor.type === 'player'){
                                // Prompt player to act and set flag to pause queue
                                waitingForPlayerAction = true;
                                performPlayerAction(actor.playerNum);
                            } else {
                                // Reset consecutive attack counters when enemy interrupts player's turn
                                consecutiveAttacks = 0;
                                overuseConsecutive = 0;
                                pixelComboCount = 0;
                                performEnemyAction(actor.enemyIndex);
                            }

                            // schedule next tick only if not waiting for player
                            if (!waitingForPlayerAction) {
                                setTimeout(combatTick, COMBAT_TICK_MS);
                            } else {
                                // If waiting for player, still schedule a tick but it will return early
                                setTimeout(combatTick, COMBAT_TICK_MS);
                            }
                        }

                        // Start the ticking loop
                        setTimeout(combatTick, 500);
                    }

                    // Function to start combat (called by button or auto-start)
                    function startCombat() {
                        try {
                            logCombat('Combat started');
                            // Log initial stats
                            const member = PARTY_STATS && PARTY_STATS['ONE'];
                            if (member) {
                                logCombat(`Player HP: ${member.HEALTH}/${member.MAX_HEALTH} STR:${member.STRENGTH} MAG:${member.MAGIC} SPD:${member.SPEED}`);
                            }
                            const first = getEnemyWrappers()[0];
                            if (first) {
                                logCombat(`Enemy HP: ${first.dataset.hp}/${first.dataset.maxHp} STR:${first.dataset.str} SPD:${first.dataset.speed||first.dataset.str}`);
                            }
                            startCombatLoop();
                            // Hide start button after combat starts
                            const startBtn = document.getElementById('start-combat-btn');
                            if (startBtn) {
                                startBtn.style.display = 'none';
                            }
                        } catch(e) {
                            console.error('Error starting combat:', e);
                            logCombat('Error starting combat. Please refresh the page.');
                        }
                    }
                    
                    // Make startCombat globally accessible for button onclick
                    window.startCombat = startCombat;
                    
                    // Auto-start combat on battle entry
                    try {
                        startCombat();
                    } catch(e) {
                        console.error('Auto-start failed:', e);
                        // If auto-start fails, keep button visible for manual start
                    }
                    // -------------------- End combat engine --------------------

        // -------------------- Victory Rewards (loot + EXP) --------------------
        // Player level cap
        const MAX_PLAYER_LEVEL = 75;
        function xpToNext(level){
            // At or above cap: no further leveling
            if ((Number(level)||1) >= MAX_PLAYER_LEVEL) return Infinity;
            // Per spec: level * 100 * sqrt(level) to reach next level
            const lvl = Math.max(1, Number(level)||1);
            return Math.max(1, Math.round(lvl * 100 * Math.sqrt(lvl)));
        }

        function showDefeatModal(defeatedEnemies, totalEnemies, expInfo, level) {
            // Build modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.85)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '100000';

            const panel = document.createElement('div');
            panel.style.background = 'rgba(40,20,20,0.95)';
            panel.style.border = '3px solid #cc0000';
            panel.style.borderRadius = '10px';
            panel.style.padding = '20px 24px';
            panel.style.color = 'white';
            panel.style.minWidth = '320px';
            panel.style.maxWidth = '520px';

            const title = document.createElement('h2');
            title.textContent = 'Defeat';
            title.style.marginTop = '0';
            title.style.color = '#cc0000';
            panel.appendChild(title);

            const message = document.createElement('p');
            message.textContent = 'Your party has been defeated...';
            message.style.marginBottom = '16px';
            panel.appendChild(message);

            // Enemies defeated section
            const enemyDiv = document.createElement('div');
            enemyDiv.style.margin = '10px 0 6px';
            const defeatPercent = Math.round((defeatedEnemies / totalEnemies) * 100);
            enemyDiv.innerHTML = `<strong>Enemies Defeated:</strong> ${defeatedEnemies} / ${totalEnemies} (${defeatPercent}%)`;
            panel.appendChild(enemyDiv);

            // EXP section
            const expDiv = document.createElement('div');
            expDiv.style.margin = '6px 0 10px';
            const fullReward = Math.max(10, Math.round(100 * level));
            const totalPercent = Math.round((expInfo.totalExp / fullReward) * 100);
            expDiv.innerHTML = `<strong>Partial EXP:</strong> ${expInfo.totalExp} (${totalPercent}% of full reward)`;
            const list = document.createElement('ul');
            list.style.margin = '8px 0 0';
            list.style.paddingLeft = '18px';
            expInfo.participants.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name}: +${p.gained} EXP â€¢ Lv ${p.level}` + (p.levelsGained>0?` (â†‘ +${p.levelsGained})`:'' );
                list.appendChild(li);
            });
            panel.appendChild(expDiv);
            panel.appendChild(list);

            const btnRow = document.createElement('div');
            btnRow.style.display = 'flex';
            btnRow.style.gap = '10px';
            btnRow.style.marginTop = '16px';
            btnRow.style.justifyContent = 'flex-end';

            const ok = document.createElement('button');
            ok.textContent = 'Return to Map';
            ok.style.padding = '10px 14px';
            ok.style.background = 'rgba(200,50,50,0.9)';
            ok.style.border = '2px solid rgba(200,50,50,1)';
            ok.style.borderRadius = '6px';
            ok.style.color = 'white';
            ok.style.cursor = 'pointer';
            ok.onclick = ()=>{ 
                overlay.remove(); 
                // Save game data before leaving
                if (typeof saveGameData === 'function') saveGameData();
                window.location.href = 'map.html'; 
            };

            btnRow.appendChild(ok);
            panel.appendChild(btnRow);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
        }

        function awardExpToParticipants(level, customTotalExp = null){
            // Base total EXP proportional to level
            const totalExp = customTotalExp !== null ? customTotalExp : Math.max(10, Math.round(100 * (Number(level)||1)));
            const participants = Array.from(battleParticipants);
            const count = participants.length || 1;
            const per = Math.floor(totalExp / count);
            const breakdown = [];

            participants.forEach(key => {
                const m = PARTY_STATS[key];
                if (!m) return;
                if (typeof m.XP !== 'number') m.XP = 0;
                if (typeof m.LEVEL !== 'number' || m.LEVEL < 1) m.LEVEL = 1;
                let gain = per;
                let leveled = 0;
                // Clamp current level before awarding
                if (m.LEVEL >= MAX_PLAYER_LEVEL) {
                    m.LEVEL = MAX_PLAYER_LEVEL;
                    m.XP = 0; // at cap, no XP stored
                } else {
                    m.XP += gain;
                    let need = xpToNext(m.LEVEL);
                    while (m.XP >= need && m.LEVEL < MAX_PLAYER_LEVEL) {
                        m.XP -= need;
                        m.LEVEL += 1;
                        leveled += 1;
                        need = xpToNext(m.LEVEL);
                    }
                }
                // Compute next requirement display
                const nextReq = (m.LEVEL >= MAX_PLAYER_LEVEL) ? 'MAX' : xpToNext(m.LEVEL);
                breakdown.push({ key, name: m.NAME||key, gained: gain, newXP: m.XP, level: m.LEVEL, levelsGained: leveled, nextReq });
            });

            // Recalculate stats after possible level ups
            try { if (typeof updateStats === 'function') updateStats(); } catch(e){}
            try { if (typeof saveGameData === 'function') saveGameData(); } catch(e){}

            return { totalExp, perExp: per, participants: breakdown };
        }

        function generateVictoryLoot(level){
            try {
                if (typeof window.generateRandomItem === 'function') {
                    // Check if this is the first time clearing this level
                    const progression = typeof window.loadDungeonProgression === 'function' ? window.loadDungeonProgression() : { clearedLevels: [] };
                    const isFirstClear = !progression.clearedLevels.includes(level);
                    const numItems = isFirstClear ? 3 : 1;
                    
                    // Boss tiles grant bonus loot
                    const isBossTile = battleData.isBossTile || false;
                    const items = [];
                    
                    for (let i = 0; i < numItems; i++) {
                        let item;
                        // LEGENDARY GUARANTEED: Only at boss stages 40 and 50 (normal mode), 100 (hard mode), 150 (hell mode)
                        if (isBossTile && (level === 40 || level === 50 || level === 100 || level === 150)) {
                            item = window.generateRandomItem(level, 'Legendary');
                            if (i === 0) {
                                logCombat('ï¿½âœ¨ LEGENDARY BOSS REWARD: Guaranteed Legendary Item! âœ¨ðŸŒŸ');
                                console.log(`[BOSS REWARD] Level ${level} boss guaranteed legendary!`);
                            }
                        } else {
                            // All other stages use normal rarity distribution based on level
                            item = window.generateRandomItem(level);
                        }
                        if (item) items.push(item);
                    }
                    
                    if (isFirstClear && items.length > 1) {
                        logCombat(`âœ¨ FIRST CLEAR BONUS: ${items.length}x loot drops!`);
                    }
                    
                    try { if (typeof saveGameData === 'function') saveGameData(); } catch(e){}
                    return items;
                }
            } catch(e) { console.error('generateRandomItem failed', e); }
            return [];
        }

        function showDefeatModal(defeatedEnemies, totalEnemies, expInfo) {
            // Build modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.85)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '100000';

            const panel = document.createElement('div');
            panel.style.background = 'rgba(40,20,20,0.95)';
            panel.style.border = '3px solid #cc0000';
            panel.style.borderRadius = '10px';
            panel.style.padding = '20px 24px';
            panel.style.color = 'white';
            panel.style.minWidth = '320px';
            panel.style.maxWidth = '520px';

            const title = document.createElement('h2');
            title.textContent = 'Defeat';
            title.style.marginTop = '0';
            title.style.color = '#cc0000';
            panel.appendChild(title);

            const message = document.createElement('p');
            message.textContent = 'Your party has been defeated...';
            message.style.marginBottom = '16px';
            panel.appendChild(message);

            // Enemies defeated section
            const enemyDiv = document.createElement('div');
            enemyDiv.style.margin = '10px 0 6px';
            const defeatPercent = Math.round((defeatedEnemies / totalEnemies) * 100);
            enemyDiv.innerHTML = `<strong>Enemies Defeated:</strong> ${defeatedEnemies} / ${totalEnemies} (${defeatPercent}%)`;
            panel.appendChild(enemyDiv);

            // EXP section
            const expDiv = document.createElement('div');
            expDiv.style.margin = '6px 0 10px';
            const totalPercent = Math.round((expInfo.totalExp / (Math.round((battleData.level||1) * 100 * Math.sqrt(battleData.level||1)))) * 100);
            expDiv.innerHTML = `<strong>Partial EXP:</strong> ${expInfo.totalExp} (${totalPercent}% of full reward)`;
            const list = document.createElement('ul');
            list.style.margin = '8px 0 0';
            list.style.paddingLeft = '18px';
            expInfo.participants.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name}: +${p.gained} EXP â€¢ Lv ${p.level}` + (p.levelsGained>0?` (â†‘ +${p.levelsGained})`:'' );
                list.appendChild(li);
            });
            panel.appendChild(expDiv);
            panel.appendChild(list);

            const btnRow = document.createElement('div');
            btnRow.style.display = 'flex';
            btnRow.style.gap = '10px';
            btnRow.style.marginTop = '16px';
            btnRow.style.justifyContent = 'flex-end';

            const ok = document.createElement('button');
            ok.textContent = 'Return to Map';
            ok.style.padding = '10px 14px';
            ok.style.background = 'rgba(200,50,50,0.9)';
            ok.style.border = '2px solid rgba(200,50,50,1)';
            ok.style.borderRadius = '6px';
            ok.style.color = 'white';
            ok.style.cursor = 'pointer';
            ok.onclick = ()=>{ 
                overlay.remove(); 
                // Save game data before leaving
                if (typeof saveGameData === 'function') saveGameData();
                window.location.href = 'map.html'; 
            };

            btnRow.appendChild(ok);
            panel.appendChild(btnRow);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
        }

        function showVictoryRewards(level){
            // Stop battle music and play victory music
            if (battleMusic) {
                battleMusic.pause();
                battleMusic = null;
            }
            
            const musicEnabled = localStorage.getItem('musicEnabled') === 'true';
            if (musicEnabled) {
                const victorySound = new Audio('audio/soundEffects/victoryMusic.wav');
                victorySound.volume = 0.5;
                victorySound.play().catch(err => console.log('Could not play victory music:', err));
            }
            
            // Compute rewards
            const expInfo = awardExpToParticipants(level);
            const lootArray = generateVictoryLoot(level);

            // Check if this is a challenge mode victory
            const isChallengeVictory = battleData.isChallenge || false;
            const challengeReward = battleData.challengeReward || null;
            const challengeId = battleData.challengeId || null;
            const isBossTile = battleData.isBossTile || false;
            
            // Award gems based on stage type
            let gemsAwarded = 0;
            if (isChallengeVictory) {
                gemsAwarded = Math.floor(10 + level * 2); // Challenge stages give more gems
            } else if (isBossTile) {
                gemsAwarded = Math.floor(5 + level * 1.5); // Boss stages give good gems
            } else {
                gemsAwarded = Math.floor(2 + level * 0.5); // Regular stages give some gems
            }
            
            if (typeof GEMS !== 'undefined') {
                GEMS += gemsAwarded;
            } else {
                window.GEMS = gemsAwarded;
            }
            
            // Save game data to persist gems
            if (typeof saveGameData === 'function') saveGameData();
            
            // Handle challenge completion
            if (isChallengeVictory && challengeId && challengeReward) {
                // Mark challenge as completed
                try {
                    const completed = JSON.parse(localStorage.getItem('completedChallenges') || '[]');
                    if (!completed.includes(challengeId)) {
                        completed.push(challengeId);
                        localStorage.setItem('completedChallenges', JSON.stringify(completed));
                    }
                } catch(e) {
                    console.error('Failed to mark challenge as completed:', e);
                }
                
                // Award enchantment
                if (typeof window.addEnchantment === 'function') {
                    window.addEnchantment(challengeReward);
                    logCombat(`ðŸŽ Challenge Reward: ${challengeReward} enchantment unlocked!`);
                }
            } else {
                // Normal/Hard mode - unlock progression
                try { if (typeof window.clearLevelAndUnlock === 'function') window.clearLevelAndUnlock(level); } catch(e) { console.error('clearLevelAndUnlock failed', e); }
            }

            // Build modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.8)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '100000';

            const panel = document.createElement('div');
            panel.style.background = 'rgba(30,30,30,0.95)';
            panel.style.border = isChallengeVictory ? '3px solid #a335ee' : '3px solid gold';
            panel.style.borderRadius = '10px';
            panel.style.padding = '20px 24px';
            panel.style.color = 'white';
            panel.style.minWidth = '320px';
            panel.style.maxWidth = '600px';

            const title = document.createElement('h2');
            title.textContent = isChallengeVictory ? 'Challenge Complete!' : 'Victory!';
            title.style.marginTop = '0';
            title.style.color = isChallengeVictory ? '#a335ee' : 'gold';
            panel.appendChild(title);
            
            // Show gems awarded
            if (gemsAwarded > 0) {
                const gemDiv = document.createElement('div');
                gemDiv.style.margin = '10px 0';
                gemDiv.style.padding = '10px';
                gemDiv.style.background = 'rgba(0, 200, 255, 0.2)';
                gemDiv.style.border = '2px solid #00c8ff';
                gemDiv.style.borderRadius = '8px';
                gemDiv.innerHTML = `<strong style="color: #00c8ff;">ðŸ’Ž Gems Earned:</strong> <span style="color: #fff; font-weight: bold;">+${gemsAwarded}</span> <span style="color: #aaa;">(Total: ${GEMS || 0})</span>`;
                panel.appendChild(gemDiv);
            }
            
            // Show enchantment reward for challenges
            if (isChallengeVictory && challengeReward) {
                const rewardDiv = document.createElement('div');
                rewardDiv.style.margin = '10px 0';
                rewardDiv.style.padding = '15px';
                rewardDiv.style.background = 'rgba(163, 53, 238, 0.2)';
                rewardDiv.style.border = '2px solid #a335ee';
                rewardDiv.style.borderRadius = '8px';
                rewardDiv.innerHTML = `<strong style="color: #a335ee;">ðŸŒŸ Enchantment Unlocked:</strong> <span style="color: #ff8000; font-weight: bold;">${challengeReward}</span>`;
                panel.appendChild(rewardDiv);
            }

            // Loot section - display multiple items
            const lootDiv = document.createElement('div');
            lootDiv.style.margin = '10px 0 6px';
            const lootHeader = document.createElement('strong');
            lootHeader.textContent = `Loot (${lootArray.length}):`;
            lootDiv.appendChild(lootHeader);
            
            // Track which items are marked for deletion (declare outside to be accessible in button handler)
            const markedForDeletion = new Set();
            
            if (lootArray.length > 0) {
                const itemGrid = document.createElement('div');
                itemGrid.style.display = 'grid';
                itemGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(100px, 1fr))';
                itemGrid.style.gap = '10px';
                itemGrid.style.marginTop = '10px';
                
                lootArray.forEach((loot, index) => {
                    if (!loot) return;
                    const itemCard = document.createElement('div');
                    itemCard.style.textAlign = 'center';
                    itemCard.style.padding = '8px';
                    itemCard.style.background = 'rgba(0,0,0,0.3)';
                    itemCard.style.borderRadius = '6px';
                    itemCard.style.cursor = 'pointer';
                    itemCard.style.transition = 'all 0.2s';
                    itemCard.style.position = 'relative';
                    
                    const rarityColor = (loot.rarity && typeof window.getRarityColor === 'function') ? window.getRarityColor(loot.rarity) : 'gold';
                    
                    // Click handler to toggle deletion mark
                    itemCard.onclick = () => {
                        if (markedForDeletion.has(index)) {
                            // Unmark for deletion
                            markedForDeletion.delete(index);
                            itemCard.style.opacity = '1';
                            itemCard.style.background = 'rgba(0,0,0,0.3)';
                            itemCard.style.border = 'none';
                            deleteLabel.style.display = 'none';
                        } else {
                            // Mark for deletion
                            markedForDeletion.add(index);
                            itemCard.style.opacity = '0.5';
                            itemCard.style.background = 'rgba(100,0,0,0.4)';
                            itemCard.style.border = '2px solid #ff0000';
                            deleteLabel.style.display = 'block';
                        }
                    };
                    
                    if (loot.image) {
                        const img = document.createElement('img');
                        img.src = loot.image;
                        img.alt = loot.name;
                        img.style.width = '64px';
                        img.style.height = '64px';
                        img.style.objectFit = 'contain';
                        img.style.border = `3px solid ${rarityColor}`;
                        img.style.boxShadow = `0 0 10px ${rarityColor}`;
                        img.style.borderRadius = '4px';
                        itemCard.appendChild(img);
                    }
                    
                    const itemName = document.createElement('div');
                    itemName.style.color = rarityColor;
                    itemName.style.fontSize = '0.9em';
                    itemName.style.marginTop = '4px';
                    itemName.textContent = `${loot.name}`;
                    itemCard.appendChild(itemName);
                    
                    const itemLevel = document.createElement('div');
                    itemLevel.style.color = '#aaa';
                    itemLevel.style.fontSize = '0.8em';
                    itemLevel.textContent = `Lv ${loot.level || level}`;
                    itemCard.appendChild(itemLevel);
                    
                    // Delete label (hidden by default)
                    const deleteLabel = document.createElement('div');
                    deleteLabel.textContent = 'ðŸ—‘ï¸ DELETE';
                    deleteLabel.style.position = 'absolute';
                    deleteLabel.style.top = '2px';
                    deleteLabel.style.right = '2px';
                    deleteLabel.style.background = 'rgba(255,0,0,0.9)';
                    deleteLabel.style.color = 'white';
                    deleteLabel.style.fontSize = '0.7em';
                    deleteLabel.style.padding = '2px 4px';
                    deleteLabel.style.borderRadius = '3px';
                    deleteLabel.style.fontWeight = 'bold';
                    deleteLabel.style.display = 'none';
                    itemCard.appendChild(deleteLabel);
                    
                    itemGrid.appendChild(itemCard);
                });
                
                lootDiv.appendChild(itemGrid);
                
                // Add deletion info text
                const deletionInfo = document.createElement('div');
                deletionInfo.style.fontSize = '0.85em';
                deletionInfo.style.color = '#aaa';
                deletionInfo.style.marginTop = '8px';
                deletionInfo.style.fontStyle = 'italic';
                deletionInfo.textContent = 'Click items to mark for deletion';
                lootDiv.appendChild(deletionInfo);
            } else {
                const noLoot = document.createElement('div');
                noLoot.textContent = 'â€”';
                noLoot.style.marginTop = '6px';
                lootDiv.appendChild(noLoot);
            }
            panel.appendChild(lootDiv);

            // EXP section
            const expDiv = document.createElement('div');
            expDiv.style.margin = '6px 0 10px';
            expDiv.innerHTML = `<strong>EXP:</strong> ${expInfo.totalExp} total â€” ${expInfo.perExp} each (${expInfo.participants.length} participant${expInfo.participants.length!==1?'s':''})`;
            const list = document.createElement('ul');
            list.style.margin = '8px 0 0';
            list.style.paddingLeft = '18px';
            expInfo.participants.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name}: +${p.gained} EXP â€¢ Lv ${p.level}` + (p.levelsGained>0?` (â†‘ +${p.levelsGained})`:'' ) + ` â€¢ Next: ${p.nextReq}`;
                list.appendChild(li);
            });
            panel.appendChild(expDiv);
            panel.appendChild(list);

            const btnRow = document.createElement('div');
            btnRow.style.display = 'flex';
            btnRow.style.gap = '10px';
            btnRow.style.marginTop = '16px';
            btnRow.style.justifyContent = 'flex-end';

            const ok = document.createElement('button');
            ok.textContent = 'Continue';
            ok.style.padding = '10px 14px';
            ok.style.background = 'rgba(100,200,100,0.9)';
            ok.style.border = '2px solid rgba(100,200,100,1)';
            ok.style.borderRadius = '6px';
            ok.style.color = 'white';
            ok.style.cursor = 'pointer';
            ok.onclick = ()=>{ 
                // Remove marked items from INVENTORY before continuing
                if (markedForDeletion.size > 0 && typeof INVENTORY !== 'undefined') {
                    const itemsToDelete = [];
                    lootArray.forEach((loot, index) => {
                        if (markedForDeletion.has(index)) {
                            itemsToDelete.push(loot);
                        }
                    });
                    
                    itemsToDelete.forEach(item => {
                        const idx = INVENTORY.findIndex(i => i === item || (i._uid && item._uid && i._uid === item._uid));
                        if (idx !== -1) {
                            INVENTORY.splice(idx, 1);
                        }
                    });
                    
                    try { if (typeof saveGameData === 'function') saveGameData(); } catch(e){}
                }
                
                overlay.remove();
                
                // Redirect based on mode
                if (isChallengeVictory) {
                    window.location.href = 'challenge.html';
                } else {
                    window.location.href = 'map.html';
                }
            };

            btnRow.appendChild(ok);
            panel.appendChild(btnRow);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
        }

        })();
        </script>
</body>
</html>