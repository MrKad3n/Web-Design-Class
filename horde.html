<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horde Mode</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
        }

        .horde-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 68, 68, 0.1);
            border-radius: 15px;
            border: 2px solid #ff4444;
        }

        .header h1 {
            margin: 0 0 10px 0;
            font-size: 48px;
            color: #ff4444;
            text-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .wave-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 24px;
        }

        .power-display {
            color: #ffaa00;
            font-weight: bold;
        }

        .warning {
            background: rgba(255, 136, 0, 0.2);
            border: 2px solid #ff8800;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
        }

        .warning-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .enemies-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(255, 68, 68, 0.3);
        }

        .enemies-section h2 {
            margin: 0 0 20px 0;
            color: #ff4444;
            font-size: 28px;
        }

        .enemies-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .enemy-card {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 68, 68, 0.4);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .enemy-image {
            width: 100%;
            height: 150px;
            object-fit: contain;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .enemy-name {
            font-size: 18px;
            font-weight: bold;
            color: #ff4444;
            margin: 10px 0;
        }

        .enemy-tier {
            font-size: 14px;
            color: #ffaa00;
            margin: 5px 0;
        }

        .enemy-level {
            font-size: 14px;
            color: #aaa;
        }

        .rewards-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(255, 68, 68, 0.3);
        }

        .rewards-section h2 {
            margin: 0 0 20px 0;
            color: #ff4444;
            font-size: 24px;
        }

        .reward-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .reward-label {
            font-weight: bold;
            color: #ffaa00;
            font-size: 16px;
        }

        .reward-value {
            color: #00ff00;
            font-weight: bold;
            font-size: 18px;
        }

        .buttons-section {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .start-button {
            flex: 1;
            padding: 20px;
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            border: none;
            border-radius: 10px;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.5);
        }

        .claim-button {
            flex: 1;
            padding: 20px;
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            border: none;
            border-radius: 10px;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .claim-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 0, 0.5);
        }

        .claim-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .back-button {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #666 0%, #444 100%);
            border: 2px solid #888;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: center;
            box-sizing: border-box;
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .stats-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin: 3px 0;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="horde-container">
        <div class="header">
            <h1>üî• HORDE MODE üî•</h1>
            <div class="wave-info-header">
                <span>Wave <span id="currentWaveNumber">1</span></span>
                <span class="power-display">‚ö° Power: <span id="wavePower">3</span></span>
                <span>Highest: <span id="highestWave">0</span></span>
            </div>
        </div>

        <div class="warning">
            <span class="warning-icon">‚ö†Ô∏è</span>
            Losing this wave will forfeit all unclaimed rewards!
            <span class="warning-icon">‚ö†Ô∏è</span>
        </div>

        <div class="main-content">
            <div class="enemies-section">
                <h2>Wave Enemies</h2>
                <div class="enemies-grid" id="enemiesGrid">
                    <!-- Enemies will be populated here -->
                </div>
            </div>

            <div class="rewards-section">
                <h2>Wave Rewards</h2>
                <div id="waveRewards">
                    <!-- Current wave rewards -->
                </div>

                <div class="stats-box" style="margin-top: 20px;">
                    <h3 style="margin-top: 0; color: #ffaa00;">Unclaimed Total</h3>
                    <div class="stat-row">
                        <span class="stat-label">üíé Gems:</span>
                        <span class="stat-value" id="totalGems">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">üî• Horde Tokens:</span>
                        <span class="stat-value" id="totalTokens">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">‚öîÔ∏è Items:</span>
                        <span class="stat-value" id="totalItems">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">‚ú® Enchants:</span>
                        <span class="stat-value" id="totalEnchants">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">üåü Relics:</span>
                        <span class="stat-value" id="totalRelics">0</span>
                    </div>
                </div>

                <div class="buttons-section">
                    <button class="start-button" onclick="startWave()">
                        ‚öîÔ∏è Start Wave
                    </button>
                </div>
                
                <div class="buttons-section">
                    <button class="claim-button" id="claimButton" onclick="claimRewards()">
                        üí∞ Claim & Exit
                    </button>
                </div>

                <div style="margin-top: 20px;">
                    <a href="select.html" class="back-button" onclick="return confirmBack()">‚Üê Back to Mode Select</a>
                </div>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
    <script>
        // Load horde progress from localStorage
        function loadHordeProgress() {
            const progress = JSON.parse(localStorage.getItem('hordeProgress') || '{}');
            return {
                currentWave: progress.currentWave || 1,
                highestWave: progress.highestWave || 0,
                unclaimedRewards: progress.unclaimedRewards || {
                    gems: 0,
                    tokens: 0,
                    items: [],
                    enchants: [],
                    relics: []
                }
            };
        }

        // Save horde progress to localStorage
        function saveHordeProgress(progress) {
            localStorage.setItem('hordeProgress', JSON.stringify(progress));
        }

        // Get player level from party stats
        function getPlayerLevel() {
            if (typeof PARTY_STATS === 'undefined') return 1;
            // PARTY_STATS is an object with keys ONE, TWO, THREE, etc.
            const member = PARTY_STATS.ONE || PARTY_STATS.TWO || PARTY_STATS.THREE;
            if (!member) return 1;
            return member.LEVEL || 1;
        }

        // Generate enemies based on power level
        function generateWaveEnemies(power, currentWave) {
            const enemies = [];
            const playerLevel = getPlayerLevel();
            
            // Check if ENEMY_BASE_STATS exists
            if (typeof ENEMY_BASE_STATS === 'undefined') {
                console.error('ENEMY_BASE_STATS not defined!');
                return enemies;
            }
            
            // Get all available enemies from ENEMY_BASE_STATS based on wave
            const tier1Enemies = Object.keys(ENEMY_BASE_STATS).filter(key => ENEMY_BASE_STATS[key].tier === 1);
            const tier2Enemies = Object.keys(ENEMY_BASE_STATS).filter(key => ENEMY_BASE_STATS[key].tier === 2);
            const tier3Enemies = Object.keys(ENEMY_BASE_STATS).filter(key => ENEMY_BASE_STATS[key].tier === 3);
            const tier4Enemies = currentWave > 10 ? Object.keys(ENEMY_BASE_STATS).filter(key => ENEMY_BASE_STATS[key].tier === 4) : [];
            const tier5Enemies = currentWave > 25 ? Object.keys(ENEMY_BASE_STATS).filter(key => ENEMY_BASE_STATS[key].tier === 5) : [];
            
            let remainingPower = power;
            
            // Generate random enemy composition that equals the power level
            while (remainingPower > 0) {
                if (remainingPower >= 8 && Math.random() > 0.85 && tier5Enemies.length > 0) {
                    // Add a tier 5 enemy
                    const enemyKey = tier5Enemies[Math.floor(Math.random() * tier5Enemies.length)];
                    const enemy = ENEMY_BASE_STATS[enemyKey];
                    enemies.push({
                        key: enemyKey,
                        name: enemy.name || enemyKey,
                        tier: 5,
                        level: playerLevel,
                        image: enemy.image || 'Enemies/placeholder.png'
                    });
                    remainingPower -= 8;
                } else if (remainingPower >= 5 && Math.random() > 0.75 && tier4Enemies.length > 0) {
                    // Add a tier 4 enemy
                    const enemyKey = tier4Enemies[Math.floor(Math.random() * tier4Enemies.length)];
                    const enemy = ENEMY_BASE_STATS[enemyKey];
                    enemies.push({
                        key: enemyKey,
                        name: enemy.name || enemyKey,
                        tier: 4,
                        level: playerLevel,
                        image: enemy.image || 'Enemies/placeholder.png'
                    });
                    remainingPower -= 5;
                } else if (remainingPower >= 3 && Math.random() > 0.6 && tier3Enemies.length > 0) {
                    // Add a tier 3 enemy
                    const enemyKey = tier3Enemies[Math.floor(Math.random() * tier3Enemies.length)];
                    const enemy = ENEMY_BASE_STATS[enemyKey];
                    enemies.push({
                        key: enemyKey,
                        name: enemy.name || enemyKey,
                        tier: 3,
                        level: playerLevel,
                        image: enemy.image || 'Enemies/placeholder.png'
                    });
                    remainingPower -= 3;
                } else if (remainingPower >= 2 && Math.random() > 0.4 && tier2Enemies.length > 0) {
                    // Add a tier 2 enemy
                    const enemyKey = tier2Enemies[Math.floor(Math.random() * tier2Enemies.length)];
                    const enemy = ENEMY_BASE_STATS[enemyKey];
                    enemies.push({
                        key: enemyKey,
                        name: enemy.name || enemyKey,
                        tier: 2,
                        level: playerLevel,
                        image: enemy.image || 'Enemies/placeholder.png'
                    });
                    remainingPower -= 2;
                } else if (remainingPower >= 1 && tier1Enemies.length > 0) {
                    // Add a tier 1 enemy
                    const enemyKey = tier1Enemies[Math.floor(Math.random() * tier1Enemies.length)];
                    const enemy = ENEMY_BASE_STATS[enemyKey];
                    enemies.push({
                        key: enemyKey,
                        name: enemy.name || enemyKey,
                        tier: 1,
                        level: playerLevel,
                        image: enemy.image || 'Enemies/placeholder.png'
                    });
                    remainingPower -= 1;
                } else {
                    // Fallback: add tier 1 if stuck
                    break;
                }
            }
            
            return enemies;
        }

        // Calculate rewards based on power using luck-based distribution
        function calculateWaveRewards(power, currentWave = 1) {
            const playerLevel = getPlayerLevel();
            
            // Calculate luck bonus based on wave number
            // Wave 1: 0% luck, Wave 10: 45% luck, Wave 20: 95% luck, Wave 30+: 145% luck
            const luckBonus = Math.min(145, (currentWave - 1) * 5);
            
            const rewards = {
                gems: power * 5, // 5 gems per power (nerfed from 10)
                tokens: power * 2, // 2 tokens per power (no power cost)
                items: [],
                enchants: [],
                relics: [],
                luckBonus: luckBonus // Store for display
            };
            
            // Distribute power among items, enchants, and relics using weighted random selection
            // Item = 3 power, Enchant = 5 power, Relic = 10 power
            let remainingPower = power;
            const rewardTypes = [];
            
            // Keep selecting rewards until we run out of power
            while (remainingPower >= 3) {
                // Calculate weights based on remaining power
                const weights = [];
                if (remainingPower >= 3) weights.push({ type: 'item', cost: 3, weight: 5 });
                if (remainingPower >= 5) weights.push({ type: 'enchant', cost: 5, weight: 3 });
                if (remainingPower >= 10) weights.push({ type: 'relic', cost: 10, weight: 1 });
                
                if (weights.length === 0) break;
                
                // Select random reward based on weights
                const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
                let random = Math.random() * totalWeight;
                let selected = weights[0];
                
                for (const option of weights) {
                    random -= option.weight;
                    if (random <= 0) {
                        selected = option;
                        break;
                    }
                }
                
                rewardTypes.push(selected.type);
                remainingPower -= selected.cost;
            }
            
            // Generate actual rewards
            for (const type of rewardTypes) {
                if (type === 'item' && typeof window.generateRandomItem === 'function') {
                    const item = window.generateRandomItem(playerLevel, null, luckBonus);
                    if (item) rewards.items.push(item);
                } else if (type === 'enchant') {
                    // Select specific enchant from available list
                    const enchantmentList = [
                        "Sharpness", "Lifesteal", "Burning", "Fortification", "Swiftness",
                        "Vitality", "Hemorrhage", "Precision", "Arcane Power", "Berserker",
                        "Resilience", "Haste", "Frost", "Vengeance", "Warding",
                        "Multistrike", "Soulrend", "Phoenix Rebirth", "Temporal Flux", "Chaos Storm"
                    ];
                    const randomEnchant = enchantmentList[Math.floor(Math.random() * enchantmentList.length)];
                    rewards.enchants.push(randomEnchant);
                } else if (type === 'relic') {
                    const relicNames = [
                        'Heart of the Phoenix',
                        'Bloodthirsty Fang',
                        'Amulet of Haste',
                        'Mana Crystal',
                        'Titan\'s Bulwark'
                    ];
                    const randomRelic = relicNames[Math.floor(Math.random() * relicNames.length)];
                    rewards.relics.push(randomRelic);
                }
            }
            
            return rewards;
        }

        // Display wave enemies
        function displayWaveEnemies(enemies) {
            const enemiesGrid = document.getElementById('enemiesGrid');
            enemiesGrid.innerHTML = '';
            
            enemies.forEach(enemy => {
                const card = document.createElement('div');
                card.className = 'enemy-card';
                card.innerHTML = `
                    <img src="${enemy.image}" class="enemy-image" alt="${enemy.name}">
                    <div class="enemy-name">${enemy.name}</div>
                    <div class="enemy-tier">Tier ${enemy.tier}</div>
                    <div class="enemy-level">Level ${enemy.level}</div>
                `;
                enemiesGrid.appendChild(card);
            });
        }

        // Display wave rewards
        function displayWaveRewards(rewards) {
            const waveRewardsDiv = document.getElementById('waveRewards');
            waveRewardsDiv.innerHTML = '';
            
            // Show luck bonus if present
            if (rewards.luckBonus > 0) {
                const luckDiv = document.createElement('div');
                luckDiv.className = 'reward-item';
                luckDiv.style.borderBottom = '1px solid rgba(255, 215, 0, 0.3)';
                luckDiv.style.paddingBottom = '8px';
                luckDiv.style.marginBottom = '8px';
                luckDiv.innerHTML = `
                    <span class="reward-label">üçÄ Luck Bonus:</span>
                    <span class="reward-value" style="color: #4af;">${rewards.luckBonus}%</span>
                `;
                waveRewardsDiv.appendChild(luckDiv);
            }
            
            // Simple rewards (gems, tokens)
            if (rewards.gems > 0) {
                const rewardDiv = document.createElement('div');
                rewardDiv.className = 'reward-item';
                rewardDiv.innerHTML = `
                    <span class="reward-label">üíé Gems:</span>
                    <span class="reward-value">+${rewards.gems}</span>
                `;
                waveRewardsDiv.appendChild(rewardDiv);
            }
            
            if (rewards.tokens > 0) {
                const rewardDiv = document.createElement('div');
                rewardDiv.className = 'reward-item';
                rewardDiv.innerHTML = `
                    <span class="reward-label">üî• Horde Tokens:</span>
                    <span class="reward-value">+${rewards.tokens}</span>
                `;
                waveRewardsDiv.appendChild(rewardDiv);
            }
            
            // Items - show each item with name and level
            if (rewards.items && rewards.items.length > 0) {
                rewards.items.forEach(item => {
                    const rewardDiv = document.createElement('div');
                    rewardDiv.className = 'reward-item';
                    const rarityColor = typeof window.getRarityColor === 'function' ? window.getRarityColor(item.rarity) : '#fff';
                    rewardDiv.innerHTML = `
                        <span class="reward-label">‚öîÔ∏è Item:</span>
                        <span class="reward-value" style="color: ${rarityColor};">${item.name} (Lv ${item.level})</span>
                    `;
                    waveRewardsDiv.appendChild(rewardDiv);
                });
            }
            
            // Enchants
            if (rewards.enchants && rewards.enchants.length > 0) {
                rewards.enchants.forEach(enchant => {
                    const rewardDiv = document.createElement('div');
                    rewardDiv.className = 'reward-item';
                    rewardDiv.innerHTML = `
                        <span class="reward-label">‚ú® Enchant:</span>
                        <span class="reward-value">${enchant}</span>
                    `;
                    waveRewardsDiv.appendChild(rewardDiv);
                });
            }
            
            // Relics
            if (rewards.relics && rewards.relics.length > 0) {
                rewards.relics.forEach(relic => {
                    const rewardDiv = document.createElement('div');
                    rewardDiv.className = 'reward-item';
                    rewardDiv.innerHTML = `
                        <span class="reward-label">üåü Relic:</span>
                        <span class="reward-value" style="color: #ff8800;">${relic}</span>
                    `;
                    waveRewardsDiv.appendChild(rewardDiv);
                });
            }
        }

        // Display unclaimed totals
        function displayUnclaimedTotals(unclaimed) {
            document.getElementById('totalGems').textContent = unclaimed.gems || 0;
            document.getElementById('totalTokens').textContent = unclaimed.tokens || 0;
            document.getElementById('totalItems').textContent = (unclaimed.items || []).length;
            document.getElementById('totalEnchants').textContent = (unclaimed.enchants || []).length;
            document.getElementById('totalRelics').textContent = (unclaimed.relics || []).length;
            
            // Enable/disable claim button
            const hasRewards = unclaimed.gems > 0 || unclaimed.tokens > 0 || 
                             unclaimed.items.length > 0 || unclaimed.enchants.length > 0 || 
                             unclaimed.relics.length > 0;
            document.getElementById('claimButton').disabled = !hasRewards;
        }

        // Initialize the page
        function initHordeMode() {
            const progress = loadHordeProgress();
            const currentWave = progress.currentWave;
            const power = 2 + currentWave; // Power = 3 for wave 1, 4 for wave 2, etc.
            
            // Update header
            document.getElementById('currentWaveNumber').textContent = currentWave;
            document.getElementById('wavePower').textContent = power;
            document.getElementById('highestWave').textContent = progress.highestWave;
            
            // Check if we have saved enemies for this wave
            let enemies, rewards;
            const savedWaveKey = `hordeWave_${currentWave}`;
            const savedWaveData = localStorage.getItem(savedWaveKey);
            
            if (savedWaveData) {
                // Use saved enemies from this wave
                try {
                    const parsed = JSON.parse(savedWaveData);
                    enemies = parsed.enemies;
                    rewards = parsed.rewards;
                } catch(e) {
                    console.error('Failed to parse saved wave data:', e);
                    enemies = generateWaveEnemies(power, currentWave);
                    rewards = calculateWaveRewards(power, currentWave);
                }
            } else {
                // Generate new enemies and save them
                enemies = generateWaveEnemies(power, currentWave);
                rewards = calculateWaveRewards(power, currentWave);
                
                // Save this wave's enemies so they persist
                localStorage.setItem(savedWaveKey, JSON.stringify({
                    enemies: enemies,
                    rewards: rewards
                }));
            }
            
            displayWaveEnemies(enemies);
            displayWaveRewards(rewards);
            
            // Display unclaimed totals
            displayUnclaimedTotals(progress.unclaimedRewards);
            
            // Store current wave data for battle
            sessionStorage.setItem('currentHordeWave', JSON.stringify({
                wave: currentWave,
                power: power,
                enemies: enemies,
                rewards: rewards
            }));
        }

        // Start wave - go to battle
        function startWave() {
            const waveData = JSON.parse(sessionStorage.getItem('currentHordeWave'));
            window.location.href = `battle.html?mode=horde&wave=${waveData.wave}&power=${waveData.power}`;
        }

        // Claim rewards
        function claimRewards() {
            const progress = loadHordeProgress();
            const unclaimed = progress.unclaimedRewards;
            
            if (!unclaimed || (unclaimed.gems === 0 && unclaimed.tokens === 0 && 
                unclaimed.items.length === 0 && unclaimed.enchants.length === 0 && 
                unclaimed.relics.length === 0)) {
                alert('No rewards to claim!');
                return;
            }
            
            // Add gems - sync with global GEMS variable
            if (unclaimed.gems > 0) {
                const currentGems = parseInt(localStorage.getItem('gems')) || 0;
                const newGemTotal = currentGems + unclaimed.gems;
                localStorage.setItem('gems', newGemTotal);
                
                // Sync with global GEMS variable if it exists
                if (typeof window.GEMS !== 'undefined') {
                    window.GEMS = newGemTotal;
                }
            }
            
            // Add tokens
            if (unclaimed.tokens > 0) {
                const currentTokens = parseInt(localStorage.getItem('hordeTokens')) || 0;
                localStorage.setItem('hordeTokens', currentTokens + unclaimed.tokens);
            }
            
            // Add items to INVENTORY
            if (unclaimed.items && unclaimed.items.length > 0 && typeof INVENTORY !== 'undefined') {
                // Build set of occupied slots
                const occupiedSlots = new Set();
                INVENTORY.forEach(invItem => {
                    if (invItem && !invItem.equipped && invItem.slotIndex !== undefined) {
                        occupiedSlots.add(invItem.slotIndex);
                    }
                });
                
                unclaimed.items.forEach((item, itemIndex) => {
                    // Assign first available slot
                    for (let slotNum = 0; slotNum < 125; slotNum++) {
                        if (!occupiedSlots.has(slotNum)) {
                            item.slotIndex = slotNum;
                            occupiedSlots.add(slotNum);
                            break;
                        }
                    }
                    // Ensure unique ID
                    if (!item._uid) {
                        item._uid = `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${itemIndex}`;
                    }
                    item.equipped = false;
                    INVENTORY.push(item);
                });
                
                // Save to localStorage
                if (typeof saveGameData === 'function') saveGameData();
            }
            
            // Add enchants to ENCHANTMENT_INVENTORY
            if (unclaimed.enchants && unclaimed.enchants.length > 0) {
                if (typeof window.ENCHANTMENT_INVENTORY === 'undefined') {
                    window.ENCHANTMENT_INVENTORY = {};
                }
                
                unclaimed.enchants.forEach(enchantName => {
                    window.ENCHANTMENT_INVENTORY[enchantName] = (window.ENCHANTMENT_INVENTORY[enchantName] || 0) + 1;
                });
                
                // Save to localStorage
                localStorage.setItem('enchantmentInventory', JSON.stringify(window.ENCHANTMENT_INVENTORY));
            }
            
            // Add relics to INVENTORY system like items
            if (unclaimed.relics && unclaimed.relics.length > 0) {
                unclaimed.relics.forEach(relicName => {
                    // Find relic in ITEM_TABLE
                    const relicData = Object.values(window.ITEM_TABLE || {}).find(item => item.name === relicName);
                    if (!relicData) return;
                    
                    // Create relic item object
                    const relicItem = {
                        ...relicData,
                        slotIndex: null,
                        equipped: false,
                        uid: Date.now() + Math.random(),
                        level: getPlayerLevel()
                    };
                    
                    // Add to INVENTORY
                    if (typeof window.INVENTORY !== 'undefined') {
                        window.INVENTORY.push(relicItem);
                    }
                });
                
                // Save game data
                if (typeof window.saveGameData === 'function') {
                    window.saveGameData();
                }
            }
            
            // Clear unclaimed rewards
            progress.unclaimedRewards = {
                gems: 0,
                tokens: 0,
                items: [],
                enchants: [],
                relics: []
            };
            
            // Reset to wave 1 when claiming rewards
            progress.currentWave = 1;
            
            saveHordeProgress(progress);
            
            // Clear all saved wave data so fresh enemies generate
            for (let i = 1; i <= 100; i++) {
                localStorage.removeItem(`hordeWave_${i}`);
            }
            
            alert('Rewards claimed successfully! Starting fresh from Wave 1.');
            window.location.href = 'select.html';
        }

        // Confirm back navigation
        function confirmBack() {
            const progress = loadHordeProgress();
            const hasRewards = progress.unclaimedRewards && 
                             (progress.unclaimedRewards.gems > 0 || 
                              progress.unclaimedRewards.tokens > 0 || 
                              (progress.unclaimedRewards.items && progress.unclaimedRewards.items.length > 0) ||
                              (progress.unclaimedRewards.enchants && progress.unclaimedRewards.enchants.length > 0) ||
                              (progress.unclaimedRewards.relics && progress.unclaimedRewards.relics.length > 0));
            
            if (hasRewards) {
                return confirm('‚ö†Ô∏è You have unclaimed rewards! Leaving will NOT lose them, but you should claim them first. Continue?');
            }
            return true;
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', initHordeMode);
    </script>
</body>
</html>
